[{"content":"先稍微記錄一下，整體建置與工作流程：\nhugo官網找喜歡的theme(https://themes.gohugo.io/) 選擇使用Stack(https://themes.gohugo.io/themes/hugo-theme-stack/) 作者github裡面有教學，可以直接clone代碼匯入我的github repositiry 新repositiry名稱使用：github帳號id.github.io git clone代碼到本機，hugo server執行看看，打上http://localhost:1313，就能直接看到頁面效果 修改手機版無法看到大綱toc問題(直接複製貼上裡面四個檔案到相對的目錄中) 參考網站(https://github.com/CaiJimmy/hugo-theme-stack/pull/615/files#diff-eef437e68bc6669e72d9b52c51e6f18c33aaedc919cd231abc1a68aa7030fcb3) 網站左邊menu 透明漂亮icon使用，svg檔製作 參考網站(https://tablericons.com/) 網站左邊page新增與修改 色碼表，網站各處顏色更改會用到 參考網站(https://www.ifreesite.com/color/) 開始優化美化頁面 參考網站(https://blog.linsnow.cn/p/modify-hugo/) 參考網站(https://ponder.lol/2023/custom-hugo-theme-stack/) 添加網站底部顯示發表xx文章、本站運行xx天、本站總訪問量xx次功能 參考網站(https://thirdshire.com/post/hugo-stack-renovation/) 修改文章description描述字體大小，縮小(在article.scss裡面的.article-subtitle) 添加disqus評論功能 參考網站(https://blog.tershi.com/pages/cafd93/#%E8%A8%BB%E5%86%8A-disqus-%E5%B8%B3%E8%99%9F) 添加channel.io頁面即時聊天功能 參考網站(https://thirdshire.com/post/hugo-stack-renovation/) 以上在本地修改與美化頁面功能驗證完畢後，將代碼推送到github中 使用github workflow建立自動發佈gh-pages branch功能 參考網站(https://www.zoeydc.com/zh/posts/2021-05-23-hugo-website_github-pages_custom-domain/) 網頁測試打(https://github帳號id.github.io)，網站是否呈現 購買domain name，我使用cloudflare(https://dash.cloudflare.com/) 購買domain name 更新DNS記錄，設定CNAME，名稱blog，內容github預設pages頁面網址(github帳號id.github.io) 啟用http強制轉到https 將github pages自訂網域名 至github專案中，Settings-\u0026gt;Pages-\u0026gt;Branch選擇gh-pages分支 Custom domain-\u0026gt;設定已註冊的domain name(blog.goldfishbrain-fighting.com) 網頁測試打domain name，網站是否呈現(https://blog.goldfishbrain-fighting.com/) google-search-console添加 會需要驗證網站擁有權，將google提供檔案放置網站根目錄下(static/googlexxxxxx.html) 添加sitemap，好讓google幫我們產生索引，後續才能夠過google瀏覽器，搜尋到我的網站(可能會需要好多天，才能完成) google-analytics添加 好讓後續可以分析網站使用狀況 以上就完成了使用hugo在github架站 後續新文章撰寫，我是使用obsidian撰寫文章 使用template功能，寫文章時，快速插入front matter 如果categories有新增，記得要先去categories目錄新增出來 如有快速貼上圖片，圖片記得改檔名，因為會有空格，網站會無法正常辨識路徑和檔名 撰寫文章完畢，使用obsidian git插件，直接使用快捷鍵ctrl+p叫出命令面板，執行Commit all changes、Push就能將文章推送到我的github中 github接收到commit，就會自動使用workflow幫我佈屬gh-pages 以下就是網站呈現的樣子 ","date":"2023-10-09T09:53:09+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/blog-hugo/","title":"我使用hugo在github架設我的第一個Blog"},{"content":"我選擇免費方案，每天能遊玩30分鐘，體驗一下 使用我的MACBOOK M1 PRO登入Counter-Strike 2中，需要排隊一下 下方就是我的遊玩體驗影片，很久沒玩CS，好爛 :) ","date":"2023-10-09T07:33:09+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/geforce-now/","title":"我的Macbook M1 Pro，使用Geforce Now遊玩Steam遊戲(Counter-Strike 2)"},{"content":"紀錄一下，為什麼要購買此課程，很久以前，就有這樣的目標，想要將英文這門語言學好， 礙於工作轉職、人生待辦事項優先順序，所以一直遲遲沒有開始。\n近期是在學習程式語言python與django，想要將工作更有效率的完成(辦公自動化)與管理平台化(網頁點一點完成需求)，陸陸續續學習了快一年了，開始覺得不是我的興趣，也常常會提不起勁繼續學習，或許是沒有能大量應用上的環境，變的學習時感覺很孤單、很無趣，也跟著導致我連生活也提不起勁，因為會覺得，有很多資料要看、要練習，但是要看、要練習時，就又會覺得提不起勁，就在這樣的心態上拉扯，也就因為這樣，導致生活和精神也越來越疲憊。\n因為上述的狀況，讓我心態有所轉變，人生還那麼長，還有很多事情等著我去探險與嘗試，於是就將人生待辦事項優先順序調整了，從影片去學習語言，讓學習不再那麼枯燥乏味，又能藉由影片瞭解更多新知與世界上發生了什麼事，同時也能讓我藉由這門語言，未來能與世界各地更拉近一點距離。\n我是直接購買12個月，一個月675台幣，無限堂學習，不強求變的多厲害，考什麼多益、雅思，只希望能在未來(1年之後)，遇到外國人，能與之簡單對談(不會害怕)，聽到電影影集，能夠聽懂在說什麼，最後給自己加油打氣，加油我一定行，堅持下去。\n現在夜深了，其實也該睡了。\n","date":"2023-10-09T01:37:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english/","title":"Lesson000 - 我開始使用VoiceTube-Hero學習英文"},{"content":"\n分享我自己平常使用剪映這個軟體，影片快速上字幕及冗言、停頓刪除。\nYouTube教學影片 ","date":"2023-10-08T12:38:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/capcut/","title":"剪映 - 影片快速上字幕及冗言、停頓刪除"},{"content":"今日大綱 Ansible自動化安裝Redis、Redis-Sentinel服務 Gitlab redis-config設定檔管理 創建project 將設定檔傳入 Ansible佈屬腳本撰寫 Jenkins Free-Style專案建立 創建Free-Style軟體專案 參數化構建 原始碼管理 Build Steps: Invoke Ansible Playbook 建置測試 Ansible自動化安裝Redis、Redis-Sentinel服務 # ansible佈屬腳本目錄 [root@ansible ansible]# ll 總計 24 -rw-r--r--. 1 root root 12593 9月 11 22:52 hosts drwxr-xr-x. 33 root root 4096 9月 12 21:05 roles -rw-r--r--. 1 root root 2091 9月 11 22:38 site.yml # 主機清單 [root@ansible ansible]# cat hosts [redis] 192.168.1.11 ansible_nodename=redis01 192.168.1.12 ansible_nodename=redis02 192.168.1.13 ansible_nodename=redis03 192.168.1.14 ansible_nodename=redis04 # 選擇要佈屬的主機和角色，使用become: yes(sudo su -) [root@ansible ansible]# cat site.yml - hosts: redis remote_user: root gather_facts: false become: yes roles: - roles/redis # 要佈屬的任務腳本 [root@ansible ansible]# cat roles/redis/tasks/main.yml # 執行佈屬 [root@ansible ansible]# ansible-playbook -i hosts site.yml --ask-pass PLAY RECAP ******************************************************************************************************************* 192.168.1.11 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.12 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.13 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.14 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 Gitlab redis-config設定檔管理 1. 創建project 2. 將設定檔傳入 # 使用已存在目錄的方式，將設定檔傳入 # 當前目錄 chenqingze@chenqingze-MBP redis-config-test % ll total 0 drwxr-xr-x@ 5 chenqingze staff 160 9 12 22:49 batch drwxr-xr-x@ 4 chenqingze staff 128 9 12 22:44 t1zone drwxr-xr-x@ 4 chenqingze staff 128 9 12 22:45 t2zone # 傳入gitlab chenqingze@chenqingze-MBP redis-config-test % git init Initialized empty Git repository in /Users/chenqingze/Desktop/redis-config-test/redis-config-test/.git/ chenqingze@chenqingze-MBP redis-config-test % git remote add origin http://gitlab.jimmyhome.tw/root/redis-config-test.git chenqingze@chenqingze-MBP redis-config-test % git add . chenqingze@chenqingze-MBP redis-config-test % git commit -m \u0026#34;Initial commit\u0026#34; chenqingze@chenqingze-MBP redis-config-test % git branch -m main master chenqingze@chenqingze-MBP redis-config-test % git push -u origin master Enumerating objects: 19, done. Counting objects: 100% (19/19), done. Delta compression using up to 10 threads Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 45.79 KiB | 7.63 MiB/s, done. Total 19 (delta 6), reused 0 (delta 0), pack-reused 0 To http://gitlab.jimmyhome.tw/root/redis-config-test.git * [new branch] master -\u0026gt; master branch \u0026#39;master\u0026#39; set up to track \u0026#39;origin/master\u0026#39;. redis-sentinel.conf -\u0026gt; redis-sentinel設定檔 redis.conf -\u0026gt; redis設定檔 sentinel-users.acl -\u0026gt; redis-sentinel的acl設定檔 users.acl -\u0026gt; redis的acl設定檔 Ansible佈屬腳本撰寫 1. 變數定義與獲取、判斷輸入選項(Jenkins本地端操作) 1. 獲取項目的工作目錄 {{ workspace.stdout }} 2. 確認function是否沒有選擇，沒有選擇，報錯終止流程 3. 確認masterip不能沒有輸入，沒有輸入，報錯終止流程 4. 確認masterip只能一個，一個以上則報錯，報錯終止流程 5. 確認slaveip不能沒有輸入，沒有輸入，報錯終止流程 2. masterip開始流程 0. 確認Redis服務是否活著，活著的話，報錯終止流程 0. 確認Redis-Sentinel服務是否活著，活著的話，報錯終止流程 1. 拷貝檔案至遠端主機 2. 替換redis-sentinel.conf配置文件，將masterip寫入 3. slaveip開始流程 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 1. 拷貝檔案至遠端主機 2. 替換redis-sentinel.conf配置文件，將masterip寫入 3. 將slaveof masterip 6379寫入redis.conf配置文件 4. all開始流程 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 1. 啟動，開機自啟動redis服務 2. 確認Redis服務是否正常啟動，不啟動的話，報錯終止流程 3. 啟動，開機自啟動redis-sentinel服務 4. 確認Redis-Sentinel服務是否正常啟動，不啟動的話，報錯終止流程 redis-sentinel剛啟動連接，需要一點時間偵測，所以流程暫停5秒 5. 查看Redis-Sentinel狀態連接狀態(/usr/local/bin/redis-cli -p 26379 info | grep -i {{ function }}) [root@ansible ansible]# cat se_redis-config-test_deploy.yml ##################變數定義與獲取、判斷輸入選項(Jenkins本地端操作)################### - hosts: all gather_facts: no tasks: # 1. 獲取項目的工作目錄 {{ workspace.stdout }} - name: Get WorkSpace Work Path shell: cmd: \u0026#34;echo ${WORKSPACE}\u0026#34; register: workspace delegate_to: 127.0.0.1 # 2. 確認function是否沒有選擇，沒有選擇，報錯終止流程 - name: Check Function Choice shell: cmd: \u0026#34;echo {{ function }} | wc -w\u0026#34; register: is_function delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_function.stdout\u0026#34; # 3. 確認masterip不能沒有輸入，沒有輸入，報錯終止流程 - name: Check Masterip Input shell: cmd: \u0026#34;echo {{ masterip }} | wc -w\u0026#34; register: is_masterip delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_masterip.stdout\u0026#34; # 4. 確認masterip只能一個，一個以上則報錯，報錯終止流程 - name: Check Masterip Count shell: cmd: \u0026#34;echo -e \u0026#39;{{ masterip }}\u0026#39; | wc -l\u0026#34; register: is_masterip delegate_to: 127.0.0.1 failed_when: \u0026#34;is_masterip.stdout \u0026gt; \u0026#39;1\u0026#39;\u0026#34; # 5. 確認slaveip不能沒有輸入，沒有輸入，報錯終止流程 - name: Check Slaveip Input shell: cmd: \u0026#34;echo {{ slaveip }} | wc -w\u0026#34; register: is_slaveip delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_slaveip.stdout\u0026#34; ################################masterip開始流程################################### - hosts: \u0026#34;{{ masterip }}\u0026#34; gather_facts: no tasks: # 0. 確認Redis服務是否活著，活著的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否活著，活著的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 拷貝檔案至遠端主機 - name: Copy Filepath To Remote Server copy: src: \u0026#34;{{ workspace.stdout }}/{{ zone }}/{{ function }}/\u0026#34; dest: \u0026#34;/usr/local/redis/\u0026#34; owner: redis group: redis mode: \u0026#39;0644\u0026#39; # 2. 替換redis-sentinel.conf配置文件，將masterip寫入 - name: Replace Masterip To redis-sentinel.conf shell: \u0026#34;sed -i \u0026#39;s/o.o.o.o/{{ masterip }}/g\u0026#39; /usr/local/redis/redis-sentinel.conf\u0026#34; ################################slaveip開始流程################################### - hosts: \u0026#34;{{ slaveip }}\u0026#34; gather_facts: no tasks: # 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 拷貝檔案至遠端主機 - name: Copy Filepath To Remote Server copy: src: \u0026#34;{{ workspace.stdout }}/{{ zone }}/{{ function }}/\u0026#34; dest: \u0026#34;/usr/local/redis/\u0026#34; owner: redis group: redis mode: \u0026#39;0644\u0026#39; # 2. 替換redis-sentinel.conf配置文件，將masterip寫入 - name: Replace Masterip To redis-sentinel.conf shell: \u0026#34;sed -i \u0026#39;s/o.o.o.o/{{ masterip }}/g\u0026#39; /usr/local/redis/redis-sentinel.conf\u0026#34; # 3. 將slaveof masterip 6379寫入redis.conf配置文件 - name: Add Slaveof To redis.conf blockinfile: path: /usr/local/redis/redis.conf block: | slaveof {{ masterip }} 6379 ##################################all開始流程##################################### - hosts: all gather_facts: no tasks: # 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 啟動，開機自啟動redis服務 # 2. 確認Redis服務是否正常啟動，不啟動的話，報錯終止流程 - name: Enabled、Started Redis systemd: name: redis enabled: true state: started - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;failed\u0026#39; in command_result.stdout or \u0026#39;unknown\u0026#39; in command_result.stdout or \u0026#39;inactive\u0026#39; in command_result.stdout\u0026#34; # 3. 啟動，開機自啟動redis-sentinel服務 # 4. 確認Redis-Sentinel服務是否正常啟動，不啟動的話，報錯終止流程 - name: Enabled、Started Redis-Sentinel systemd: name: redis-sentinel enabled: true state: started - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;failed\u0026#39; in command_result.stdout or \u0026#39;unknown\u0026#39; in command_result.stdout or \u0026#39;inactive\u0026#39; in command_result.stdout\u0026#34; # redis-sentinel剛啟動連接，需要一點時間偵測，所以流程暫停5秒 - name: Pause for 5 seconds to build app cache pause: seconds: 5 # 5. 查看Redis-Sentinel狀態連接狀態(/usr/local/bin/redis-cli -p 26379 info | grep -i web-front) - name: Check Redis-Sentinel info shell: \u0026#34;/usr/local/bin/redis-cli -p 26379 info | grep -i {{ function }}\u0026#34; register: \u0026#34;command_result\u0026#34; args: warn: no ignore_errors: True - name: Runcommand Redis-Sentinel info Msg debug: msg: \u0026#34;{{ command_result.stdout_lines }}\u0026#34; ignore_errors: True Jenkins Free-Style專案建立 1. 創建Free-Style軟體專案 2. 參數化構建 Active Choices Parameter Active Choices Reactive Parameter 文字參數 文字參數 使用ansible這台主機來跑佈屬流程 3. 原始碼管理 原始碼管理(連接Gitlab) ##### Gitlab複製下來的clone http://gitlab.jimmyhome.tw/root/redis-config-test.git ##### Credential 連接gitlab帳號和密碼 4. Build Steps: Invoke Ansible Playbook Invoke Ansible Playbook ##### ansible腳本位置 Playbook path: /root/ansible/se_redis-config-test_deploy.yml ##### Inventory主機IP 以下撰寫方式，ip都會傳入 連接要佈屬的主機，使用帳號，我這裡用key， 所以我有從ansible主機，產生key，ssh-copy-id 要佈屬的主機 [root@ansible ~]# ssh-copy-id 192.168.1.11 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026#34;/root/.ssh/id_rsa.pub\u0026#34; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@192.168.1.11\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh \u0026#39;192.168.1.11\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. [root@ansible ~]# ssh-copy-id 192.168.1.12 [root@ansible ~]# ssh-copy-id 192.168.1.13 [root@ansible ~]# ssh-copy-id 192.168.1.14 Jenkins參數，要傳入ansible內 Extra Variables 5. 建置測試 可以看到，zone選擇，function也會跟著變動 輸入IP處，slaveip可以輸入多個 可以看到，redis-sentinel已經成功啟動，有偵測到目前master是誰，也偵測到slaves主機有3台，總共4台主機啟動sentinel服務 進redis主機直接確認，使用redis-cli登入，選擇index 1， set 1個key為test value為1 get key test，value為1 [root@redis01 redis]# redis-cli 127.0.0.1:6379\u0026gt; select 1 OK 127.0.0.1:6379[1]\u0026gt; set test 1 OK 127.0.0.1:6379[1]\u0026gt; get test \u0026#34;1\u0026#34; [root@redis01 redis]# redis-cli -p 26379 master0:name=search,status=ok,address=192.168.1.11:6379,slaves=3,sentinels=4 可以看到，如果再次佈屬，會顯示失敗，因為主機redis和redis-sentinel服務如果是active狀態，就不能佈屬(腳本一開始就有添加此段）， 防止輸入IP輸錯，導致設定檔覆蓋，營運中的redis服務異常 YouTube教學影片 ","date":"2023-10-08T11:49:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/devops-jenkins-gitlab-ansible-redis/","title":"Jenkins+Gitlab+Ansible 版控與佈屬 Redis Redis-Sentinel集群"},{"content":"今日内容概要 python基本數據類型 與使用者交互 格式化輸出 基本運算符 多種賦值方式 邏輯運算符 成員運算符 身份運算符 基本數據類型之布爾值bool 1.用來判斷事物的對錯 是否可行 只要用於流程控制中 2.只有兩種狀態 True 對的 真的 可行的 False 錯的 假的 不可行的 3.python中所有數據都自帶布爾值 布爾值為False的數據有：0 None \u0026#39;\u0026#39; [] {} 布爾值為True的數據有：除了上面的都是True 4.存儲布爾值的變數名一般推薦使用is開頭 is_delete = False is_alive = True \u0026#34;\u0026#34;\u0026#34; 很多程式中提供的註銷帳戶的功能 其實底層並沒有刪除數據 而是修改了數據的狀態 id\tusername\tpassword phone is_delete 1\tjimmy\t123\t110 1 2\tkevin\t321\t120\t0 \u0026#34;\u0026#34;\u0026#34; EX： 基本數據類型之元組tuple 1.也稱為『不可變』的列表 元組內索引綁定的記憶體位址不能修改 2.小括弧括起來 內部存放多個數據值 數據值與數據值之間逗號隔開 數據值可以是任何數據類型 3.代碼實現 t1 = (11, 22, \u0026#39;jimmy\u0026#39;) 4.元組與列表的對比 # 列表 l1 = [11, 22, 33] print(l1[0]) # 獲取索引0對應的數據值 l1[0] = 666 print(l1) # [666, 22, 33] # 元組 t1 = (11, 22, 33) print(t1[0]) t1[0] = 999 print(t1) # 報錯 # 練習題 元組混列表 t1 = (11, 22, [111, 222]) t1[2][1] = 666 print(t1) # (11, 22, [111, 666]) \u0026#34;\u0026#34;\u0026#34; A.直接報錯 B.(11, 22, [111, 666]) C.不知道 超出了我的認知 \u0026#34;\u0026#34;\u0026#34; 5.元組內如果只有一個數據值 t1 = (1) t2 = (11.11) t3 = (\u0026#39;Jimmy\u0026#39;) print(type(t1), type(t2), type(t3)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; t1 = (1,) t2 = (11.11,) t3 = (\u0026#39;Jimmy\u0026#39;,) print(type(t1), type(t2), type(t3)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026#34;\u0026#34;\u0026#34; 建議：以後在使用可以存放多個數據值的數據類型時 如果裡面暫時只有一個數據值 那麼也建議你加上逗號 \u0026#34;\u0026#34;\u0026#34; EX1：元組與列表的對比\n列表： 圖解： 元組： 圖解： EX2：練習題 元組混列表 圖解：\nEX3：元組內如果只有一個數據值\n基本數據類型之集合set 1.集合只能用於去重和關係運算 後面再講 暫且忽略 2.集合內數據只能是不可變類型 後面再講 暫且忽略 3.大括弧括起來 內部存放多個數據值 數據值與數據值之間逗號隔開 數據值不是k：v鍵值對 4.代碼實現 s1 = {1, 2, 3, 4, 5, 6} 5.定義空集合與空字典\t{} 預設是字典 set() 定義空集合 EX1：定義空集合\n與使用者交互 1.獲取使用者輸入 input # 獲取使用者輸入 username = input(\u0026#39;請輸入您的使用者名\u0026gt;\u0026gt;\u0026gt;：\u0026#39;) \u0026#34;\u0026#34;\u0026#34; 1.先執行input獲取用戶輸入 2.將輸入的數據綁定給變數名username 3.以後在程式中就可以使用變數名反覆調用用戶數據 \u0026#34;\u0026#34;\u0026#34; 強調：input獲取到的數據都會統一處理成字串類型 2.輸出內部資訊 print 1.括弧內既可以放數據值也可以放變數名 並且支援多個 逗號隔開即可 2.print自帶換行符 換行符：\\r\\n \\n(斜杠與字母組合到一起可能會產生特殊的含義) 3.print也可以切換結束符 print(數據,end=\u0026#39;預設是\\n\u0026#39;) 擴展：python2與python3中兩個關鍵字的區別 python2中 input方法需要使用者自己提前指定數據類型 寫什麼類型就是什麼類型 raw_input方法與python3中input一致 輸入的統一處理成字串\tpython2中 print方法有兩種使用方式 print 數據值 print(資料值) EX1：1.獲取使用者輸入\nEX2：input獲取到的數據都會統一處理成字串類型\nEX3：輸出內部資訊 EX4：2.print自帶換行符\nEX5：3.print也可以切換結束符 EX6：python2與python3中兩個關鍵字的區別\npython2\ninput方法需要使用者自己提前指定數據類型 寫什麼類型就是什麼類型 raw_input方法與python3中input一致 輸入的統一處理成字串\tpython2\nprint方法有兩種使用方式 print 數據值 print(資料值) 格式化輸出 提前定義好一些內容 將來需要使用的時候可以局部修改 代碼實現 在現實生活中大部分情況下使用下劃線提示別人填寫內容 但是在程式中需要使用佔位元：%s %d info = \u0026#39;%s同學你好\u0026#39; \u0026#39;\u0026#39;\u0026#39;單個佔位符\u0026#39;\u0026#39;\u0026#39; # print(info % \u0026#39;Jimmy\u0026#39;) # Jimmy同學你好 # print(\u0026#39;%s同學你好\u0026#39; % \u0026#39;Tony\u0026#39;) # Tony同學你好 # print(info % (\u0026#39;Jimmy\u0026#39;,)) # print(\u0026#39;%s同學你好\u0026#39; % (\u0026#39;Tony\u0026#39;,)) \u0026#39;\u0026#39;\u0026#39;多個佔位符\u0026#39;\u0026#39;\u0026#39; # desc = \u0026#39;姓名：%s 年齡：%s 愛好：%s\u0026#39; # print(desc % (\u0026#39;Jimmy\u0026#39;, 18, \u0026#39;read\u0026#39;)) # print(\u0026#39;姓名：%s 年齡：%s 愛好：%s\u0026#39; % (\u0026#39;tony\u0026#39;, 28, \u0026#39;rap\u0026#39;)) \u0026#39;\u0026#39;\u0026#39;注意事項：有幾個佔位符就需要幾個數據值\u0026#39;\u0026#39;\u0026#39; # print(\u0026#39;my name is %s my age is %s\u0026#39; % (\u0026#39;Jimmy\u0026#39;,)) # 少了不行 # print(\u0026#39;my name is %s my age is %s\u0026#39; % (\u0026#39;Jimmy\u0026#39;, 18, \u0026#39;read\u0026#39;)) # 多了不行 \u0026#39;\u0026#39;\u0026#39;不同佔位符的區別\u0026#39;\u0026#39;\u0026#39; # demo1 = \u0026#39;%s您好 您本月的話費是%s 餘額是%s\u0026#39; # %s常見數據類型都支援 # print(demo1 % (\u0026#39;Jimmy\u0026#39;, 100, 10000000000000)) # demo2 = \u0026#39;%d您好 您本月的話費是%d 餘額是%d\u0026#39; # %d只支援數字類型 # print(demo2 % (\u0026#39;tony\u0026#39;, 1000000000, -100000)) print(\u0026#39;%08d\u0026#39;% 123) # 00000123 print(\u0026#39;%08d\u0026#39;% 1234324324) # 1234324324 EX1：單個佔位符 EX2：多個佔位符\nEX3：注意事項：有幾個佔位符就需要幾個數據值\nEX4：不同佔位符的區別\n%s常見數據類型都支援 %d只支援數字類型 EX5：%d補位功能 基本運算符 以下假設變數： a=10，b=20：\n運算符 描述 實例 + 加 - 兩個物件相加 a + b 輸出結果 30 - 減 - 得到負數或是一個數減去另一個數 a - b 輸出結果 -10 * 乘 - 兩個數相乘或是返回一個被重複若干次的字串 a * b 輸出結果 200 / 除 - x除以y b / a 輸出結果 2 % 取餘 - 返回除法的餘數 b % a 输出结果 0 ** 次方 - 返回x的y次方 a**b 為10的20次方， 輸出結果 100000000000000000000 // 取整除 - 傳回商的整數部分（向下取整） \u0026raquo;\u0026gt;9//2 4, \u0026raquo;\u0026gt;-9//2 -5 1.數學運算符 + - * / % // ** 簡化寫法 n = 10 n += 1 # n = n + 1 n -= 1 # n = n - 1 n *= 1 # n = n * 1 n /= 1 # n = n / 1 n %= 1 # n = n % 1 n //= 1 # n = n // 1 n **= 1 # n = n ** 1 2.比較運算符 \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= ==(等於號) !=(不等於) 常用賦值符 1.鏈式賦值 # name = \u0026#39;jimmy\u0026#39; # name1 = name # name2 = name # 鏈式賦值 name = name1 = name2 = \u0026#39;jimmy\u0026#39; 2.交叉賦值 m = 100 n = 999 \u0026#39;\u0026#39;\u0026#39;讓m和n互相轉換綁定的值\u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34;奇葩式寫法\u0026#34;\u0026#34;\u0026#34; # m = n # n = m # print(m, n) # 999 999 \u0026#39;\u0026#39;\u0026#39;方式1:採用中間變數\u0026#39;\u0026#39;\u0026#39; # temp = m # m = n # n = temp # print(m, n) # 999 100 \u0026#39;\u0026#39;\u0026#39;方式2:交叉賦值語法\u0026#39;\u0026#39;\u0026#39; m, n = n, m print(m, n) # 999 100 3.解壓賦值 name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] \u0026#39;\u0026#39;\u0026#39;low的寫法\u0026#39;\u0026#39;\u0026#39; # name1 = name_list[0] # name2 = name_list[1] # name3 = name_list[2] # name4 = name_list[3] \u0026#39;\u0026#39;\u0026#39;解壓賦值語法\u0026#39;\u0026#39;\u0026#39; # name1, name2, name3, name4 = name_list \u0026#39;\u0026#39;\u0026#39;解壓賦值在使用的時候 正常情況下需要保證左邊的變數名與右邊的數據值個數一致\u0026#39;\u0026#39;\u0026#39; # a, b = name_list # 變數名少了不行 # a, b, c, d, e = name_list # 變數名多了也不行 \u0026#39;\u0026#39;\u0026#39;當需要解壓的數據個數特別多 並且我們只需要使用其中的幾個 那麼可以打破上述的規則\u0026#39;\u0026#39;\u0026#39; # a, *b = name_list # *會自動接收多餘的數據 組織成列表賦值給後面的變數名 # print(a) # jimmy # print(b) # [\u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] # a, c, *b = name_list # print(a) # print(c) # print(b) # [\u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] # a, *b, c = name_list # print(a) # jimmy # print(b) # [\u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;] # print(c) # oscar \u0026#39;\u0026#39;\u0026#39;當數據值不準備使用的時候 可以使用下劃線作為變數名綁定\u0026#39;\u0026#39;\u0026#39; a, *_, c = name_list EX1：1.鏈式賦值 EX2：2.交叉賦值\n奇葩式寫法： 圖解： 方式1:採用中間變數：\n圖解：\n方式2:交叉賦值語法：\nEX3：3.解壓賦值\n解壓賦值在使用的時候 正常情況下需要保證左邊的變數名與右邊的數據值個數一致 變數名少了不行 變數名多了也不行 當需要解壓的數據個數特別多 並且我們只需要使用其中的幾個 那麼可以打破上述的規則 *會自動接收多餘的數據 組織成列表賦值給後面的變數名 當數據值不準備使用的時候 可以使用下劃線作為變數名綁定 邏輯運算符 \u0026#39;\u0026#39;\u0026#39;主要配合條件一起使用\u0026#39;\u0026#39;\u0026#39; and\t與 and連接的多個條件必須全部成立 結果才成立 1 \u0026gt; 2 and 4 \u0026lt; 8 and 10 \u0026lt; 1 and 1 == 2 如果條件中全部由and組成那麼判斷起來非常的簡單 只要發現一個不成立 結果就不成立 print(1 \u0026lt; 10 and 666) # 666 成立 print(1 \u0026lt; 10 and 2 \u0026lt; 8) # True 成立 print(111 and 222) # 222 成立 如果需要你準確的說出具體的結果值 那麼需要按照下列方式 如果and左邊的條件是成立的 那麼就完全取決於右邊的條件 右邊如果直接是數據值 那麼結果就是該數據值 如果是含有表達式 則為布爾值 or\t或 or連接的多個條件只要有一個成立 結果就成立 1 \u0026gt; 2 or 4 \u0026lt; 8 or 10 \u0026lt; 1 or 1 == 2 如果條件中全部由or組成那麼判斷起來非常的簡單 只要發現一個成立 結果就成立 # print(1 \u0026lt; 10 or 666) # True # print(666 or 1 \u0026gt; 10) # 666 print(0 or False) # False print(0 or 111) # 111 規律用and not\t非 取反 類似於說反話 print(not 1) # False print(not 0) # True \u0026#34;\u0026#34;\u0026#34; 三者混合使用的時候有優先順序之分 但是我們不需要記憶優先順序 應該通過代碼的形式提前規定好優先順序 eg: 先乘除後加減 但是可以使用括弧來改變優先順序 (3\u0026gt;4 and 4\u0026gt;3) or ((1==3 and \u0026#39;x\u0026#39; == \u0026#39;x\u0026#39;) or 3 \u0026gt;3) \u0026#34;\u0026#34;\u0026#34; EX1：and\nEX2：or\nEX3：not\n三者混合使用的時候有優先順序之分 但是我們不需要記憶優先順序 應該通過代碼的形式提前規定好優先順序 成員運算符 判斷個體在不在群體內 # name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;oscar\u0026#39;, \u0026#39;jerry\u0026#39;] # print(\u0026#39;tony\u0026#39; in name_list) # False # print(\u0026#39;tony\u0026#39; not in name_list) # True # print(\u0026#39;j\u0026#39; in name_list) # False 列表最小單位是數據值 不能再細分 # s1 = \u0026#39;hello world\u0026#39; # print(\u0026#39;d\u0026#39; in s1) # 字串最小單位是單個單個的字元 d1 = { \u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;pwd\u0026#39;: 123 } print(\u0026#39;jimmy\u0026#39; in d1) # False 字典成員運算只有鍵參與 print(\u0026#39;username\u0026#39; in d1) # True \u0026#39;username\u0026#39; \u0026#39;pwd\u0026#39; EX1：成員運算符\n列表 字串 字典 身份運算符 \u0026#34;\u0026#34;\u0026#34; id() 返回一串數字 該數字可以看成是記憶體位址 \u0026#34;\u0026#34;\u0026#34; is\t判斷記憶體位址是否相同 == 判斷數據值是否相同 # l1 = [11, 22, 33, 44, 55, 66, 77, 88] # l2 = [11, 22, 33, 44, 55, 66, 77, 88] # print(l1 == l2) # True # print(id(l1)) # print(id(l2)) # print(l1 is l2) # False # 小整數池 i1 = 11 i2 = 11 print(i1 is i2) s1 = \u0026#39;jason jason jason\u0026#39; s2 = \u0026#39;jason jason jason\u0026#39; print(s1 is s2) 不同的環境下可能優化的程度不一樣 \u0026#34;\u0026#34;\u0026#34; 了解 值相同 内存地址可能不同 内存地址相同 值肯定相同 \u0026#34;\u0026#34;\u0026#34; EX1：身份運算符\nis\t判斷記憶體位址是否相同 == 判斷數據值是否相同 EX2：不同的環境下可能優化的程度不一樣\npycharm有額外做優化和解釋器出來結果不一樣\n練習題 1.獲取使用者輸入並列印成下列格式 ------------ info of Jimmy ----------- Name : Jimmy Age : 18 Sex : male Job : Teacher ---------------- end ----------------- # 1.先制定一個列印的範本 info_demo = \u0026#34;\u0026#34;\u0026#34; ------------ info of %s ------------- Name : %s Age : %s Job : %s ---------------- end ----------------- \u0026#34;\u0026#34;\u0026#34; # 2.獲取用戶輸入 username = input(\u0026#39;username\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) age = input(\u0026#39;age\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) job = input(\u0026#39;job\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) # 3.格式化輸出 print(info_demo % (username, username, age, job)) 2.下列變數名v綁定的結果 v1 = 1 or 3 # 1 v2 = 1 and 3 # 3 v3 = 0 and 2 and 1 # 0 v4 = 0 and 2 or 1 # 1 沒寫執行順序，是not-\u0026gt;and-\u0026gt;or v5 = 0 and 2 or 1 or 4 # 1 沒寫執行順序，是not-\u0026gt;and-\u0026gt;or v6 = 0 or False and 1 # False EX1：1.獲取使用者輸入並列印成下列格式\nEX2：2.下列變數名v綁定的結果\n","date":"2023-10-07T03:02:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day04/","title":"Day04 - 基本數據類型(bool、tuple、set)，與使用者交互，格式化輸出，基本運算符，常用賦值符，邏輯運算符，成員運算符，身份運算符，練習題"},{"content":"今日内容概要 pycharm下載與使用 MAC版安裝 WINDOWS版安裝 python語法之注釋 PEP8規範 python語法之變數與常量 python基本數據類型(先大致了解有哪些) 整型int 浮點型float 字串str 列表list 字典dict 練習題(數據類型) # 整體內容大綱 pycharm下載與使用 MAC版安裝： windows版安裝： 回到我的MAC電腦，創建項目 1. 處建項目 2. Location要填寫、解釋器選擇，先不要用虛擬環境 3. 儲存python代碼的文件後綴名一般叫.py 4. 使用pycharm創建的py文件在編寫程式碼的時候有自動提示 tab補全 方向鍵選擇 5. 配置調整 6.運行python代碼 python語法之注釋 PEP8規範 變數與常量 變數的基本使用 1. 日常生活中的變數案例 2. 變數使用的語法結構與底層原理 3. 變數名的命名規範 4. 變數名的命名風格 常量的基本使用 數據類型 數據類型之整型int 數據類型之浮點型float 數據類型之字串str 1.定義字串有四種方式 數據類型之列表list 數據類型之字典dict 小結 今日PEP8規範 練習題 pycharm下載與使用 1.該軟體分為收費版和免費版 免費版功能太少(community) 我們盡量使用收費版(professional) 30天試用 2.pycharm比較笨重 本身占據的資源較多 並且保持運行的情況下需要消耗計算機1GB多的資源 3.文件後綴名 儲存python代碼的文件後綴名一般叫.py 4.如何創建py文件 使用pycharm創建的py文件在編寫程式碼的時候有自動提示 tab補全 方向鍵選擇 5.配置調整 字體大小 編程背景 解釋器選擇 6.運行python代碼 Pycharm官網下載網址： https://www.jetbrains.com/pycharm/download/?section=mac\nMAC版安裝： 下載最新版Pycharm 下載其他版本，我電腦是mac m1晶片 拖曳過去Applications檔案夾即可 需要licenses授權，因為我是有購買的，所以我採取登入JB帳號，即可使用 windows版安裝： Next 目錄選擇簡單一點的名稱，方便後續查找 安裝後，桌面會一個PyCharm的icon捷徑 回到我的MAC電腦，創建項目 1. 處建項目 2. Location要填寫、解釋器選擇，先不要用虛擬環境 3. 儲存python代碼的文件後綴名一般叫.py 項目創建的資料，就會看到上面創建的.py文件 4. 使用pycharm創建的py文件在編寫程式碼的時候有自動提示 tab補全 方向鍵選擇 5. 配置調整 字體 背景，我習慣用白的，這裡再依各位個人喜好去修改 可以看到選擇Darcula，視窗就變暗色系了 如果pycharm無法找到python解釋器，可以再來這裡再設定 有新安裝版本，也能從旁右方齒輪按鍵，去新增 6.運行python代碼 代碼行處，右鍵，即可執行此當下這個.py文件代碼 或者視窗右上面，也能執行 python語法之注釋 1.什麼是注釋 注釋其實就是對一段代碼的解釋說明 2.如何編寫注釋 方式1:解釋說明文字前加警號 pycharm中有快捷鍵 ctrl + / mac電腦，用 command + / # 注釋(單行注釋) 方式2:鍵盤enter鍵左邊那個鍵英文輸入法下連續按三下 \u0026#39;\u0026#39;\u0026#39; 多行注釋 \u0026#39;\u0026#39;\u0026#39; 方式3:鍵盤enter鍵左邊那個鍵英文輸入法下+shift 連續按三下 \u0026#34;\u0026#34;\u0026#34; 多行注釋 \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;hello world\u0026#39;) #1. 這是列印數據方式，單行註釋 # print(\u0026#39;hello world\u0026#39;) # Prcharm快捷鍵，command + /(右邊shift左邊那個鍵) \u0026#39;\u0026#39;\u0026#39; 2. 多行註釋: 大家好，我是翻轉吧金魚腦 \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 3. 多行註釋: 哈摟，我是翻轉吧金魚腦 \u0026#34;\u0026#34;\u0026#34; PEP8規範 \u0026#34;\u0026#34;\u0026#34; pycharm中很多時候會有各種顏色提示還有波浪線 只要不是紅線一般都不影響代碼運行 \u0026#34;\u0026#34;\u0026#34; python代碼編寫規範 1.單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 2.如果單行注釋自成一行 那麼內容與警號空一格 ps:如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 EX1: 單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 EX2: 如果單行注釋自成一行 那麼內容與警號空一格 EX3: 如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 變數與常量 變數與常量就是為了讓程序具備人記錄事物狀態的能力 1.什麼是變數? 記錄變化(可能會經常改變)的事物狀態 eg:年齡 容貌 薪資 2.什麼是常量? 記錄固定(可能不經常改變)的事物狀態 eg:圓周率 重力加速度 變數的基本使用 日常生活中的變數案例 翻轉吧金魚腦 姓名叫jimmy 年齡是20 性別是男性 代碼中如何記錄事物狀態 name = \u0026#39;jimmy\u0026#39; age = 20 gender = \u0026#39;male\u0026#39; 變數使用的語法結構與底層原理 \u0026#34;\u0026#34;\u0026#34; name = \u0026#39;jimmy\u0026#39; 變數名 賦值符號 數據值 1.一旦看到賦值符號 那麼一定先看符號的右側 2.在記憶體空間中申請一塊記憶體空間儲存數據值 3.給數據值綁定一個變數名 4.以後就可以通過變數名訪問到數據值 \u0026#34;\u0026#34;\u0026#34; 注意事項: 1.同一個數據值可以綁定多個變數名 2.賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值 3.一個變數名同一時間只能綁定一個數據值 name = \u0026#39;jimmy\u0026#39; name1 = name name2 = name1 x = 10 x = x + 1 print(x) 1. 日常生活中的變數案例 2. 變數使用的語法結構與底層原理 \u0026#34;\u0026#34;\u0026#34; name = \u0026#39;jimmy\u0026#39; 變數名 賦值符號 數據值 1.一旦看到賦值符號 那麼一定先看符號的右側 2.在記憶體空間中申請一塊記憶體空間儲存數據值 3.給數據值綁定一個變數名 4.以後就可以通過變數名訪問到數據值 \u0026#34;\u0026#34;\u0026#34; EX1: 變數名 賦值符號 數據值 注意事項: 1. 同一個數據值可以綁定多個變數名 2.賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值 3.一個變數名同一時間只能綁定一個數據值 EX1: 一個數據值可以綁定多個變數名(賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值) EX2: 一個變數名同一時間只能綁定一個數據值 3. 變數名的命名規範 變數名的命名規範 1.中文是可以用作變數名的 但是不建議使用 並且容易報錯 2.變數名只能出現字母、數字、下劃線 3.數字不能開頭 4.變數名盡量做到見名知意 5.變數名不能與關鍵字衝突 EX1: 中文是可以用作變數名的 但是不建議使用 並且容易報錯 EX2: 變數名只能出現字母、數字、下劃線、數字不能開頭 EX3: 見名之意 EX4: 關鍵字 4. 變數名的命名風格 變數名的命名風格 1.下劃線式 python推薦使用 變數名中單字很多 彼此使用下劃線隔開 name_from_mysql_db1_userinfo = \u0026#39;jimmy\u0026#39; 2.駝峰體式 JS推薦使用 大駝峰 NameFromMysqlDb1Userinfo = \u0026#39;jimmy\u0026#39; 小駝峰 nameFromMysqlDb1Userinfo = \u0026#39;jimmy\u0026#39; ps:在同一個程式語言中盡量固定使用一種 不要隨意切換 EX1: 下劃線式 (變數名中單字很多 彼此使用下劃線隔開)\n常量的基本使用 1.在python沒有真正意義上的常量(定義了就不能改) 定義了可以隨時修改 2.在python中如果想表示出常量 那麼可以使用全大寫的變數名 HOST = \u0026#39;127.0.0.1\u0026#39; ps:除了全大寫之外 其他與變數用法一致 數據類型 1.什麼是數據類型 在日常生活中數據的表現形式多種多樣 在程序中也是如此 2.為何學習數據類型 針對不同的數據採用最佳的數據類型來表示出該數據的價值 3.本次學習數據類型僅僅是了解 只要看到每個數據類型能夠叫出它們的名字以及代碼如何編寫即可 4.學前必會 如何查看數據值的數據類型 type(數據值)\\type(變數名) EX1: 數據類型之整型int 大白話的意思其實就是整數 應用場景:年齡 班級人數 年份 EX1: 數據類型之浮點型float 大白話的意思其實就是小數 應用場景:身高 體重 薪資 EX1: 數據類型之字串str 大白話的意思其實就是文本類型的數據\u0026gt;\u0026gt;\u0026gt;:引號引起來的部分都是字串 應用場景:姓名 地址 愛好 1.定義字串有四種方式 name = \u0026#39;jimmy\u0026#39; name1 = \u0026#34;jimmy\u0026#34; name2 = \u0026#39;\u0026#39;\u0026#39;jimmy\u0026#39;\u0026#39;\u0026#39; name3 = \u0026#34;\u0026#34;\u0026#34;jimmy\u0026#34;\u0026#34;\u0026#34; 2.為什麼定義字串需要有多種方式 我們在字串中編寫文本也可能會使用到引號 為了避免衝突 有了多種方式 info = \u0026#34;jimmy說:\u0026#39;好學\u0026#39;\u0026#34; 3.如何區分三引號是字串還是注釋 關注左側是否含有賦值符號和變數名 如果有則為字串 沒有則為注釋 EX1: 1.定義字串有四種方式 1.定義字串有四種方式 name = \u0026#39;jimmy\u0026#39; name1 = \u0026#34;jimmy\u0026#34; name2 = \u0026#39;\u0026#39;\u0026#39;jimmy\u0026#39;\u0026#39;\u0026#39; name3 = \u0026#34;\u0026#34;\u0026#34;jimmy\u0026#34;\u0026#34;\u0026#34; 2.為什麼定義字串需要有多種方式 我們在字串中編寫文本也可能會使用到引號 為了避免衝突 有了多種方式 info = \u0026#34;jimmy說：\u0026#39;好學\u0026#39;\u0026#34; 3.如何區分三引號是字串還是注釋 關注左側是否含有賦值符號和變數名 如果有則為字串 沒有則為注釋 EX1: EX2: 為什麼定義字串需要有多種方式(為了避免衝突) 數據類型之列表list 大白話的意思其實就是可以儲存多個數據值的類型 並且可以非常方便的取 應用場景:儲存多個數據值 並且將來可能需要單獨取其中一些 代碼實現: name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;oscar\u0026#39;, \u0026#39;jerry\u0026#39;] 1.列表的文字描述 中括號括起來 內部可以存放多個數據值 數據值與數據值之間逗號隔開 數據值可以是任意數據類型 l1 = [11, 11.11, \u0026#39;jimmy\u0026#39;,[11, 22]] 2.索引取值 起始數字是從0開始 l1[索引值] \u0026#34;\u0026#34;\u0026#34; PEP8規範補充 1.逗號後面與數據值空一格 2.賦值符號左右都得空一格 \u0026#34;\u0026#34;\u0026#34; EX1: EX2: 數據類型之字典dict 能夠非常精確的儲存和表達數據值的含義 代碼實現: info_dict = { \u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;hobby\u0026#39;: \u0026#39;coding\u0026#39;, } 1.字典文字描述 大括號括起來 內部可以存放多個數據 數據的組織形式是K:V鍵值對 鍵值對與鍵值對之間逗號隔開 K是對V的描述性性質的資訊(解釋說明) 一般都是字串類型 V是真正的數據值 可以是任意數據類型 2.按K取值 字典只能按K取值 因為字典是無序的 沒有索引的概念 info_dict[\u0026#39;username\u0026#39;] \u0026#34;\u0026#34;\u0026#34; PEP8規範補充 1.字典K:V，:右邊要空一格 \u0026#34;\u0026#34;\u0026#34; EX1:字典 EX2: 按鍵取值 小結 今日PEP8規範 1.單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 2.如果單行注釋自成一行 那麼內容與警號空一格 3.list 1.逗號後面與數據值空一格 2.賦值符號左右都得空一格 4.dict 1.字典K:V，:右邊要空一格 ps:如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 (mac快捷鍵command+option+L) 練習題(數據類型) # 附加練習題(提示:一步步拆解) # 1.想辦法列印出jimmy l1 = [11, 22, \u0026#39;kevin\u0026#39;, [\u0026#39;tony\u0026#39;, \u0026#39;jerry\u0026#39;, [123, 456, \u0026#39;jimmy\u0026#39;]] ] \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # 1.先看大列表到底有幾個數據值 以及我們想要的數據值在哪個裡面 # print(l1[3]) l2 = l1[3] # [\u0026#39;tony\u0026#39;, \u0026#39;jerry\u0026#39;, [123, 456, \u0026#39;jimmy\u0026#39;]] # 2.再次思考小列表有幾個數據值 以及我們想要的數據值在哪個裡面 # print(l2[2]) l3 = l2[2] # [123, 456, \u0026#39;jimmy\u0026#39;] # 3.最後轉化成了簡單的索引直接取值 print(l3[2]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(l1[3][2][2]) # 2.想辦法列印出大寶貝 d1 = {\u0026#39;name\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;others\u0026#39;: {\u0026#39;a1\u0026#39;: \u0026#39;heiheihei\u0026#39;, \u0026#39;a2\u0026#39;: {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;} } } \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # 1.先拿大字典第二個鍵值對的值 # print(d1[\u0026#39;others\u0026#39;]) d2 = d1[\u0026#39;others\u0026#39;] # {\u0026#39;a1\u0026#39;: \u0026#39;heiheihei\u0026#39;, \u0026#39;a2\u0026#39;: {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;}} # 2.再拿小字典第二個鍵值對的值 # print(d2[\u0026#39;a2\u0026#39;]) d3 = d2[\u0026#39;a2\u0026#39;] # {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;} # 3.轉化成簡單的按k直接取值 print(d3[\u0026#39;k3\u0026#39;]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(d1[\u0026#39;others\u0026#39;][\u0026#39;a2\u0026#39;][\u0026#39;k3\u0026#39;]) # 3.想辦法列印出run data = {\u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;hobby\u0026#39;: [11, 22, {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39; ] } ] } \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # print(data[\u0026#39;hobby\u0026#39;]) data1 = data[\u0026#39;hobby\u0026#39;] # [11, 22, {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;]}] # print(data1[2]) data2 = data1[2] # {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;]} # print(data2[\u0026#39;hobby\u0026#39;]) data3 = data2[\u0026#39;hobby\u0026#39;] # [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;] print(data3[1]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(data[\u0026#39;hobby\u0026#39;][2][\u0026#39;hobby\u0026#39;][1]) EX1: 想辦法列印出jimmy EX2: 想辦法列印出大寶貝 EX3: 想辦法列印出run YouTube教學影片 ","date":"2023-10-07T03:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day03/","title":"Day03 - pycharm，註解，PEP8規範，變量與常量，基本數據類型int、float、str、list、dict(初探)，練習題(數據類型)"},{"content":"今日內容概要 計算機三大核心硬體 操作系統 程式語言的分類 python解釋器 運行python程序的三種方式 mac、windows電腦安裝python解釋器(多版本) 計算機三大核心硬體 計算機三大核心硬體: 1.CPU 2.記憶體 3.硬碟 為什麼不直接省略記憶體，跟硬碟溝通就好? 1.記憶體的容量一般比硬碟小的多得多 2.CPU運行速度快，硬碟運行速度慢，記憶體搭配CPU運作，提升CPU運行效率 3.只要是運行的程序 產生的數據第一時間肯定在記憶體，突然斷電數據會立刻遺失 操作系統 https://ithelp.ithome.com.tw/upload/images/20230909/20132481mxrUPlFKDC.png\n控制 協調 管理計算機各個硬體的工作 PC端常見操作系統: windows、macOS、linux 行動端常見操作系統: Android、IOS、 程式語言的分類 1.編譯型語言\tC++、Java、Golang 類似於GOOGLE翻譯(一次性翻譯) 翻譯之後可以反覆使用翻譯的結果 優勢: 一次翻譯可以反覆使用 執行效率高 速度快 劣勢: 當程序中頻繁出現bug 那麼需要反覆編譯 2.解釋型語言 python 類似於翻譯官(說一句翻一句) 優勢: 有bug和沒有bug執行效率幾乎一樣 劣勢: 速度沒有編譯型語言快 \u0026#39;\u0026#39;\u0026#39;要想讓計算機能夠識別並運行高級語言需要對應類型的翻譯官\u0026#39;\u0026#39;\u0026#39; python解釋器 1.python發展方向 web方向、自動化運維、自動化測試、自動化辦公、網路爬蟲、金融量化、人工智慧、機器學習、數據分析 2.python解釋器 1.歷史 荷蘭的Guido van Rossum因為當時的程式語言存在缺陷，聖誕節期間，他決定創建一種新的語言。一種更易於使用又功能強大的語言。 2.版本 版本其實是軟體更新疊代的紀錄 python1.X:初期版本 幾乎不用 python2.X:python2.7(2020年就已經不再維護更新) python3.X:python3.6 python3.8 python3.10+ ps:學習python語法 對版本的區別差異不大 目前常用:python2.7\tpython3.6\tpython3.8 3.下載 官網:https://www.python.org/downloads/windows/ ps:蘋果電腦macOS、linux系統(centos7、rhel7...等)自帶python2.7 4.安裝(如本頁後面:mac、windows電腦安裝python解釋器(多版本)) 自訂安裝 路徑盡量簡單一些 示範:windows電腦、mac電腦 5.使用 1.windows+r 2.輸入cmd回車 3.切換盤符 C: 4.切換目錄 cd python38 5.運行解釋器 python 6.退出解釋器 exit() 7.退到上一層目錄 cd ..\t運行python程序的三種方式 1.cmd直接編寫運行 適用於較短 臨時執行的代碼 2.解釋器命令運行 可以編寫較長的代碼 並且可以長久保存 3.利用IDE工具編寫並運行 IDE開發者工具:自動提示 攜帶各種功能插件 編寫程式碼效率更高更快 1.sublime 2.vscode 3.pycharm cmd直接編寫運行 解釋器命令運行 利用IDE工具編寫並運行(pycharm 2021.3.3) mac、windows電腦安裝python解釋器(多版本) mac電腦安裝python解釋器(多版本) 官網Downloads網址：https://www.python.org/downloads/macos/\n1. Downloads 2. 找到要安裝的版本 3. 全程點繼續，完成安裝 4. 打開termimel，可以看到使用者環境變數已自動加上python3.9路徑 5. 直接可以使用 6. 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6本版的 Downloads 找到要安裝的版本，因為我的電腦是m1晶片，所以就不能選擇intel-only，選擇universal2 全程點繼續，完成安裝 打開termimel，可以看到使用者環境變數已自動加上python3.9路徑 直接可以使用 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6本版的 可以看到使用者環境變數也已自動加上python3.8路徑\nwindows電腦安裝python解釋器(多版本) 官網Downloads網址：https://www.python.org/downloads/windows/\n1. Downloads 2. 找到要安裝的版本 3. 注意，點選Customize installation 4. 打開termimel，到安裝目錄下 5. 可以看到有一個python.exe檔案，執行即可使用 6. 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可 7. 每次都要到安裝目錄下，才能使用python，故將路徑直接加入環境變數。 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 Downloads 找到要安裝的版本，因為我的電腦是w11 64bit，所以選擇Windows installer (64-bit) 注意，點選Customize installation，自訂安裝路徑，不然原安裝路徑名稱非常長，以後要找，不易 我選擇在C:\\，創建一個python39資料夾，將python3.9安裝在此位置 打開termimel，到安裝目錄下 可以看到有一個python.exe檔案，執行即可使用 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6、本版的 我選擇在C:\\，創建一個python38資料夾，將python3.8安裝在此位置\n每次都要到安裝目錄下，才能使用python，故將路徑直接加入環境變數。 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 YouTube教學影片 ","date":"2023-10-07T02:50:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day02/","title":"Day02 - 計算機三大核心，操作系統，程式語言分類，Python解釋器，Mac、Windows電腦安裝Python解釋器"},{"content":"今日總結 typora軟件 下載與安裝 文件路徑 主要功能 markdown語法 技術文章編寫教程 計算機本質 計算機五大組成部分 計算機三大核心硬件 計算機五大組成部分： 控制器 似大腦控制各器官與四肢 運算器 似大腦運算，邏輯思考 存儲器 似人記憶，短期記憶(記憶體)，長期記憶(硬盤) 輸入設備 似眼睛，接收外在訊息 輸出設備 似嘴巴，講述想法 計算機單位與轉換： 1 Byte = 8 bit 1024Byte = 1KB 1024KB = 1MB 1024MB = 1GB 1024GB = 1TB 二進制、十六進制、十進制、八進制 的轉換 自我介绍 就學歷程： 高中：就讀普通高中，讀2類自然組，對化學很有興趣，也考過全校化學競賽第一名，代表學校去參加全市比賽，但沒得名。 就是在那次比賽後，有深刻的體悟，普通高中，實作實驗真的太少，去比賽時，幾乎都是實作實驗，讓我不知所措，才會再報考大學時，轉而去讀科技大學，希望能學到一技之常。\n大學：就讀科技大學電機系，果然是科技大學，很多都是實作課，那時候才發現我與同學們的差距那麼大，因為他們幾乎都是專科進來的，所以大部分實驗，很多都接觸過了，我那時候連麵包版都不會插，電阻看不懂，剛開始實在是超辛苦，還好有同儕的教學，讓我挺過來。\n當兵：海軍陸戰隊，戰車營，去新竹受訓3個月，回來營上，開戰車下基地，是我人生中，非常特殊的回憶。\n工作經歷： 弱電工程師：不超過110V的工程都做，佈網路線、電話線、監控、廣播，建置網路機房\u0026hellip;等，全台有配合的裝修場、配合的維護銀行，都要跑。做了3年半，做到主任，但考量薪水、工作環境差、未來規劃，裸辭，決定轉職進IT領域。\n特訓班：前份工作裸辭，就是為了能進特訓班，此特訓班不用費用，但前提是要沒有工作的人(就是勞動部幫助失業的人轉職)，同時也要進過考試和面試，學習到的課程：Windows Server管理、Linux Server管理、Cisco網路設備管理。(特訓完：考取CCNA證照)\n網路FAE：特訓班結訓後，進入通路商，負責公司販賣的網路設備售後技術支援。\nMIS：和網路FAE是同一家公司，因為公司內部缺網管，長官希望我過去幫忙，就內轉到MIS部門，負責公司內部網路、伺服器建置與管理，會選擇離開，主要是MIS負責太多事了，沒辦法專心在一個領域技術提升。(考取：CCNP證照、RHCSA7證照、RCHE7證照、RHCSA8證照)\n電商伺服器工程師：到此公司，就是專門負責電商對外伺服器管理和建置，原則上就幾乎都是linux系統和pve虛擬化系統，會選擇只做4個月就離開，主要是因為公司文化、公司凝聚力、部門間協調、SOP不明確、公司不賺錢，基於以上原因，才會選擇盡快離開。當然在此公司是非常好的經歷，因為電商領域，就是我轉職到IT時，一直想走上的路，也算讓我進到這個領域有了第一個敲門磚。\n電商伺服器 資深工程師：負責電商伺服器管理與建置、Redis服務管理與建置、K8S平台管理與建置、目前自學Python、前端、Django，主要是為了讓管理方式能更有效率、更系統化。目前在公司也會安排向內部員工進行教育訓練課程、分享技術，讓我在此工作上得到滿滿的成就感。就我自己認為，會再多，如果不能說到讓別人也瞭解，那就不是真的瞭解這個技術了。所以我熱衷於這份工作，能讓我分享技術，公司也不斷的引進新技術、新想法，讓我們去嘗試，所以目前在此工作，是非常開心的狀態，希望這種感覺，能一直持續下去。(考取：CKA證照、CKAD證照、CKS證照)\nYouTube教學影片 ","date":"2023-10-07T02:45:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day01/","title":"Day01 - Typora、Markdown、技術文章編寫、計算機五大組成、三大核心、自我介紹"},{"content":"\n一、節點規劃 部署k8s集群的節點按照用途可以劃分為如下2類角色：\nmaster：集群的master節點，集群的初始化節點，基礎配置不低於2C4G node：集群的node節點，可以多台，基礎配置不低於2C4G K8S實體機網段: 192.168.1.0/24\nPOD網段: 10.244.0.0/16\nSERVICE網段: 10.245.0.0/16\n主機名 節點ip 角色 部署組件 k8s-master71u 192.168.1.71 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico k8s-master72u 192.168.1.72 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico k8s-master73u 192.168.1.73 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico 192.168.1.74 VIP 作為3台master節點的LB使用 k8s-node75u k8s-node75u node kubectl, kubelet, kube-proxy, calico k8s-node76u k8s-node76u node kubectl, kubelet, kube-proxy, calico 二、組件版本 組件 版本 說明 Ubuntu 22.04.3 LTS Kernel 5.15.0-83-generic etcd 3.5.6-0 使用Pod方式部署，默認數據掛載到本地路徑 coredns v1.9.3 kubeadm v1.26.3 kubectl v1.26.3 kubelet v1.26.3 kube-proxy v1.26.3 calico v3.26.0 cri-dockerd 0.3.3.3-0 安裝前準備 一、設置hosts解析 操作節點：所有節點（k8s-master，k8s-node）均需執行\n添加hosts解析 root@k8s-master71u:~# cat \u0026gt;\u0026gt;/etc/hosts\u0026lt;\u0026lt;EOF 192.168.1.71 k8s-master71u 192.168.1.72 k8s-master72u 192.168.1.73 k8s-master73u 192.168.1.75 k8s-node75u 192.168.1.76 k8s-node76u EOF root@k8s-master71u:~# cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 k8s-master71u # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 192.168.1.71 k8s-master71u 192.168.1.72 k8s-master72u 192.168.1.73 k8s-master73u 192.168.1.75 k8s-node75u 192.168.1.76 k8s-node76u 二、調整系統配置 操作節點： 所有的master和node節點（k8s-master,k8s-node）需要執行\n本章下述操作均以k8s-master為例，其他節點均是相同的操作（ip和hostname的值換成對應機器的真實值）\n設置安全組開放端口 如果節點間無安全組限制（內網機器間可以任意訪問），可以忽略，否則，至少保證如下端口可通： k8s-master節點：TCP：6443，2379，2380，60080，60081UDP協議端口全部打開 k8s-node節點：UDP協議端口全部打開\n關閉防火牆 root@k8s-master71u:~# ufw status Status: inactive 關閉swap root@k8s-master71u:~# swapoff -a \u0026amp;\u0026amp; sysctl -w vm.swappiness=0 vm.swappiness = 0 root@k8s-master71u:~# sed -i \u0026#39;s/.*swap.*/#\u0026amp;/g\u0026#39; /etc/fstab #/dev/disk/by-id/dm-uuid-LVM-kAtY9KpfwxzNTDEpBzFkOODzcZgK93hc3OfpHLBwOVbgBZUOZC21pLNScKzDP2aI none swap sw 0 0 修改內核參數 root@k8s-master71u:~# cat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF root@k8s-master71u:~# systemctl restart systemd-modules-load.service root@k8s-master71u:~# systemctl status systemd-modules-load.service ● systemd-modules-load.service - Load Kernel Modules Loaded: loaded (/lib/systemd/system/systemd-modules-load.service; static) Active: active (exited) since Wed 2023-09-20 00:23:11 UTC; 6s ago Docs: man:systemd-modules-load.service(8) man:modules-load.d(5) Process: 2322 ExecStart=/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS) Main PID: 2322 (code=exited, status=0/SUCCESS) CPU: 39ms Sep 20 00:23:11 k8s-master71u systemd[1]: Starting Load Kernel Modules... Sep 20 00:23:11 k8s-master71u systemd-modules-load[2322]: Inserted module \u0026#39;overlay\u0026#39; Sep 20 00:23:11 k8s-master71u systemd-modules-load[2322]: Inserted module \u0026#39;br_netfilter\u0026#39; Sep 20 00:23:11 k8s-master71u systemd[1]: Finished Load Kernel Modules. root@k8s-master71u:~# lsmod |grep -e overlay overlay 151552 0 root@k8s-master71u:~# lsmod |grep -e br_netfilter br_netfilter 32768 0 bridge 307200 1 br_netfilter root@k8s-master71u:~# cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf vm.max_map_count=262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory=1 vm.panic_on_oom=0 fs.inotify.max_user_watches=89100 fs.file-max=52706963 fs.nr_open=52706963 net.netfilter.nf_conntrack_max=2310720 net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl =15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 EOF root@k8s-master71u:~# sysctl -p /etc/sysctl.d/k8s.conf vm.max_map_count = 262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory = 1 vm.panic_on_oom = 0 fs.inotify.max_user_watches = 89100 fs.file-max = 52706963 fs.nr_open = 52706963 sysctl: cannot stat /proc/sys/net/netfilter/nf_conntrack_max: No such file or directory net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl = 15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 # 報錯 sysctl: cannot stat /proc/sys/net/netfilter/nf_conntrack_max: 沒有此一檔案或目錄 # 解決方式 root@k8s-master71u:~# modprobe ip_conntrack root@k8s-master71u:~# sysctl -p /etc/sysctl.d/k8s.conf vm.max_map_count = 262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory = 1 vm.panic_on_oom = 0 fs.inotify.max_user_watches = 89100 fs.file-max = 52706963 fs.nr_open = 52706963 net.netfilter.nf_conntrack_max = 2310720 net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl = 15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 添加ipvs，安裝套件 root@k8s-master71u:~# apt -y install ipvsadm ipset sysstat conntrack libseccomp2 libseccomp-dev root@k8s-master71u:~# cat \u0026gt; /etc/modules-load.d/ipvs.conf \u0026lt;\u0026lt; EOF ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_fo ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack ip_tables ip_set xt_set ipt_set ipt_rpfilter ipt_REJECT ipip EOF root@k8s-master71u:~# systemctl restart systemd-modules-load.service root@k8s-master71u:~# systemctl status systemd-modules-load.service ● systemd-modules-load.service - Load Kernel Modules Loaded: loaded (/lib/systemd/system/systemd-modules-load.service; static) Active: active (exited) since Wed 2023-09-20 00:28:06 UTC; 7s ago Docs: man:systemd-modules-load.service(8) man:modules-load.d(5) Process: 3116 ExecStart=/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS) Main PID: 3116 (code=exited, status=0/SUCCESS) CPU: 76ms Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_fo\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_nq\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_sed\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_ftp\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_set\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;xt_set\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipt_rpfilter\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipt_REJECT\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipip\u0026#39; Sep 20 00:28:06 k8s-master71u systemd[1]: Finished Load Kernel Modules. root@k8s-master71u:~# lsmod |grep -e ip_vs -e nf_conntrack_ipv4 ip_vs_ftp 16384 0 nf_nat 49152 1 ip_vs_ftp ip_vs_sed 16384 0 ip_vs_nq 16384 0 ip_vs_fo 16384 0 ip_vs_sh 16384 0 ip_vs_dh 16384 0 ip_vs_lblcr 16384 0 ip_vs_lblc 16384 0 ip_vs_wrr 16384 0 ip_vs_rr 16384 0 ip_vs_wlc 16384 0 ip_vs_lc 16384 0 ip_vs 176128 24 ip_vs_wlc,ip_vs_rr,ip_vs_dh,ip_vs_lblcr,ip_vs_sh,ip_vs_fo,ip_vs_nq,ip_vs_lblc,ip_vs_wrr,ip_vs_lc,ip_vs_sed,ip_vs_ftp nf_conntrack 172032 2 nf_nat,ip_vs nf_defrag_ipv6 24576 2 nf_conntrack,ip_vs libcrc32c 16384 7 nf_conntrack,nf_nat,btrfs,nf_tables,xfs,raid456,ip_vs 三、安裝docker 所有的master和node節點（k8s-master,k8s-node）需要執行\nhttps://docs.docker.com/engine/install/ubuntu/\n# 1. Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install ca-certificates curl gnupg # 2. Add Docker’s official GPG key: sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # 3. Use the following command to set up the repository: echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/docker.list deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu jammy stable # 5. Update the apt package index sudo apt-get update # 查看所有的可用版本 root@k8s-master71u:~# apt-cache madison docker-ce | awk \u0026#39;{ print $3 }\u0026#39; 5:24.0.6-1~ubuntu.22.04~jammy 5:24.0.5-1~ubuntu.22.04~jammy 5:24.0.4-1~ubuntu.22.04~jammy 5:24.0.3-1~ubuntu.22.04~jammy 5:24.0.2-1~ubuntu.22.04~jammy 5:24.0.1-1~ubuntu.22.04~jammy 5:24.0.0-1~ubuntu.22.04~jammy 5:23.0.6-1~ubuntu.22.04~jammy 5:23.0.5-1~ubuntu.22.04~jammy 5:23.0.4-1~ubuntu.22.04~jammy 5:23.0.3-1~ubuntu.22.04~jammy 5:23.0.2-1~ubuntu.22.04~jammy 5:23.0.1-1~ubuntu.22.04~jammy 5:23.0.0-1~ubuntu.22.04~jammy 5:20.10.24~3-0~ubuntu-jammy 5:20.10.23~3-0~ubuntu-jammy 5:20.10.22~3-0~ubuntu-jammy 5:20.10.21~3-0~ubuntu-jammy 5:20.10.20~3-0~ubuntu-jammy 5:20.10.19~3-0~ubuntu-jammy 5:20.10.18~3-0~ubuntu-jammy 5:20.10.17~3-0~ubuntu-jammy 5:20.10.16~3-0~ubuntu-jammy 5:20.10.15~3-0~ubuntu-jammy 5:20.10.14~3-0~ubuntu-jammy 5:20.10.13~3-0~ubuntu-jammy # 指定版本，安裝docker-ce root@k8s-master71u:~# VERSION_STRING=5:20.10.13~3-0~ubuntu-jammy root@k8s-master71u:~# sudo apt-get install docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io ## 配置docker使用cgroupdriver=systemd root@k8s-master71u:~# mkdir -p /etc/docker root@k8s-master71u:~# vim /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] } root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl restart docker ## 啟動docker root@k8s-master71u:~# systemctl enable docker \u0026amp;\u0026amp; systemctl start docker root@k8s-master71u:~# systemctl status docker ## 測試起一個容器 root@k8s-master71u:~# sudo docker run hello-world Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 719385e32844: Pull complete Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db Status: Downloaded newer image for hello-world:latest Hello from Docker! 四、安裝cri-docker 所有的master和node節點（k8s-master,k8s-node）需要執行\nhttps://github.com/Mirantis/cri-dockerd\nroot@k8s-master71u:~# wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.3/cri-dockerd_0.3.3.3-0.ubuntu-jammy_amd64.deb root@k8s-master71u:~# sudo dpkg -i cri-dockerd_0.3.3.3-0.ubuntu-jammy_amd64.deb root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl enable cri-docker \u0026amp;\u0026amp; systemctl start cri-docker \u0026amp;\u0026amp; systemctl status cri-docker ● cri-docker.service - CRI Interface for Docker Application Container Engine Loaded: loaded (/lib/systemd/system/cri-docker.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2023-09-20 00:44:58 UTC; 25s ago TriggeredBy: ● cri-docker.socket Docs: https://docs.mirantis.com Main PID: 5055 (cri-dockerd) Tasks: 10 Memory: 9.8M CPU: 83ms CGroup: /system.slice/cri-docker.service └─5055 /usr/bin/cri-dockerd --container-runtime-endpoint fd:// Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Start docker client with reque\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Hairpin mode is set to none\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Loaded network plugin cni\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker cri networking managed \u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker Info: \u0026amp;{ID:ZVOJ:5V6C:QO\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Setting cgroupDriver systemd\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker cri received runtime co\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Starting the GRPC backend for \u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Start cri-dockerd grpc backend\u0026#34; Sep 20 00:44:58 k8s-master71u systemd[1]: Started CRI Interface for Docker Application Container Engine. 初始化集群 一、安裝kubeadm、kubelet、kubectl 操作節點： 所有的master和node節點(k8s-master,k8s-node) 需要執行\nhttps://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n# 1. Update the apt package index and install packages needed to use the Kubernetes apt repository: sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl # 2. Download the Google Cloud public signing key: curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg # 3. Add the Kubernetes apt repository: echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/kubernetes.list deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main # 5. Update apt package index, install kubelet, kubeadm and kubectl, and pin their version: sudo apt-get update root@k8s-master71u:~# sudo apt-get install -y kubelet=1.26.3-00 kubeadm=1.26.3-00 kubectl=1.26.3-00 ## 查看kubeadm 版本 root@k8s-master71u:~# kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;26\u0026#34;, GitVersion:\u0026#34;v1.26.3\u0026#34;, GitCommit:\u0026#34;9e644106593f3f4aa98f8a84b23db5fa378900bd\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2023-03-15T13:38:47Z\u0026#34;, GoVersion:\u0026#34;go1.19.7\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} ## 設置kubelet開機啟動，並使用ipvs與systemd root@k8s-master71u:~# vim /etc/default/kubelet KUBE_PROXY_MODE=\u0026#34;ipvs\u0026#34; KUBELET_EXTRA_ARGS=\u0026#34;--cgroup-driver=systemd --pod-infra-container-image=registry.k8s.io/pause:3.6\u0026#34; root@k8s-master71u:~# systemctl enable --now kubelet 二、安裝配置haproxy、keepalived 操作節點： 所有的master\n注意：如果有兩個集群，都在同一網段內，/etc/keepalived/keepalived.conf裡面的virtual_router_id 60記得要不一樣，不然/var/log/message會一直報錯。\nroot@k8s-master71u:~# apt-get install keepalived haproxy -y # 所有master節點執行,注意替換最後的master節點IP地址 root@k8s-master71u:~# vim /etc/haproxy/haproxy.cfg global maxconn 2000 ulimit-n 16384 log 127.0.0.1 local0 err stats timeout 30s defaults log global mode http option httplog timeout connect 5000 timeout client 50000 timeout server 50000 timeout http-request 15s timeout http-keep-alive 15s frontend monitor-in bind *:33305 mode http option httplog monitor-uri /monitor frontend k8s-master bind 0.0.0.0:7443 bind 127.0.0.1:7443 mode tcp option tcplog tcp-request inspect-delay 5s default_backend k8s-master backend k8s-master mode tcp option tcplog option tcp-check balance roundrobin default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100 server k8s-master71u 192.168.1.71:6443 check server k8s-master72u 192.168.1.72:6443 check server k8s-master73u 192.168.1.73:6443 check # 在k8s-master71u節點，注意mcast_src_ip換成實際的master1ip地址，virtual_ipaddress換成lb地址，interface要替換成主機IP使用的介面 root@k8s-master71u:~# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived global_defs { router_id LVS_DEVEL script_user root enable_script_security } vrrp_script chk_apiserver { script \u0026#34;/etc/keepalived/check_apiserver.sh\u0026#34; interval 5 weight -5 fall 2 rise 1 } vrrp_instance VI_1 { state MASTER interface ens160 mcast_src_ip 192.168.1.71 virtual_router_id 60 priority 101 advert_int 2 authentication { auth_type PASS auth_pass K8SHA_KA_AUTH } virtual_ipaddress { 192.168.1.74 } track_script { chk_apiserver } } # 在k8s-master52u和k8s-master53u分別創建/etc/keepalived/keepalived.conf，注意修改mcast_src_ip和virtual_ipaddress #所有master節點配置KeepAlived健康檢查文件： root@k8s-master71u:~# vim /etc/keepalived/check_apiserver.sh #!/bin/bash err=0 for k in $(seq 1 3) do check_code=$(pgrep haproxy) if [[ $check_code == \u0026#34;\u0026#34; ]]; then err=$(expr $err + 1) sleep 1 continue else err=0 break fi done if [[ $err != \u0026#34;0\u0026#34; ]]; then echo \u0026#34;systemctl stop keepalived\u0026#34; /usr/bin/systemctl stop keepalived exit 1 else exit 0 fi # 啟動haproxy和keepalived----\u0026gt;所有master節點 root@k8s-master71u:~# chmod +x /etc/keepalived/check_apiserver.sh root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl enable --now haproxy root@k8s-master71u:~# systemctl enable --now keepalived root@k8s-master71u:~# systemctl restart haproxy root@k8s-master71u:~# systemctl restart keepalived root@k8s-master71u:~# systemctl status haproxy root@k8s-master71u:~# systemctl status keepalived # 測試lbip是否生效(從node節點測試的) root@k8s-node76u:~# telnet 192.168.1.74 7443 Trying 192.168.1.74... Connected to 192.168.1.74. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. 三、初始化配置文件 操作節點： 只在master節點（k8s-master）執行\nhttps://kubernetes.io/docs/reference/config-api/kubeadm-config.v1beta3/\n# 1.24.0版本之後，需修改為criSocket: unix:///var/run/cri-dockerd.sock # 1.27.x版本之後，需修改為apiVersion: kubeadm.k8s.io/v1beta3，v1beta2不能用了 # imageRepository: k8s.gcr.io已不更新，改imageRepository: registry.k8s.io # clusterName: kubernetes -\u0026gt;依自己需求修改 # dns: type: CoreDNS 已棄用，不用寫 root@k8s-master71u:~# vim kubeadm.yaml apiVersion: kubeadm.k8s.io/v1beta3 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: 7t2weq.bjbawausm0jaxury ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration localAPIEndpoint: advertiseAddress: 192.168.1.71 bindPort: 6443 nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock name: k8s-master71u taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: certSANs: - 192.168.1.74 timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta3 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controlPlaneEndpoint: 192.168.1.74:7443 controllerManager: {} etcd: local: dataDir: /var/lib/etcd imageRepository: registry.k8s.io kind: ClusterConfiguration kubernetesVersion: v1.26.3 networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 serviceSubnet: 10.245.0.0/16 scheduler: {} 四、提前下載鏡像 操作節點：所有master節點執行\nroot@k8s-master71u:~# kubeadm config images list --config kubeadm.yaml registry.k8s.io/kube-apiserver:v1.26.3 registry.k8s.io/kube-controller-manager:v1.26.3 registry.k8s.io/kube-scheduler:v1.26.3 registry.k8s.io/kube-proxy:v1.26.3 registry.k8s.io/pause:3.9 registry.k8s.io/etcd:3.5.6-0 registry.k8s.io/coredns/coredns:v1.9.3 root@k8s-master71u:~# kubeadm config images pull --config kubeadm.yaml [config/images] Pulled registry.k8s.io/kube-apiserver:v1.26.3 [config/images] Pulled registry.k8s.io/kube-controller-manager:v1.26.3 [config/images] Pulled registry.k8s.io/kube-scheduler:v1.26.3 [config/images] Pulled registry.k8s.io/kube-proxy:v1.26.3 [config/images] Pulled registry.k8s.io/pause:3.9 [config/images] Pulled registry.k8s.io/etcd:3.5.6-0 [config/images] Pulled registry.k8s.io/coredns/coredns:v1.9.3 五、初始化master節點 操作節點：只在master節點（k8s-master）執行，找一台master執行即可\nroot@k8s-master71u:~# kubeadm init --config kubeadm.yaml --upload-certs ## 若初始化成功後，最後會提示如下信息： Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of the control-plane node running the following command on each as root: kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a Please note that the certificate-key gives access to cluster sensitive data, keep it secret! As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use \u0026#34;kubeadm init phase upload-certs --upload-certs\u0026#34; to reload certs afterward. Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 ## 接下來按照上述提示信息操作，配置kubectl客戶端的認證 root@k8s-master71u:~# mkdir -p $HOME/.kube root@k8s-master71u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master71u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config 若執行初始化過程中出錯，根據錯誤信息調整後，執行 kubeadm reset -f ; ipvsadm \u0026ndash;clear ; rm -rf ~/.kube ; rm -rf /etc/kubernetes/manifests/* ; rm -rf /var/lib/etcd/\n六、添加其他master節點到集群中 # k8s-master72u主機 root@k8s-master72u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a \\ --cri-socket=unix:///var/run/cri-dockerd.sock root@k8s-master72u:~# mkdir -p $HOME/.kube root@k8s-master72u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master72u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config # k8s-master73u主機 root@k8s-master73u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a \\ --cri-socket=unix:///var/run/cri-dockerd.sock root@k8s-master73u:~# mkdir -p $HOME/.kube root@k8s-master73u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master73u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config 七、添加node節點到集群中 操作節點：所有的node節點（k8s-node）需要執行 在每台node節點，執行如下命令，該命令是在kubeadm init成功後提示信息中打印出來的，需要替換成實際init後打印出的命令。\n# k8s-node75u主機 root@k8s-node75u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --cri-socket=unix:///var/run/cri-dockerd.sock # k8s-node76u主機 root@k8s-node76u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --cri-socket=unix:///var/run/cri-dockerd.sock 如果忘記添加命令，可以通過如下命令生成：\n$ kubeadm token create --print-join-command 查看目前node狀況:\nroot@k8s-master71u:~# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master71u NotReady control-plane 10m v1.26.3 k8s-master72u NotReady control-plane 3m58s v1.26.3 k8s-master73u NotReady control-plane 2m57s v1.26.3 k8s-node75u NotReady \u0026lt;none\u0026gt; 55s v1.26.3 k8s-node76u NotReady \u0026lt;none\u0026gt; 51s v1.26.3 部署容器網絡（calico） 操作節點：只在master節點（k8s-master）執行，找一台master執行即可，CNI\nCalico是一個純三層的數據中心網絡方案，是目前Kubernetes主流的網絡方案。\nhttps://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart\nroot@k8s-master71u:~# mkdir calico root@k8s-master71u:~# cd calico/ root@k8s-master71u:~/calico# wget https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/tigera-operator.yaml root@k8s-master71u:~/calico# wget https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/custom-resources.yaml root@k8s-master71u:~/calico# kubectl create -f tigera-operator.yaml # cidr ip部分，與前面kubeadm init的 --pod-network-cidr指定的一樣。 root@k8s-master71u:~/calico# vim custom-resources.yaml # This section includes base Calico installation configuration. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.Installation apiVersion: operator.tigera.io/v1 kind: Installation metadata: name: default spec: # Configures Calico networking. calicoNetwork: # Note: The ipPools section cannot be modified post-install. ipPools: - blockSize: 26 cidr: 10.244.0.0/16 encapsulation: VXLANCrossSubnet natOutgoing: Enabled nodeSelector: all() --- # This section configures the Calico API server. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.APIServer apiVersion: operator.tigera.io/v1 kind: APIServer metadata: name: default spec: {} root@k8s-master71u:~/calico# kubectl create -f custom-resources.yaml # 等Calico Pod都Running，節點也會准備就緒。 root@k8s-master71u:~/calico# kubectl get pods -n calico-system NAME READY STATUS RESTARTS AGE calico-kube-controllers-676484d755-9llvm 1/1 Running 0 16m calico-node-2s4gl 1/1 Running 0 16m calico-node-f9dz9 1/1 Running 0 16m calico-node-kvc55 1/1 Running 0 16m calico-node-l9gb2 1/1 Running 0 16m calico-node-xdp42 1/1 Running 0 16m calico-typha-98f544f9f-nqc4n 1/1 Running 0 16m calico-typha-98f544f9f-plpnn 1/1 Running 0 16m calico-typha-98f544f9f-vgrmn 1/1 Running 0 16m csi-node-driver-42c8p 2/2 Running 0 16m csi-node-driver-kdd42 2/2 Running 0 16m csi-node-driver-nxf5d 2/2 Running 0 16m csi-node-driver-rphdj 2/2 Running 0 16m csi-node-driver-shs2s 2/2 Running 0 16m root@k8s-master71u:~/calico# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master71u Ready control-plane 31m v1.26.3 k8s-master72u Ready control-plane 24m v1.26.3 k8s-master73u Ready control-plane 23m v1.26.3 k8s-node75u Ready \u0026lt;none\u0026gt; 21m v1.26.3 k8s-node76u Ready \u0026lt;none\u0026gt; 21m v1.26.3 root@k8s-master71u:~/calico# kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE coredns-787d4945fb-6x8v2 1/1 Running 0 31m coredns-787d4945fb-ddpgp 1/1 Running 0 31m etcd-k8s-master71u 1/1 Running 0 31m etcd-k8s-master72u 1/1 Running 0 24m etcd-k8s-master73u 1/1 Running 0 23m kube-apiserver-k8s-master71u 1/1 Running 0 31m kube-apiserver-k8s-master72u 1/1 Running 0 24m kube-apiserver-k8s-master73u 1/1 Running 1 (23m ago) 23m kube-controller-manager-k8s-master71u 1/1 Running 1 (24m ago) 31m kube-controller-manager-k8s-master72u 1/1 Running 0 24m kube-controller-manager-k8s-master73u 1/1 Running 0 22m kube-proxy-4rtwz 1/1 Running 0 23m kube-proxy-84v9t 1/1 Running 0 24m kube-proxy-9bh8t 1/1 Running 0 21m kube-proxy-m5gj8 1/1 Running 0 21m kube-proxy-x4t5v 1/1 Running 0 31m kube-scheduler-k8s-master71u 1/1 Running 1 (24m ago) 31m kube-scheduler-k8s-master72u 1/1 Running 0 24m kube-scheduler-k8s-master73u 1/1 Running 0 22m 註：以後所有yaml文件都只在Master節點執行。\n安裝目錄：/etc/kubernetes/\n組件配置文件目錄：/etc/kubernetes/manifests/\n集群設置 設置master節點是否可調度（可選） 操作節點：k8s-master\n默認部署成功後，master節點無法調度業務pod，如需設置master節點也可以參與pod的調度，需執行：\n$ kubectl taint node k8s-master node-role.kubernetes.io/master:NoSchedule- 設置kubectl自動補全 操作節點：k8s-master\nroot@k8s-master71u:~# apt install -y bash-completion root@k8s-master71u:~# apt install plocate root@k8s-master71u:~# locate bash_completion root@k8s-master71u:~# source /usr/share/bash-completion/bash_completion root@k8s-master71u:~# source \u0026lt;(kubectl completion bash) root@k8s-master71u:~# echo \u0026#34;source \u0026lt;(kubectl completion bash)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 調整證書過期 使用kubeadm安裝的集群，證書默認有效期為1年，可以通過如下方式修改為10年。全部master節點都要執行\nroot@k8s-master71u:~/calico# cd /etc/kubernetes/pki root@k8s-master71u:/etc/kubernetes/pki# for i in $(ls *.crt); do echo \u0026#34;===== $i =====\u0026#34;; openssl x509 -in $i -text -noout | grep -A 3 \u0026#39;Validity\u0026#39; ; done ===== apiserver.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:27 2024 GMT Subject: CN = kube-apiserver ===== apiserver-etcd-client.crt ===== Validity Not Before: Sep 20 04:42:28 2023 GMT Not After : Sep 19 04:42:29 2024 GMT Subject: O = system:masters, CN = kube-apiserver-etcd-client ===== apiserver-kubelet-client.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:27 2024 GMT Subject: O = system:masters, CN = kube-apiserver-kubelet-client ===== ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = kubernetes ===== front-proxy-ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = front-proxy-ca ===== front-proxy-client.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:28 2024 GMT Subject: CN = front-proxy-client root@k8s-master71u:/etc/kubernetes/pki# mkdir backup_key; cp -rp ./* backup_key/ root@k8s-master71u:/etc/kubernetes/pki# git clone https://github.com/yuyicai/update-kube-cert.git root@k8s-master71u:/etc/kubernetes/pki# cd update-kube-cert/ root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# bash update-kubeadm-cert.sh all root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# kubectl -n kube-system delete po kube-apiserver-k8s-master71u kube-apiserver-k8s-master72u kube-apiserver-k8s-master73u kube-controller-manager-k8s-master71u kube-controller-manager-k8s-master72u kube-controller-manager-k8s-master73u kube-scheduler-k8s-master71u kube-scheduler-k8s-master72u kube-scheduler-k8s-master73u root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# kubectl get pod -n kube-system NAME READY STATUS RESTARTS AGE coredns-787d4945fb-6x8v2 1/1 Running 0 36m coredns-787d4945fb-ddpgp 1/1 Running 0 36m etcd-k8s-master71u 1/1 Running 0 36m etcd-k8s-master72u 1/1 Running 0 29m etcd-k8s-master73u 1/1 Running 0 28m kube-apiserver-k8s-master71u 1/1 Running 0 30s kube-apiserver-k8s-master72u 1/1 Running 0 30s kube-apiserver-k8s-master73u 1/1 Running 1 (28m ago) 30s kube-controller-manager-k8s-master71u 1/1 Running 1 (29m ago) 30s kube-controller-manager-k8s-master72u 1/1 Running 0 30s kube-controller-manager-k8s-master73u 1/1 Running 0 30s kube-proxy-4rtwz 1/1 Running 0 28m kube-proxy-84v9t 1/1 Running 0 29m kube-proxy-9bh8t 1/1 Running 0 26m kube-proxy-m5gj8 1/1 Running 0 26m kube-proxy-x4t5v 1/1 Running 0 36m kube-scheduler-k8s-master71u 1/1 Running 2 (69s ago) 30s kube-scheduler-k8s-master72u 1/1 Running 0 30s kube-scheduler-k8s-master73u 1/1 Running 0 30s root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# cd /etc/kubernetes/pki root@k8s-master71u:/etc/kubernetes/pki# for i in $(ls *.crt); do echo \u0026#34;===== $i =====\u0026#34;; openssl x509 -in $i -text -noout | grep -A 3 \u0026#39;Validity\u0026#39; ; done ===== apiserver.crt ===== Validity Not Before: Sep 20 05:17:58 2023 GMT Not After : Sep 17 05:17:58 2033 GMT Subject: CN = kube-apiserver ===== apiserver-etcd-client.crt ===== Validity Not Before: Sep 20 05:17:55 2023 GMT Not After : Sep 17 05:17:55 2033 GMT Subject: O = system:masters, CN = kube-apiserver-etcd-client ===== apiserver-kubelet-client.crt ===== Validity Not Before: Sep 20 05:17:58 2023 GMT Not After : Sep 17 05:17:58 2033 GMT Subject: O = system:masters, CN = kube-apiserver-kubelet-client ===== ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = kubernetes ===== front-proxy-ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = front-proxy-ca ===== front-proxy-client.crt ===== Validity Not Before: Sep 20 05:17:59 2023 GMT Not After : Sep 17 05:17:59 2033 GMT Subject: CN = front-proxy-client 驗證集群 操作節點： 在master節點（k8s-master）執行\nroot@k8s-master71u:~# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master71u Ready control-plane 39m v1.26.3 k8s-master72u Ready control-plane 32m v1.26.3 k8s-master73u Ready control-plane 31m v1.26.3 k8s-node75u Ready \u0026lt;none\u0026gt; 29m v1.26.3 k8s-node76u Ready \u0026lt;none\u0026gt; 29m v1.26.3 root@k8s-master71u:~# kubectl run test-nginx --image=nginx:alpine pod/test-nginx created root@k8s-master71u:~# kubectl get pod -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES test-nginx 1/1 Running 0 21s 10.244.255.195 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; root@k8s-master71u:~# curl 10.244.255.195 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2023-10-07T02:30:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-install/","title":"kubeadm安裝 高可用版(ubuntu2204+k8s版本1.26.3+docker+cri-docker)"},{"content":"\nRancher官網安裝網址： https://ranchermanager.docs.rancher.com/zh/pages-for-subheaders/rancher-on-a-single-node-with-docker\n最新版Rancher(v2.7.6)能夠納管的kubernetes版本為1.26.4： https://www.suse.com/suse-rancher/support-matrix/all-supported-versions/rancher-v2-7-6/ 一、Rancher Server安裝 一、使用docker起容器 root@k8s-node75u:~# sudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher root@k8s-node75u:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0e92a3ece9cd rancher/rancher \u0026#34;entrypoint.sh\u0026#34; 4 minutes ago Up About a minute 0.0.0.0:80-\u0026gt;80/tcp, :::80-\u0026gt;80/tcp, 0.0.0.0:443-\u0026gt;443/tcp, :::443-\u0026gt;443/tcp dreamy_rubin 二、查看初始密碼 root@k8s-node75u:~# docker logs 0e92a3ece9cd 2\u0026gt;\u0026amp;1 | grep \u0026#34;Bootstrap Password:\u0026#34; 2023/09/20 09:50:01 [INFO] Bootstrap Password: 79j4khgd9952rmn55kdntxt7kwxfn7f7dvpmrsgx6nr7wqblrtpp6l 三、登入 四、重新設定admin密碼 登入成功頁面 二、匯入現有集群 一、點選Import Existing 二、點選Import any Kubernetes cluster(Generic) 三、填寫Cluster Name(自己決定，以利後續辨識)，點選Create 四、創建之後，會有提供加入的方式，選擇第二項 # master節點執行 root@k8s-master71u:~# curl --insecure -sfL https://192.168.1.75/v3/import/ff4mlx8k768hsz8vmwl89lqhbmcsfbttkxqdtmk4m8pgqsrnd87pqc_c-m-gq2vbtfn.yaml | kubectl apply -f - # 查看pod是否都創建成功 root@k8s-master71u:~# kubectl get pod -n cattle-system -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES cattle-cluster-agent-6c97c478bb-mjgwg 1/1 Running 0 5m 10.244.14.137 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; cattle-cluster-agent-6c97c478bb-vdn59 1/1 Running 0 16m 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; rancher-webhook-74c9bd4d6-znrdp 1/1 Running 0 61s 10.244.255.201 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 五、確認現有集群已加入納管 加入rancher需要一點時間，請耐心等候，如果鏡像拉取失敗，可以手動去下載鏡像\n六、開啟Kubectl Shell介面，Rancher會臨時起一個容器來跑Shell指令，關閉Shell介面，容器就會刪除 root@k8s-master71u:~# kubectl get pod -n cattle-system -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES cattle-cluster-agent-6c97c478bb-mjgwg 1/1 Running 0 6m11s 10.244.14.137 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; cattle-cluster-agent-6c97c478bb-vdn59 1/1 Running 0 17m 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; dashboard-shell-75g77 2/2 Running 0 9s 10.244.255.202 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; rancher-webhook-74c9bd4d6-znrdp 1/1 Running 0 2m12s 10.244.255.201 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 三、加入Windows Server Active Directory (LDAP) Rancher官網設定網址： https://ranchermanager.docs.rancher.com/zh/how-to-guides/new-user-guides/authentication-permissions-and-global-configuration/authentication-config/configure-active-directory\n一、查看可以整合登入驗證的方式 二、創建AD使用者，供Rancher獲取ldap使用者資料 三、使用ldapsearch測試一下，是否可以查找到剛剛建立的使用者資訊 chenqingze@chenqingze-MBP ~ % ldapsearch -x -H \u0026#34;ldap://192.168.1.49:389\u0026#34; -D \u0026#34;jimmyhome\\rancheruser\u0026#34; -w \u0026#34;密碼\u0026#34; \\ -b \u0026#34;dc=jimmyhome,dc=tw\u0026#34; -s sub \u0026#34;sAMAccountName=rancheruser\u0026#34; # extended LDIF # # LDAPv3 # base \u0026lt;dc=jimmyhome,dc=tw\u0026gt; with scope subtree # filter: sAMAccountName=rancheruser # requesting: ALL # # rancheruser, Users, jimmyhome.tw dn: CN=rancheruser,CN=Users,DC=jimmyhome,DC=tw objectClass: top objectClass: person objectClass: organizationalPerson objectClass: user cn: rancheruser givenName: rancheruser distinguishedName: CN=rancheruser,CN=Users,DC=jimmyhome,DC=tw instanceType: 4 whenCreated: 20230920115311.0Z whenChanged: 20230920120448.0Z displayName: rancheruser uSNCreated: 16399 uSNChanged: 16452 name: rancheruser objectGUID:: B9nTPDTyY0ehHZz4mWIJ1Q== userAccountControl: 66048 badPwdCount: 0 codePage: 0 countryCode: 0 badPasswordTime: 0 lastLogoff: 0 lastLogon: 0 pwdLastSet: 133396843913520620 primaryGroupID: 513 objectSid:: AQUAAAAAAAUVAAAA2KPkIYA62ax0WlhyTwQAAA== accountExpires: 9223372036854775807 logonCount: 0 sAMAccountName: rancheruser sAMAccountType: 805306368 userPrincipalName: rancheruser@jimmyhome.tw objectCategory: CN=Person,CN=Schema,CN=Configuration,DC=jimmyhome,DC=tw dSCorePropagationData: 16010101000000.0Z lastLogonTimestamp: 133396850882972826 # search reference ref: ldap://ForestDnsZones.jimmyhome.tw/DC=ForestDnsZones,DC=jimmyhome,DC=tw # search reference ref: ldap://DomainDnsZones.jimmyhome.tw/DC=DomainDnsZones,DC=jimmyhome,DC=tw # search reference ref: ldap://jimmyhome.tw/CN=Configuration,DC=jimmyhome,DC=tw # search result search: 2 result: 0 Success # numResponses: 5 # numEntries: 1 # numReferences: 3 四、整合AD驗證 確認驗證成功，連接到ldap 可以看到，此時已經自動改成用剛剛驗證的ad帳戶登入了 五、再到AD創建一個使用者，驗證一下，是否Rancher可以獲取到此使用者帳號 編輯default project(裡面只有一個default namespace) 添加ldap帳號 可以看到有jimmy帳號 添加此帳號 登出Rancher，改用jimmy帳號登入，密碼是ad中設定的密碼 確認可以登入 可以看到，能查看到default project與default namespace dashboard shell也是可以使用的，但只能看到default namespace的資源 是無法查看kube-system namespace的資源，確實跟前面設定的權限是符合的 六、也可以下載連線設定檔到自己常用linux主機，連線管理 # 1. 將下載的設定檔，scp到常用linux主機 chenqingze@chenqingze-MBP ~ % scp /Users/chenqingze/Downloads/kubernetes-config.yml root@192.168.1.76:/root/ # 2. 可以看到設定檔 root@k8s-node76u:~# ls -l total 9376 -rw-r--r-- 1 root root 1396 Sep 20 12:47 kubernetes-config.yml # 3. 在使用者家目錄下，創建.kube目錄 root@k8s-node76u:~# mkdir .kube # 4. 將設定檔複製到.kube目錄，且命名為config(因kubectl預設就是用.kube/config設定檔連線) root@k8s-node76u:~# cp kubernetes-config.yml ~/.kube/config # 5. 確認可以連線，查看default namespace下的資源 root@k8s-node76u:~# kubectl get pod NAME READY STATUS RESTARTS AGE test-nginx 1/1 Running 1 (3h20m ago) 7h26m # 6. 其他namespace下的資源，是無法查看的 root@k8s-node76u:~# kubectl get pod -n kube-system Error from server (Forbidden): pods is forbidden: User \u0026#34;u-hx7xy6ap22\u0026#34; cannot list resource \u0026#34;pods\u0026#34; in API group \u0026#34;\u0026#34; in the namespace \u0026#34;kube-system\u0026#34; ","date":"2023-10-07T02:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-docker/","title":"使用Docker安裝Rancher管理平台，納管現有k8s集群(單節點-非高可用)"},{"content":"\n安裝先決條件：\nkubernetes 集群 Ingress Controller Helm 、kubectl CLI 工具 一、Ingress Controller安裝 github網址:\nhttps://github.com/kubernetes/ingress-nginx\nchenqingze@chenqingze-MBP ~ % scp /Users/chenqingze/Downloads/ingress-nginx-controller-v1.6.4.tar.gz root@192.168.1.71:/root / root@k8s-master71u:~# tar -xzvf ingress-nginx-controller-v1.6.4.tar.gz root@k8s-master71u:~# cd ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal # Deployment改成DaemonSet # 添加hostNetwork: true root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# vim deploy.yaml --- apiVersion: apps/v1 kind: DaemonSet metadata: labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.6.4 name: ingress-nginx-controller namespace: ingress-nginx spec: minReadySeconds: 0 revisionHistoryLimit: 10 selector: matchLabels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx template: metadata: labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx spec: hostNetwork: true containers: root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# kubectl apply -f deploy.yaml root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# kubectl get pod -n ingress-nginx -owide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES ingress-nginx-admission-create-zmkrl 0/1 Completed 0 73s 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-admission-patch-rlglf 0/1 Completed 0 73s 10.244.14.133 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-controller-js2fl 1/1 Running 0 73s 192.168.1.76 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-controller-mmc2h 1/1 Running 0 73s 192.168.1.75 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 二、Kubectl與Helm CLI 工具安裝 官方安裝網站： https://helm.sh/docs/intro/install/\nHelm v3.12.3 Binary Releases： https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz\nroot@k8s-master71u:~# wget https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz root@k8s-master71u:~# tar -zxvf helm-v3.12.3-linux-amd64.tar.gz root@k8s-master71u:~# mv linux-amd64/helm /usr/local/bin/helm Kubectl： https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n如果主機就是master,應該都有kubectl了,此流程可以略過\n# 1. Update the apt package index and install packages needed to use the Kubernetes apt repository: sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl # 2. Download the Google Cloud public signing key: curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg # 3. Add the Kubernetes apt repository: echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/kubernetes.list deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main # 5. Update apt package index, install kubelet, kubeadm and kubectl, and pin their version: sudo apt-get update root@k8s-master71u:~# sudo apt-get install -y kubectl=1.26.3-00 # 查看版本 root@k8s-master71u:~# kubectl version 三、Rancher高可用管理平台安裝 一、添加 Helm Chart 倉庫 root@k8s-master71u:~# helm repo add rancher-stable https://releases.rancher.com/server-charts/stable \u0026#34;rancher-stable\u0026#34; has been added to your repositories 二、為 Rancher 建立命名空間 root@k8s-master71u:~# kubectl create namespace cattle-system 三、選擇 SSL 配置 Rancher 產生的憑證（預設） 需要 cert-manager\n四、安裝 cert-manager # 如果你手動安裝了CRD，而不是在 Helm 安裝命令中添加了 \u0026#39;--set installCRDs=true\u0026#39; 選項，你應該在升級 Helm Chart 之前升級 CRD 資源。 root@k8s-master71u:~# kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.crds.yaml # 添加 Jetstack Helm 倉庫 root@k8s-master71u:~# helm repo add jetstack https://charts.jetstack.io # 更新本地 Helm Chart 倉庫緩存 root@k8s-master71u:~# helm repo update Hang tight while we grab the latest from your chart repositories... ...Successfully got an update from the \u0026#34;jetstack\u0026#34; chart repository ...Successfully got an update from the \u0026#34;rancher-stable\u0026#34; chart repository Update Complete. ⎈Happy Helming!⎈ # 安裝 cert-manager Helm Chart root@k8s-master71u:~# helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.11.0 # 安裝完 cert-manager 后，你可以通過檢查 cert-manager 命名空間中正在運行的 Pod 來驗證它是否已正確部署 root@k8s-master71u:~# kubectl get pods --namespace cert-manager NAME READY STATUS RESTARTS AGE cert-manager-64f9f45d6f-8j65z 1/1 Running 0 2m1s cert-manager-cainjector-56bbdd5c47-4hngr 1/1 Running 0 2m1s cert-manager-startupapicheck-vzq7z 0/1 Completed 0 2m cert-manager-webhook-d4f4545d7-rhbkv 1/1 Running 0 2m1s 五、根據你選擇的證書選項，通過 Helm 安裝 Rancher 採Rancher 生成的證書方式\nRancher Helm Chart 選項： https://ranchermanager.docs.rancher.com/zh/getting-started/installation-and-upgrade/installation-references/helm-chart-options\n需多指定ingressClassName為nginx\nroot@k8s-master71u:~# helm install rancher rancher-stable/rancher \\ --namespace cattle-system \\ --set hostname=rancher.jimmyhome.tw \\ --set bootstrapPassword=admin \\ --set ingress.ingressClassName=nginx NAME: rancher LAST DEPLOYED: Wed Sep 20 18:31:10 2023 NAMESPACE: cattle-system STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: Rancher Server has been installed. NOTE: Rancher may take several minutes to fully initialize. Please standby while Certificates are being issued, Containers are started and the Ingress rule comes up. Check out our docs at https://rancher.com/docs/ If you provided your own bootstrap password during installation, browse to https://rancher.jimmyhome.tw to get started. If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates: echo https://rancher.jimmyhome.tw/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}\u0026#39;) To get just the bootstrap password on its own, run: kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}{{ \u0026#34;\\n\u0026#34; }}\u0026#39; Happy Containering! # 等待 Rancher 運行 root@k8s-master71u:~# kubectl -n cattle-system rollout status deploy/rancher Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 0 of 3 updated replicas are available... Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 1 of 3 updated replicas are available... Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 2 of 3 updated replicas are available... deployment \u0026#34;rancher\u0026#34; successfully rolled out 六、驗證 Rancher Server 是否部署成功 root@k8s-master71u:~# kubectl -n cattle-system get deploy NAME READY UP-TO-DATE AVAILABLE AGE rancher 3/3 3 3 53s root@k8s-master71u:~# kubectl -n cattle-system get ingress NAME CLASS HOSTS ADDRESS PORTS AGE rancher nginx rancher.jimmyhome.tw 192.168.1.75,192.168.1.76 80, 443 67s # 我自己的筆電，先設定/etc/hosts測試網頁訪問 # 如是內部有dns server的，就到dns server設定a record解析 chenqingze@chenqingze-MBP ~ % sudo vim /etc/hosts 192.168.1.75 rancher.jimmyhome.tw 打 https://rancher.jimmyhome.tw 可以看到網頁 由上方helm install rancher完成時，可以看到以下兩個指令，可以獲取到預設admin帳號的密碼\n# If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates root@k8s-master71u:~# echo https://rancher.jimmyhome.tw/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}\u0026#39;) https://rancher.jimmyhome.tw/dashboard/?setup=admin # To get just the bootstrap password on its own, run root@k8s-master71u:~# kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}{{ \u0026#34;\\n\u0026#34; }}\u0026#39; admin 重設admin帳號的密碼 輸入剛剛重設的admin密碼，登入 可以看到集群資訊，state為Active 進入集群，可以看到集群詳細訊息 也可以使用dashboard shell去管理集群 ","date":"2023-10-07T01:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-helm/","title":"使用Helm安裝Rancher管理平台，納管現有k8s集群( 高可用)"}]