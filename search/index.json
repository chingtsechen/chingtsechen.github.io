[{"content":"學習影片 ","date":"2023-11-13T22:17:56+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/youtuber-wawa-gong-learn-korean-lesson002/","title":"Lesson002 - 韓文40音(下)ㅣ分不清的那些子音母音們！氣音硬音子音, 複合母音一次搞懂"},{"content":"學習影片 ","date":"2023-11-13T22:10:52+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/youtuber-wawa-gong-learn-korean-lesson001/","title":"Lesson001 - 韓文40音｜發音技巧大公開(上)｜說出一口道地韓文腔"},{"content":"學習影片 40音子母音列表 學韓文前必知5大重點 1. 韓文40音分為子音19個 母音21個 2. 母音不會單獨出現成唯一個字 3. 韓文4大類造字規則 4. 搞懂初聲、中聲、終聲 (收尾音) 5. 韓文有許多發音規則 不一定就是造字面上的唸法 ","date":"2023-11-13T21:32:12+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/youtuber-wawa-gong-learn-korean-lesson003/","title":"Lesson003 - 韓文40音總整理ㅣ一起唸完子母音399字ㅣ韓文初學必知5大重點！表格請參閱說明欄自行下載"},{"content":"據述 來源：Google Bard\n該劇講述了四位年輕人創業的故事。他們來自不同的背景，但都有著一個共同的夢想，那就是成功創業。\n劇照 來源：\nhttps://news.agentm.tw/145093/\n","date":"2023-11-13T19:41:53+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/movie-start-up/media/Pasted-image-20231113194929_hu277e65009fbe4d342f0377e2ba8a75fa_392382_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/movie-start-up/","title":"Start-Up：我的新創時代"},{"content":"學習影片 ## 單字 originally adv. 原本 absolute adj. 絕對的 admission n. 入場費，門票費 purchase v. 購買 character n. （電影、戲劇或故事中的）人物 imitate v. 模仿 stationery n. 文具 文法 一般副詞 (Adverbs)\nAdverbs and adjectives both have the function of modifying. Adjectives modify nouns, while adverbs can modify verbs, adjectives, prepositional phrases, clauses, and more. By using adverbs, we can enhance the expression of actions, their states, and degrees. Many adverbs are formed by adding \u0026ldquo;-ly\u0026rdquo; (with some slight changes in certain cases) to adjectives. For example, in the sentence \u0026ldquo;However, we strongly recommend that you purchase advance tickets through E+ on the museum\u0026rsquo;s official website,\u0026rdquo; the adverb \u0026ldquo;strongly\u0026rdquo; modifies the verb \u0026ldquo;recommend.\u0026rdquo; Another example is: \u0026ldquo;Normally themed cafes at restaurants serve average dishes at best, just with jacked-up prices and shaped like Mickey Mouse or something.\u0026rdquo; Here, the adverb \u0026ldquo;normally\u0026rdquo; modifies the entire subsequent sentence. Here are some additional examples of different types of adverbs:\n副詞和形容詞都有修飾的功能。形容詞修飾名詞，而副詞則可以修飾動詞、形容詞、介係詞片語，或子句等。使用副詞，可以強化表達動作的狀態和程度。許多形容詞都可以透過＋ly（有些字尾須稍作變化）來形成副詞。 例如，影片中 However, we strongly recommend that you purchase advance tickets through E+ on the museum\u0026rsquo;s official website. （我們強力推薦你先去 Eplus 上的官方網站購買預售票。）就是透過把形容詞strong變為副詞，以修飾「推薦」。 或是：Normally themed cafes at restaurants serve average dishes at best just with jacked up prices and shaped like Mickey Mouse or something. （一般主題咖啡廳都會特別將餐點製作成米奇等其他模樣，美味程度普通，但價格卻很高。）就是用Normally來修飾接續的一整段句子。 以下再補充不同種類的副詞與例句：\n### 例句 - How soon can we sign the contract? 我們多快可以簽合約？（時間副詞） - We sat around the table. 我們圍著桌子坐下。（地方副詞） - Could you please speak more slowly? 你能講慢一點嗎？（情態副詞 ） ","date":"2023-11-13T16:08:26+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson018/media/Pasted-image-20231113193906_hud9c370b43a0c2b402e6b2448bf40dd2e_884162_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson018/","title":"Lesson018 - 東京旅遊新去處！帶你一窺 Snoopy 博物館！"},{"content":"學習影片 單字 effective adj.有效的 caffeine n.咖啡因 unconscious adj.無意識的；不省人事的 brake n.煞車 evidence n.證據，證明 error n.錯誤，差錯 consistently adv.一貫地 challenge n.挑戰；難題；考驗 cell n.細胞 文法 程度副詞 (Adverbs of Degree)\n本堂課中我們認識了兩個可用來修飾動作、狀態的程度副詞：a whole lot 以及 much。這兩個副詞（片語）常被用來修飾「形容詞比較級」，用來表示「更大程度上的\u0026hellip;」。看看以下的例句你們就會更清楚唷。\n### 例句 - I\u0026#39;m feeling a whole lot better now. Thanks for coming to check on me. 我感覺好很多了。謝謝你過來看我。 - The exam was much easier than I had expected. 考試比我預期的簡單很多。 - Things are about to get a whole lot worse. 事情即將變得更加糟糕。 ","date":"2023-11-13T15:43:41+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson019/media/Pasted-image-20231113160652_hu1d085bbb9ca07426bf68fbe61f6c15f3_431893_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson019/","title":"Lesson019 - 科學證實：喝杯咖啡再打個小盹，比只喝咖啡或只睡午覺還有效！"},{"content":"學習影片 YouTube影片連結： https://www.youtube.com/watch?v=v98ahM6mr-w\n單字 signature n. 簽名 aesthetic n. 審美觀 architect n. 建築師 blurred adj. 模糊的 shelter n. 遮蔽處 component n. 成分 disturbing adj. 讓人心煩的 intuitive adj. 直覺的 paradigm n. 範例，示例 static adj. 靜態的 文法 名詞子句 (Noun Clause)\nA noun clause acts as a noun and can be used as the subject, object, or complement. It starts with words like that, if, whether, where, when, how, and so on. For example, in this video, the speaker said, \u0026ldquo;I don\u0026rsquo;t know why I said it.\u0026rdquo; In this sentence, \u0026ldquo;why I said it\u0026rdquo; is a noun clause. Though it starts with the question word \u0026ldquo;why\u0026rdquo;, the speaker wasn’t trying to ask the audience a question but to talk about \u0026ldquo;the reason\u0026rdquo; he said something. Let’s look at another example sentence: \u0026ldquo;That\u0026rsquo;s how I got to this freedom of expression.\u0026rdquo; Here, \u0026ldquo;how I got to this freedom of expression\u0026rdquo; is also a noun clause, and the speaker wasn\u0026rsquo;t trying to ask a question here, either. He was talking about \u0026ldquo;the way\u0026rdquo; he did something.\n「名詞子句」是指能扮演名詞角色的子句，可以做為主詞、補語、受詞使用，由 that, if, whether, where, when, how 等等開頭，如本課的例句 I don\u0026rsquo;t know why I said it. 其中以 why 開頭的名詞子句 why I said it ，並不是講者提出疑問，想問觀眾「為什麼？」，而是說明「我那麼說的『原因』」。另外一句 That\u0026rsquo;s how I got to this freedom of expression. 其中以 how 開頭的名詞子句 how I got to this freedom of expression，也不是講者要問觀眾「如何？」，而是說明「我到達這種表達自由的境界的方式」。我們來看看更多名詞子句的例子：\n### 例句 - He doesn\u0026#39;t know that I broke his phone. 他不知道我弄壞他的手機。 - I\u0026#39;d like to demonstrate how to use the printer. 我想示範如何使用影印機。 - The counselor will show you where your cabin is. 輔導員會告訴你你的小木屋在哪。 ","date":"2023-11-09T23:11:44+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson017/media/Pasted-image-20231109231601_hu5ff5a81c135121c3e7197bbdb2aae552_884318_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson017/","title":"Lesson017 - 建築大師帶你參觀巴黎新地標：LV 美術館"},{"content":"據述 來源：Google Bard\n該劇講述了患上雷普利症候群的女人李由美，為了滿足虛榮心而不惜編造家世、造假學歷，後來更偷了老闆千金李安娜的身分不斷往上爬，並且逆襲嫁入豪門的故事。\n裴智秀在劇中飾演李由美/李安娜，她在劇中的表現非常出色，獲得了觀眾的一致好評。她把李由美/李安娜這個複雜的角色演繹得非常生動，讓人看到了她內心深處的掙扎和痛苦。\n《安娜》是一部非常精彩的懸疑犯罪劇，它不僅探討了人性中的虛榮和欲望，也展現了社會中階層固化的現實。如果你喜歡裴智秀的演技，那麼我相信你也會喜歡這部劇。\n劇照 來源： https://www.koreastardaily.com/sc/news/142228\n","date":"2023-11-09T00:22:14+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/movie-anna/media/Pasted-image-20231109003826_huae49c3c2e03cd8d0df990ea0365a1b72_1120970_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/movie-anna/","title":"安娜"},{"content":"據述 來源：Google Bard\n它是一部改編自閔宋雅的網路漫畫《愛上姐姐的理由》的浪漫愛情劇，由裴秀智和梁世宗主演。\n該劇講述了一位平凡的大學男生李元峻（梁世宗飾演）在Share House與華麗但已隱退的K-POP偶像李斗娜（裴秀智飾演）相遇後，展開了即使承諾不談戀愛卻又情不自禁愛上對方的浪漫愛情故事。\n《我的女神室友斗娜》於2023年10月20日在Netflix上線，共8集。該劇在播出後獲得了觀眾的一致好評，裴秀智和梁世宗的演技也得到了肯定。\n劇照 來源：\nhttps://mintnews.tw/Entertainment/Drama/content-36951.html\nhttps://www.cosmopolitan.com/tw/entertainment/movies/g45621420/doona-quote/\n","date":"2023-11-09T00:10:14+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/movie-doona/media/_huf77db7967c7060487b92283750069c4b_79445_a689d976cf37d9a1247a379c5b56e351.jpg","permalink":"https://blog.goldfishbrain-fighting.com/2023/movie-doona/","title":"我的女神室友斗娜"},{"content":"學習影片 單字 oversized adj. 特大號的；碩大的；太大的 specialty n. 專長 ounce n. 盎司（重量單位，1盎司約等於28克） beneath prep. 在...下方 wander v. 漫步 abandon v. 離棄 suspicious adj. 可疑的 chirp n. （尤指鳥）唧唧叫 crocodile n. 鱷魚 tuck v. 把…夾入；把…藏入；把…塞入 文法 分詞構句 (Participle Clauses)\nThere are two types of participles: present (V-ing) and past (V-ed). When two complete sentences (with subject and verb) have the same subject, we can change one of them into a participle clause by omitting the subject and change the verb into a past or present participle. Look at the example from the video, \u0026ldquo;The father has his own flotation issues to deal with, but he keeps up with them, watching for anything suspicious in the water.\u0026rdquo; We can rewrite this into \u0026ldquo;The father has his own flotation issues to deal with, but he keeps up with them, and he watches for anything suspicious in the water.\u0026rdquo; However, if we want to avoid repeating \u0026ldquo;he\u0026rdquo; in the last two sentences, we can omit the last one and change \u0026ldquo;watches\u0026rdquo; into the present participle \u0026ldquo;watching\u0026rdquo;. Whether the verb should be changed into the present or past participle depends on the voice. If it\u0026rsquo;s in active voice, we use the present participle, and if it\u0026rsquo;s in passive voice, that is, if the subject is acted upon by some other performer of the verb, we use the past participle. Take a look at more examples below.\n今天要來和大家介紹的是分詞構句。所謂分詞，共分為現在分詞（Ving）與過去分詞（Vpp）。分詞構句的使用時機是，當重複的主詞省略，並在動詞做出變化。 例如，The father has his own flotation issues to deal with, but he keeps up with them, watching for anything suspicious in the water.（水稚爸爸有自己的漂浮問題要擔心，但牠也隨時注意孩子們的安危，注意水裡是否有可疑的東西。） 該句原句應為：The father has his own flotation issues to deal with, but he keeps up with them, and he watches for anything suspicious in the water. 由於不想讓 he 再重複一次，所以使用分詞構句的文法。將主詞 he 去掉，並把watches這個動詞改成「現在分詞」watching，形成「分詞構句」。 關於動詞在變化時，該改成「現在分詞」或「過去分詞」，取決於主詞是「主動執行」該動作，還是「被動接受」該動作。詳見以下例句：\n### 例句 - Seeing the police coming, the thief quickly ran away.(= The thief saw the police coming, and the thief quickly ran away.) 看到警察來了，小偷就快速地跑了。主詞 the thief 重複，故省略其中一個。當省略的是前半句的主詞時，saw 要改成分詞。「看到」是小偷做出的動作，所以改成現在分詞 seeing。 - The thief is running on the street, chased by policemen. (= The thief is running on the street, and the thief was chased by policemen.) 小偷在街上跑，被警察追著。主詞 the thief 重複，故省略其中一個。當省略的是後半句的主詞時，was chased 把動詞 was 省略，留下分詞。小偷是「被追」，所以留下過去分詞 chased。 - Hearing her fans shouting out her name, the actress rolled down the car window to say hi. (= The actress heard her fans shouting out her name, so she rolled down the car window to say hi.) 演員聽到粉絲呼喊她的名字，搖下車窗打招呼。主詞 the actress 重複，故省略其中一個。當省略的是前半句的主詞時，heard 要改成分詞。「聽到」是演員做出的動作，所以改成現在分詞 hearing。 ","date":"2023-11-08T23:55:53+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson016/media/Pasted-image-20231109005157_hu69a61716c20fdf9a55c92a511a3f66a0_1174509_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson016/","title":"Lesson016 - 鱷魚來了！水雉爸爸如何保護雛鳥安全？"},{"content":"學習影片 單字 rebel n. 叛逆者 respect n. 重視；敬意 disagree v. 反對 backwards adv. 向後 connect v. 連接 trust v. 相信 limited adj. 有限的 inner adj. 內心的 courage n. 勇氣 trap v. 限制 文法 名詞子句 (Noun Clause)\nA noun clause acts as a noun and can be used as the subject, object, or complement. It starts with words like \u0026ldquo;that\u0026rdquo;, \u0026ldquo;if\u0026rdquo;, \u0026ldquo;whether\u0026rdquo;, \u0026ldquo;where\u0026rdquo;, \u0026ldquo;when\u0026rdquo;, \u0026ldquo;how\u0026rdquo;, and so on. For example, in this video, the speaker said, \u0026ldquo;You have to trust that the dots will somehow connect in your future.\u0026rdquo; In this sentence, \u0026ldquo;that the dots will somehow connect in your future\u0026rdquo; is a noun clause. It acts as the object of the verb \u0026ldquo;trust\u0026rdquo;. When a noun clause starting with \u0026ldquo;that\u0026rdquo; is the object, \u0026ldquo;that\u0026rdquo; can be omitted, so it\u0026rsquo;s grammatically correct to say \u0026ldquo;you have to trust the dots will somehow connect in your future\u0026rdquo; without \u0026ldquo;that\u0026rdquo; after \u0026ldquo;trust\u0026rdquo;. Let’s look at another example sentence: \u0026ldquo;They (your heart and intuition) somehow already know what you truly want to become.\u0026rdquo; Here, \u0026ldquo;what you truly want to become\u0026rdquo; is also a noun clause, and it is the object of \u0026ldquo;know\u0026rdquo;. Though it starts with the question word \u0026ldquo;what\u0026rdquo;, the speaker was trying to ask a question here.\n「名詞子句」是指能扮演名詞角色的子句，可以做為主詞、補語、受詞使用，由 that、if、whether、where、when、how 等字開頭，例如影片中講者說 You have to trust that the dots will somehow connect in your future.（你要相信在未來，這些點會以某種方式連接起來。）一句中，that the dots will somehow connect in your future 為名詞子句，作為動詞 trust 的受詞。如果 that 開頭的名詞子句作為受詞，that 可以省略，所以說 you have to trust the dots will somehow connect in your future，動詞 trust 後方沒有 that 文法上是正確的。 我們來看另一個例子：They (your heart and intuition) somehow already know what you truly want to become.（你的內心和直覺在某種程度上已經知道你真正想成為什麼。）這裡 what you truly want to become 也是名詞子句，作為動詞 know 的受詞。雖然以疑問詞 what 開頭，講者並不是在問問題。\n### 例句 - What Lily\u0026#39;s teacher said to her upset her a lot. Lily 老師和她說的事讓她很難過。 - I don\u0026#39;t believe (that) there\u0026#39;s nothing we can do. 我不相信我們無能為力了。 - The only thing I learned today is how to beat an egg. 我今天學到的只有怎麼打蛋。 ","date":"2023-11-08T23:50:53+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson015/media/Pasted-image-20231109004617_hu2ce1f30e5eb3d0491f1ceded5ee52057_341657_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson015/","title":"Lesson015 - 你的時間有限，所以不要浪費時間過別人的生活。"},{"content":"獲取影片ID，v=ID 影片連結：https://www.youtube.com/watch?v=KJM7Nj1DCwk\n影片ID：KJM7Nj1DCwk 結合以下網址就可以獲取封面照 將影片ID換成您的影片ID\n高解析度大圖（1280 × 720）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/maxresdefault.jpg 標準清晰圖 （640 × 480）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/sddefault.jpg 高品質縮圖（480×360）\nhttps://img.youtube.com/vi/KJM7Nj1DCwk/hqdefault.jpg 播放器背景縮圖（480×360）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/0.jpg　影片開始畫面縮圖（120×90）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/1.jpg 影片中間片段縮圖（120×90）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/2.jpg 影片結束縮圖（120×90）\nhttp://img.youtube.com/vi/KJM7Nj1DCwk/3.jpg 參考網站： https://www.kocpc.com.tw/archives/273287\n","date":"2023-11-06T11:43:35+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/youtube-cover-photo/","title":"獲取Youtube影片，封面照"},{"content":"學習影片 單字 parade n. 整排 cue n. 暗示；信號 grave n. 墳墓 snack n. 點心 surrounding n. 周圍環境 tempt v. 引誘 sight n. 視線 cupboard n. 櫥櫃 sample n. 試吃 decorate v. 裝飾 文法 第二類條件句 (The Second Conditional)\nIn this lesson, we talk about the sentence structure that is used to talk about \u0026ldquo;impossible\u0026rdquo; or \u0026ldquo;hypothetical\u0026rdquo; scenarios and bring out the possible outcomes. We call this structure \u0026ldquo;the second conditional\u0026rdquo;. In a subordinate clause guided by \u0026ldquo;if\u0026rdquo; (conditional clause), the verb will appear in the past tense, and the main clause (showing result) will often have the auxiliary \u0026ldquo;would\u0026rdquo;. The second conditional can refer to any time, with the scenario being hypothetical. In this lesson, the sentence \u0026ldquo;If I did buy any, I would keep them away in a cupboard.\u0026rdquo; is a presumption of something that contrasts the present. Take note of the use of \u0026ldquo;were to\u0026rdquo;, which is applicable to any of the following instances: - used in the present: To stress that the scenario described is highly unlikely, is impossible, and will lead to terrible results. Please keep in mind that this structure can only be used for if-clauses. E.g. If I were to have no friends, who would I spend my time with? - used for the future: To stress the scenario described is highly unlikely, is impossible, and can have a very bad outcome. E.g. If I were to lose my job next year,\n在本部影片中，我們學到了一種句型，它論及不可能或是假設性的情況，並帶出在這樣情況下可能會有的結果，而這類句子我們稱之為「第二類條件句」。在 if 引導的附屬子句 (條件子句) 中動詞是以過去式的型態出現，而主要子句 (結果句) 通常會出現 would 這個助動詞。第二類條件句的時間指的是現在或任何時候，而情況是假設的。本課的例句 \u0026ldquo;If I did buy any, I would keep them away in a cupboard.\u0026rdquo; 「假如我真的買了任何的某物，我會把它們放在櫥櫃裡。」這是一句與現在事實相反的假設。比較需要注意的是 were to 的用法，這種用法可以用於以下幾種情況。第一種是 were to 用於現在的情況，來強調此條件句所述的情況極不可能或完全不可能發生或非常可怕 (讓人不敢再想下去)。注意：這種特殊句型只用於 if 子句。例句：If I were to have no friends, who would I spend my time with? (如果我沒有朋友，我要跟誰消磨時間呢？) － 沒有朋友是個可怕的想法。無論人稱為何，都必須用 were。而第二種情況適用於未來的時間，來強調此條件句所述的情況極不可能或完全不可能發生，或非常可怕 (讓人不敢再想下去)。例如：If I were to lose my job next year, I would probably not find a new one quickly. (如果我明年失業，我可能不會很快找到新的工作) － 失業對我來說是很可怕的事。\n### 例句 - If I were you, I would definitely take the chance. 假如我是你，我就會把握機會。 （但實際上我不可能是你。） - If Keira were my supervisor, this job would be unbearable. 要是Keira是我的主管，這工作就會變得叫人無法忍受。 (但實際上 Keira 不是我的主管。) - Imagine if Gabriel were to show up late; it would ruin the surprise. 設想Gabriel若是遲到，就會破壞了驚喜。 (但事實上 Gabriel 沒有遲到。) ","date":"2023-11-06T11:33:11+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson014/media/Pasted-image-20231106114200_hu9689ad9bf018cce683f7c1a4e9f89a40_797334_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson014/","title":"Lesson014 - 不節食與運動如何減肥？"},{"content":"學習影片 單字 valuable adj. 值錢的 poverty n. 貧窮 generous adj. 慷慨的 extreme adj. 極端的 donation n. 捐贈 charity n. 慈善事業 common adj. 常見的 ad n. 廣告 plenty pron. 大量 local adj. 當地的 文法 名詞子句 (Noun Clause)\nA noun clause acts as a noun and can be used as the subject, object, or complement. It starts with words like that, if, whether, where, when, how, and so on. For example, in this video, the speaker said, \u0026ldquo;I don\u0026rsquo;t know how to talk to kids.\u0026rdquo; In this sentence, \u0026ldquo;how to talk to kids\u0026rdquo; is a noun clause. Though it starts with the question word \u0026ldquo;how\u0026rdquo;, the speaker wasn’t trying to ask a question. Let’s look at another example sentence: \u0026ldquo;What it (the company) does is actually put people who are creating shoes right out of business.\u0026rdquo; Here, \u0026ldquo;what it does\u0026rdquo; is also a noun clause, and it is the subject of the whole sentence.\n「名詞子句」是指能扮演名詞角色的子句，可以做為主詞、補語、受詞使用，由 that, if, whether, where, when, how 等等開頭，比如影片中講者說 I don\u0026rsquo;t know how to talk to kids.「我不知道怎麼跟小孩講話。」此句 how to talk to kids 為名詞子句，雖然以疑問詞 how 開頭，講者並不是在問問題。 我們來看另一個例子：What it (the company) does is actually put people who are creating shoes right out of business.「這間公司做的其實是讓本地的製鞋商直接失業。」這裡 what it does 也是名詞子句，作為整句主詞。\n### 例句 - I know what you did last summer. 我知道你去年夏天做了什麼事。 - I\u0026#39;m not sure if she will be home by six. 我不確定她六點前會不會回家。 - The teacher wanted us to tell her who broke her vase. 老師要我們告訴她是誰打破花瓶的。 ","date":"2023-11-06T11:29:49+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson013/media/Pasted-image-20231106114121_hu979ca755762437f85987c879560818f3_692373_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson013/","title":"Lesson013 - 為什麼「買一捐一」的 Toms 鞋概念幫不了任何人？"},{"content":"學習影片 單字 remedy n. 補救 (辦法)，糾正 (辦法) dizziness n. 眩暈 supplement v. 補充 affordable adj. 負擔得起的 accessible adj. 易取得的 hesitant adj. 猶豫的 belief n. 信仰；信念 land v. 得到、獲得 finding n. 調查結果 exceed v. 超越 文法 名詞子句 (Noun Clause)\nA noun clause is a clause that plays the role of a noun. Lots of noun clauses start with \u0026ldquo;that,\u0026rdquo; \u0026ldquo;how,\u0026rdquo; or a \u0026ldquo;wh\u0026rdquo;-word (i.e., \u0026ldquo;what,\u0026rdquo; \u0026ldquo;who,\u0026rdquo; \u0026ldquo;which,\u0026rdquo; \u0026ldquo;when,\u0026rdquo; \u0026ldquo;where,\u0026rdquo; or \u0026ldquo;why\u0026rdquo;). A noun clause can act as the subject of a sentence. It can also act as the direct object of a verb. Take this lesson\u0026rsquo;s sentence as an example, \u0026ldquo;I think I was a little bit shocked when I found out how positive the findings were.\u0026rdquo; In this sentence, \u0026ldquo;how positive the findings were.\u0026rdquo; is a noun clause. Another example is, \u0026ldquo;It has far exceeded what we had expected.\u0026rdquo; In this sentence, \u0026ldquo;what we had expected\u0026rdquo; is a noun clause. To determine whether a clause is a noun clause, try replacing it with other pronouns such as \u0026ldquo;one,\u0026rdquo; \u0026ldquo;that,\u0026rdquo; \u0026ldquo;it,\u0026rdquo; or \u0026ldquo;something.\u0026rdquo; If we can successfully replace the clause with a pronoun, the clause is a noun clause. For example, \u0026ldquo;I like that you come to visit me every now and then.\u0026rdquo; In this sentence, \u0026ldquo;that you come to visit me every now and then\u0026rdquo; can be replaced with \u0026ldquo;it/that,\u0026rdquo; such as \u0026ldquo;I like it./I like that.\u0026rdquo; Therefore we can know that this clause is a noun clause.\n所謂的名詞子句，就是把一個句子當作名詞來用。很多名詞子句都會以 that、 how 或疑問詞（例如 what/who/which/when/where/why）開頭。名詞子句可以作為句子的主詞，也跟其它名詞一樣，名詞子句可以作為受詞，例如本課例句：I think I was a little bit shocked when I found out how positive the findings were.（當我發現效果非常正面時，我覺得我有點訝異。）在這個句子中 how positive the findings were 就是一個名詞子句。另一句例句 It has far exceeded what we had expected.（這遠遠超乎了我們原本的預期。）中的 what we had expected. 為名詞子句。 另外可以注意，驗證某個子句是名詞子句最好的辦法，就是拿一個代名詞 one/that/it/something 等來取代，假如取代了而不會影響句構本身的正確性，那就可以說這個子句是名詞子句。例如：I like that you come to visit me every now and then. 其中 that you come to visit me every now and then. 可以被 it/that 所取代變為 I like it./ I like that.，而句子結構文法上也沒有問題，這時我們就可以確定，that you come visit me every now and then. 是名詞子句唷！\n### 例句 - I know that my favorite team won the game. 我知道我的支持的那隊贏了比賽。 - I know why you left the school. 我知道你為什麼離開了學校。 - I want to know whether you like it or not. 我想知道你是否喜歡它。 ","date":"2023-11-06T11:25:55+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson012/media/Pasted-image-20231106114029_hu5b3a11386cb63b8460bc9e6c0ab75c09_1139970_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson012/","title":"Lesson012 - 拯救貧血的村落，全靠一隻幸運小魚"},{"content":"報錯畫面 突然開始，佈屬皆會報錯 報錯原因 打API查詢佈屬ID # \u0026lt;TOKEN\u0026gt; 更換您的GITHUB TOKEN # grep id 更換成您報錯頁面提示的ID chenqingze@chenqingze-MBP ~ % curl -L \\ -H \u0026#34;Accept: application/vnd.github+json\u0026#34; \\ -H \u0026#34;Authorization: Bearer \u0026lt;TOKEN\u0026gt;\u0026#34;\\ -H \u0026#34;X-GitHub-Api-Version: 2022-11-28\u0026#34; \\ https://api.github.com/repos/chingtsechen/chingtsechen.github.io/deployments | grep -i -B 40 f011f3e1c2edc5fa42d95fe890265994405a045a 就可以看到，佈屬IP\n\u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/repos/chingtsechen/chingtsechen.github.io/deployments/1156464224\u0026#34;, \u0026#34;id\u0026#34;: 1156464224, 先將佈屬ID狀態設定為inactive 如果直接執行刪除，會出現以下報錯\nchenqingze@chenqingze-MBP ~ % curl -L \\ -X DELETE \\ -H \u0026#34;Accept: application/vnd.github+json\u0026#34; \\ -H \u0026#34;Authorization: Bearer \u0026lt;TOKEN\u0026gt;\u0026#34;\\ -H \u0026#34;X-GitHub-Api-Version: 2022-11-28\u0026#34; \\ https://api.github.com/repos/chingtsechen/chingtsechen.github.io/deployments/1156464224 { \u0026#34;message\u0026#34;: \u0026#34;Validation Failed\u0026#34;, \u0026#34;errors\u0026#34;: [ \u0026#34;We cannot delete an active deployment unless it is the only deployment in a given environment.\u0026#34; ], \u0026#34;documentation_url\u0026#34;: \u0026#34;https://docs.github.com/rest/deployments/deployments#delete-a-deployment\u0026#34; } 所以需要先將佈屬ID狀態設定為inactive\ncurl https://api.github.com/repos/chingtsechen/chingtsechen.github.io/deployments/1156464224/statuses -X POST -d \u0026#39;{\u0026#34;state\u0026#34;:\u0026#34;inactive\u0026#34;}\u0026#39; -H \u0026#39;accept: application/vnd.github.ant-man-preview+json\u0026#39; -H \u0026#34;authorization: token \u0026lt;TOKEN\u0026gt;\u0026#34; 用API刪除佈屬ID curl -L \\ -X DELETE \\ -H \u0026#34;Accept: application/vnd.github+json\u0026#34; \\ -H \u0026#34;Authorization: Bearer \u0026lt;TOKEN\u0026gt;\u0026#34;\\ -H \u0026#34;X-GitHub-Api-Version: 2022-11-28\u0026#34; \\ https://api.github.com/repos/chingtsechen/chingtsechen.github.io/deployments/1156464224 可以成功繼續佈屬 可以看到，佈屬成功了 ","date":"2023-11-05T16:32:52+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/github-pages-deploy-error/","title":"Github-Pages deploy error 佈屬失敗解決(報錯原因Deployment request failed for xxx due to in progress，Please cancel xxxx first or wait for it to complete)"},{"content":"垃圾回收機制 \u0026#34;\u0026#34;\u0026#34; 有一些語言 記憶體空間的申請和釋放都需要程式設計師自己寫程式碼才可以完成 但是python卻不需要 通過垃圾回收機制自動管理 \u0026#34;\u0026#34;\u0026#34; 1.引用計數 name = \u0026#39;jimmy\u0026#39; 數據值jimmy身上的引用計數為1 name1 = name 數據值jimmy身上的引用計數加一 為2 del name1 數據值jimmy身上的引用計數減一 為1 當數據值身上的引用計數為0的時候 就會被垃圾回收機制當做垃圾回收掉 當數據值身上的引用計數不為0的時候 永遠不會被垃圾回收機制回收 2.標記清除 主要針對循環引用問題 l1 = [11, 22] # 引用計數為1 l2 = [33, 44] # 引用計數為1 l1.append(l2) # l1 = [11, 22, l2列表] 引用計數為2 l2.append(l1) # l2 = [33, 44, l1列表] 引用計數為2 del l1 # 斷開變數名l1與列表的綁定關係 引用計數為1 del l2 # 斷開變數名l2與列表的綁定關係 引用計數為1 當記憶體占用達到臨界值的時候 程序會自動停止 然後掃描程序中所有的數據 並給只產生循環引用的數據打上標記 之後一次性清除 3.分代回收 垃圾回收機制的頻繁運行也會損耗各項資源 新生代、青春代、老年代(越往下檢測頻率越低) 2.標記清除\n圖解： 3.分代回收\n圖解： 流程控制理論 流程控制\u0026gt;\u0026gt;\u0026gt;:控制事物的執行流程 事物執行流程總共可以分為三種 1.順序結構 從上往下依次執行 之前所編寫的代碼都屬於該結構 2.分支結構 事物的執行會根據條件的不同做出不同的執行策略 3.循環結構 事物的執行會根據某個條件出現重複 ps:在代碼的世界裡 很多時候可能會出現三者混合 提示:作為小白 在學習流程控制的時候 建議做到代碼和圖形的結合 圖解： 流程控制必備知識 1.python中使用代碼的縮進來表示代碼的從屬關係 從屬關係:縮進的代碼(子代碼)是否執行取決於上面沒有縮進的 2.並不是所有的代碼都可以擁有縮進的代碼(子代碼) if關鍵字 3.如果有多行子代碼屬於同一個父代碼 那麼這些子代碼需要保證相同的縮進量 4.python中針對縮進量沒有具體的要求 但是推薦使用四個空格(windows中tab鍵) 5.當某一行程式碼需要編寫子代碼的時候 那麼這一行程式碼的結尾肯定需要冒號 6.相同縮進量的代碼彼此之間平起平坐 按照順序結構依次執行 分支結構 1.單if分支結構 if 條件: 條件成立之後才會執行的代碼塊 ps:單if可以借助於流程圖理解 username = input(\u0026#39;username\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) if username == \u0026#39;jimmy\u0026#39;: print(\u0026#39;老師好\u0026#39;) 2.if...else...分支結構 if 條件: 條件成立之後執行的子代碼 else: 條件不成立執行的子代碼 username = input(\u0026#39;username\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) if username == \u0026#39;jimmy\u0026#39;: print(\u0026#39;老師好\u0026#39;) else: print(\u0026#39;你不是jimmy\u0026#39;) 3.if...elif...else分支結構 if 條件1: 條件1成立之後執行的子代碼 elif 條件2: 條件1不成立 條件2成立執行的子代碼 elif 條件3: 條件1和2都不成立 條件3成立執行的子代碼 else: 上述條件都不成立 執行的子代碼 ps:中間的elif可以寫多個、上述子代碼永遠只會走一個 score = input(\u0026#39;請輸入學生成績\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) score = int(score) # 將字串的整數轉換成整型的整數 if score \u0026gt;= 90: print(\u0026#39;優秀\u0026#39;) elif score \u0026gt;= 80: print(\u0026#39;良好\u0026#39;) elif score \u0026gt;= 70: print(\u0026#39;一般\u0026#39;) elif score \u0026gt;= 60: print(\u0026#39;及格\u0026#39;) else: print(\u0026#39;重修\u0026#39;) 4.if的嵌套使用(有點難) age = 28 height = 170 weight = 110 is_beautiful = True is_success = False username = \u0026#39;tony\u0026#39; if username == \u0026#39;tony\u0026#39;: print(\u0026#39;tony發現目標\u0026#39;) if age \u0026lt; 30 and height \u0026gt; 160 and weight \u0026lt; 150 and is_beautiful: print(\u0026#39;大女孩 手機掏出來 讓我加微信\u0026#39;) if is_success: print(\u0026#39;吃飯 看電影 天黑了...\u0026#39;) else: print(\u0026#39;去你妹的 流氓!!!\u0026#39;) else: print(\u0026#39;不好意思 認錯人了\u0026#39;) else: print(\u0026#39;不是tony做不出來這件事\u0026#39;) 1.單if分支結構\nif的嵌套使用 2.if...else...分支結構\n3.if...elif...else分支結構\n圖解： 問題：字串判斷大小 4.if的嵌套使用(有點難)\n","date":"2023-11-05T14:44:37+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day05/","title":"Day05 - 垃圾回收機制、流程控制理論、流程控制必備知識、分支結構"},{"content":"\n我的感想與收穫 以下是我從書中提取出來，對我來說，是不錯的句子。 出自《蛤蟆先生去看心理師（暢銷300萬冊！英國心理諮商經典）》https://readmoo.com/book/210214965000101\nChapter 5 成長的寓言 人們會進入兒童狀態，他們的感受與行為都與小時候的自己如出一轍，這與實際年齡無關。\n多數父母都是盡最大的努力來養育孩子，很少有父母要故意傷害自己的孩子。但父母也是人，不可避免地會將觀念與行為傳遞給下一代，就像他們必然會將自己的基因傳給子女一樣。所以子女要學會的是，如何因應與避免受到不好的影響。\n蛤蟆，了解你的童年就是了解你自己的關鍵線索，這將貫穿我們諮商的整個過程。就如同佛洛伊德所說：『凡是本我所在之處，自我必相隨。』\n這個故事是關於嬰兒時期的寓言。從呱呱落地開始，我們的生命裡只和另外兩個人在一起，有時甚至只有一個人。他們比我們巨大很多，我們完全仰賴著這兩個人。既然無處逃脫，唯一能做的就是適應他們每一次的喜怒無常。我畫個簡單的圖來說明。」蒼鷺說完起身。\nChapter 9 秘密協議 「就是『可憐的我』（Poor Little Old Me），這遊戲你每次都贏，或者也可以說是輸，取決於你從哪個角度去看。」\n「就是達成一種祕密協議。我所謂的『共謀』是指你偷偷地或無意識地配合對方，來造成自己的不快樂。這就是在玩心理遊戲：輸家才是贏家。」蒼鷺的話聽起來有點難以理解。\n「這聽起來也許有些殘酷，蛤蟆，能幫助你的人是你自己，也只有你自己。有很多問題你需要對自己提問。舉例來說，你能停止審判自己嗎？你能對自己好一點嗎？也許最重要的問題是，你能開始愛自己嗎？」\nChapter 11 蛤蟆先生的選擇 我們稱為成人狀態，加上它，這樣便構成完整的三種自我狀態：父母、成人、兒童，這三種狀態構成你的人格結構。我們可以簡單地畫出來。\n「成人自我狀態（Adult Ego State）指我們能以理性、不情緒化的方式，來處理當下發生的真實狀況。」蒼鷺回答。\n唯有在成人自我狀態下，我們才能對自己有新的了解。\nChapter 13 心裡遊戲 親愛的蛤蟆，重點就在於這些是攸關一生的心理地位（life positions）。一旦我們在童年決定了何種態度，就會一輩子始終堅持自己的選擇。這些態度和觀點，變成我們存在的根本基礎。之後，我們建構的世界都是在印證與支持這些信念與預期。換句話說，我們將自己的人生變成自我實現的預言。\nChapter 14 贏了遊戲輸了自己 我不好，你好 (悲傷型兒童狀態)\n這代表一種人的行為態度，這種人對自己評價較低，認為別人都比自己好。\n遊戲1：「我是倒霉鬼」\n遊戲2：「PLOM 可憐的我」\n遊戲3：「無論我做什麼都要愛我」\n我好，你不好 (挑剔型父母狀態)\n這種人必然自認比別人好，我想他們也會玩遊戲來強化這一點\n因為憤怒是抵抗沮喪的絕佳防衛。憤怒的人從來不會覺得愧疚，因為他們總是怪罪別人。\n遊戲1：「NIGYYSOB 我逮到你了，你這個壞蛋」\n遊戲2：「你為什麼總是讓我失望？」\nChapter 15 最後一次按門鈴 我好，你也好\n心理地位是動態而非靜止的狀態\n當你認為自己好，也相信別人好，這需要透過行為與態度不斷地對自己與別人表現出這一點，而且這當然也無法保護你完全避開命運無情的矢石\n非常接近人道主義者（Humanist）的信念——相信自己，也相信別人，而不一定相信神或超自然的力量。\n現在我明白了，你一直引導我自己回答自己的問題，讓我進入『成人狀態』\nEQ還與了解別人有關。高EQ的人能了解別人的感受，這種能力稱為『同理心』。但EQ帶來的最大能力是能夠了解與處理別人的情緒，因而能與別人建立良好的關係\n","date":"2023-11-01T21:09:57+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/counselling-for-toads-summary/media/counselling-for-toads_hu01d889be316ca895dc147d9b0ca8f455_75784_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/counselling-for-toads-summary/","title":"蛤蟆先生去看心理師 - Summary - 我的感想與收穫"},{"content":"\n","date":"2023-10-31T12:18:36+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/exercise-jogging-202310/","title":"2023/10 慢跑(100.8公里)"},{"content":"大會議程 10/25 官方網站連結： https://k8s.ithome.com.tw/2023/agenda#day01\n10/26 官方網站連結： https://k8s.ithome.com.tw/2023/agenda#day02\n我拍的照片 我參加的議程 10/25 (ㄧ)大規模 Kubernetes 運維甘苦談：關於自建、雲端和 CI/CD 的那些大小事 本議程將分享趨勢科技實際進行大規模 Kubernetes 運維的經驗與踩過的雷。\n透過最初自建的背景介紹，經歷雲端半託管時期，一路到現在全雲端託管的 Kubernetes 叢集部署的策略演進（以 AWS EKS 為例），分享CI/CD的最佳實踐經驗，並帶各位了解大規模維運會碰到的挑戰，包含如何進行有效的資源管理與擴展、故障排除及監控等。\n希望這些辛酸血淚史能對有志管理大型 Kubernetes cluster的同路人有所幫助。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2250\n(二)融合 AI 技術，加速應用開發、交付與優化 應用現代化和多雲是數位化轉型的核心。研究顯示，超過 70% 的企業正在開發全新的雲原生應用，而專為多雲設計的現代化應用在企業中的使用率現已超過傳統應用 ; 因此，應用開發的敏捷性和上市速度對於企業能否在競爭中取得成功至關重要。本議程探討如何運用 VMware Tanzu 平台加速應用開發、交付和提供智能管理，藉以提升業務敏捷性與整合多雲應用。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2317\n(三)Google 重塑新一代 Kubernetes Ops 與 AI 技術的致勝關鍵 歡迎參加本議程活動，了解 Google 新一代 Kubernetes Ops 的最新消息與致勝關鍵，包括從容器至 AI 等主要議題。不論是透過雲端服務打造自己的平台，抑或是開發與管理應用程式，您將可透過本議程了解如何在每日 IT 維運任務中提升效率、可靠性及資安條件。您亦可了解業界頂尖公司如何運用具高度擴展性且自動化的 Kubernetes，迅速打造專屬自己的雲端致勝模式，並借助 AI 的力量邁向成功之路。\nJoin this session to learn the latest and best from Google for Next Genereation Kubernetes Ops – from containers to AI. Whether you’re building your own platform or developing and managing applications using cloud services, learn how to improve efficiency, reliability, and security in your IT operations. You’ll also discover how leading companies use the most scalable and automated Kubernetes to build fast and harness AI in their IT operations.\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2318\n(四)How to link K8s to Business 讓主管們都聽得懂 探討及分享雲架構平台跟業務的關係，從 CIO 角度看技術轉型。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2319\n(五)從數據看台灣企業雲原生採用大趨勢 即將揭曉，敬請期待\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2356\n(六)Resource as Code for Kubernetes: Stop kubectl apply Infrastrure as Code (IaC) 與 PaC，在萬物都該 as Code 得時代，你還在不斷的 kubectl apply 嗎？\n手動 apply 的痛點：\n人就是會忘：是誰 apply 這個在 K8s 上的？是誰上次漏 apply 所以壞了？ 人就是會寫錯：能否 apply 管理大量的 label, taint, annotation 安全：apply 變更內容是否有經過資訊安全的 review 多環境管理：多座 K8s 要如何管理 K8s resource 當服務的 app code base 都已經用 chart 打包，使用 vcs 管理後，為何依賴的 k8s resource (namespace, secret, label, crd, \u0026hellip;) 不需要推上 vcs 管理的？\n本次演講集合幾個管理 K8s 的範例，將 K8s resource 以 code 管理，推上 vcs，並使用 argoCD, secret operator, \u0026hellip; 等工具進行管理，來讓避免低級的人工操作錯誤，降低團隊整體失誤率，並降低 K8s admin 管理的成本，提高管理效率\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2331\n(七)Kubernetes 資安攻防 - 採用機密運算與零信任策略，守護您的應用 我們將探討如何使用機密運算和零信任方法在 Kubernetes 環境中保護應用程式和數據。Kubernetes 已經成為現代各大企業軟體開發和運營的必然趨勢，然而，與之相關的安全挑戰也成為現在大家關注的重點。在這個議程中，我們將深入探討您日常 Kubernetes 運營中可能面臨的潛在風險和安全挑戰。我們將透過實際案例和最佳實踐，與您分享如何有效應對這些挑戰，並強調採取相關進階措施的必要性。\n透過參加此議程，您將有機會深入了解如何運用機密運算和基於零信任的安全方法來保護您的 Kubernetes 環境。無論您是一名 Kubernetes 初學者還是資深專家，這個議程都將為您提供相關見解，以確保您的應用程式和數據得到最高水平的保護。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2352\n(八)新世代的 Service Mesh - Istio Ambient Mesh 在 Kubernetes 平台上開發應用程式時, 通常很容易會討論到是否要使用 Service Mesh。而 Service Mesh 中的代表性解決方案 Istio, 更是目前廣為採用的 Service Mesh 之一。Istio 能夠對服務的溝通，管理，乃至於監控, 提供一個強大的平台。但相對的，使用 Istio 的所需要付出的代價也相當不小，往往令許多人有心採用的人往而卻步。\n有鑑於此，Istio 在 2022 年的九月，發表了 Ambient Mesh, 一個全新的 Istio Data Plane Mode，旨在簡化操作，拓展應用成式兼容性，降低基礎架構所需成本。 Ambient Mesh 讓使用者不再需要使用之前的 Sidecar 模式，將 Data Plane 無縫地整合進 Kubernetes 基礎架構，同時還能保有 Istio 既有的零信任安全、觀測性和流量治理等核心特性。\n在 2023 三月, Ambient Mesh 進入了 Istio 開源專案的 main branch, 預計在 2023 年底會 production ready。這正是一個絕佳的時刻，讓大家能了解 Ambient Mesh 所帶來的新架構的優勢, 讓有心想要導入 Istio 的人能夠重新評估 Ambient Mesh 的可能性，對於 Sidecar \u0026amp; Sidecarless 的 Istio 應該如何選擇使用，進行一個深入淺出的探討。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2326\n(九)通往 Cloud Native 的神奇之旅：自製 Kubernetes 工具大揭秘 透過這次的分享，我們將深入探討 LINE Pay Taiwan 是如何成功從傳統的 VM 基礎架構轉向高效的 Cluster-based Infrastructure 的過程。在這趟旅程中，我們將揭示自行開發的工具如何在這轉型過程中發揮關鍵作用，並怎樣迅速引入 Kubernetes 技術，實現卓越的效益與競爭優勢。\n議程重點：\nWhy: 為何選擇 Cloud Native？\n探索導入 Kubernetes 背後的動機，以及如何解決LINE Pay Taiwan所面臨的實際挑戰 How: 落實 Cloud Native 轉型的實踐之道\n在有限資源下，我們如何革新現有的 CI/CD 流程，同時保持合規性。 設計和改進 CI/CD 流程，以實現 Kubernetes 的順利導入。 介紹我們如何使用 GoLang 開發自有 CLI 工具，協助工程師快速融入 Cloud Native 生態系統 What: 享受 Cloud Native 帶來的好處\n發現我們自行開發的工具如何帶來的優勢。 洞察導入 Kubernetes 架構後，LINE Pay Taiwan的服務將獲得什麼樣的轉變 Which: 系統性調整和未來優化之路\n窺探在架構轉型後，我們經歷了哪些系統性調整 探討更多可持續優化的可能性 官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2353\n10/26 (一)Kubernetes APIs for the Future: Building Platforms and Managing Everything Kubernetes is a powerful platform for building platforms. With CustomResourceDefinition (CRD), you can build the APIs you need to manage your applications and infrastructure. Kubernetes is becoming universal for everything, and you can use Kubernetes APIs to manage cloud resources, as well as applications and services.\nGitOps is a Git-based approach to managing infrastructure and applications. It removes toil and reduces the barrier for using Kubernetes, making it easier to be effective. With GitOps, you can build your platform using Kubernetes APIs easier, safer, and faster.\nThis keynote speech is for anyone who wants to learn more about how to use Kubernetes to build and manage platforms, applications, and infrastructure. Whether you are a beginner or an expert, you will learn something new.\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2336\n(二)打造雲原生世界的資安堡壘 成功的企業容器安全計劃必須要能從容器生命週期的建構、部署到運作的所有階段，以及底層的容器基礎架構中執行主要控制措施。\n不知從何著手嗎？本議程介紹 Red Hat 容器平台如何在雲原生世界提供完整的安全防護，為企業打造最堅實的現代化資安堡壘。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2337\n(三)幫服務建立觀測性，利用 ITSM 與自動化完成數位企業最後一哩路 企業熱衷於新技術導入，越來越多服務導入不同種新技術建立在不同的運作平台上，單純的服務監控已經不能滿足需求，需要建立觀測性(Observability)來協助我們更了解服務的運作狀態，尤其當容器化的世代來臨，更複雜的 IT 環境需要更好的工具協助我們觀測且協作，透過自動化工具，協助企業動態且快速建立服務所需要的資源；BMC 將分享關於如何建立服務觀測性，透過 AI/ML 工具有效將服務與 IT 整合起來，起到協同運作、共做共榮的使用情境，加速數位企業轉型，達成目標。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2338\n(四)Feature Toggle Makes Development more Efficient 在 Kubernetes 的部署中，經常會面臨一些挑戰。例如，新功能的部署可能會導致系統穩定性下降，甚至可能需要回朔上次部署，從而提高部署風險。此外，每次部署都需要全面的測試，這不僅增加了部署和測試的複雜性，也消耗了更多的時間。這可能會對用戶的使用體驗產生影響。透過這次的演講，我們將探討如何透過 Feature Toggle 來解決這些問題，並提升我們的部署與開發的效率和靈活性。\n因此，我們的議程將會包含以下的內容：\nFeature Toggle 的簡介： 我們將介紹什麼是 Feature Toggle，以及它的基本概念和工作原理。\nFeature Toggle 的應用場景： 我們將分享 Feature Toggle 的實際應用場景，包括 AB testing, Canary Release 等。\nLINE台灣在推動的工法： 我們將分享 LINE 台灣在推動 Feature Toggle 的經驗和工法。\n從 Feature Toggle 到 Kubernetes 的影響： 我們將探討 Feature Toggle 如何影響到開發流程和 CI/CD 在 Kubernetes 上的部署，並分享如何解決上述的痛點。\n如何持續地縮短 Release 週期與增進開發效率： 我們將分享如何透過 Feature Toggle 持續地縮短 Release 週期和提高開發效率。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2339\n(五)On-premise Workload 遷移 Kubernetes 心路歷程 往雲端 Kubernetes 遷移 workload 的過程，服務會同時並行於 on-premise 和雲端一段混合的過程，KKBOX 擁有超過千萬會員，首先面對的挑戰會是，要如何最小化遷移對使用者的影響，遷移邁入後期後，則需要持續優化營運成本。此次分享會對上述議題，分享 KKBOX 如何解決這些技術上的難題。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2355\n(六)如何在銀行內部用 K8s 打造無伺服器批次運算平台 過去企業需要考量著基礎設施的管理議題，但隨著近幾年無伺服器概念的推出，徹底的改變既有的思路，讓企業開發者能夠更專注在開發應用，而並非架構上，同時又能有效節省冗餘硬體資源並提升整體效益等優點。\n隨著 Google 將 Knative 專案貢獻給雲端原生運算基金會 (CNCF)，迅速帶起各大企業使用Serverless的浪潮，而玉山也乘著這波概念的浪潮，打造獨有的無伺服器批次運算平台，來強化玉山批次運行架構，以達對硬體資源使用、開發、維運整體效益整體的提升。\n本次演講會分享所謂 Serverless 概念及 Knative 的運作原理，並說明玉山銀行如何結合 Serverless，改造批次運行架構，提高硬體使用集縮比，以降低硬體資源成本。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2347\n(七)聯邦學習在 K8s 上的實現與應用 Machine learning 的模型建立時需要足夠的資料量與足夠的解釋力特徵，如欲建立機器學習模型時最重要的的任務即是蒐集足夠的資料量與特徵，但往往在企業上同一客戶的資料可能會分散在不同的子公司上，或是想統整運用不同子公司各自擁有的客戶群資料以提升模型準確性，基於隱私條款的限制，子公司間是無法直接進行資料交換來做使用。在資料量與特徵不足的情況下機器學習模型的整體效果就較難做進一步的提升。\n國泰資料科學團隊以 KubeFate 聯邦學習框架的基礎下開發名為 CaFe 的聯邦學習框架，使用 Helm 建立高效的聯邦學習架構，開發 Operator 用於同步不同 Namespaces 中的 ConfigMap 資料，藉由 webhook 實現自動掛載 ConfigMap 到相應的應用程式，使整個建置過程更加自動化和高效。子公司的使用者能在不交換實體資料的情況下於各自 K8S 環境共同訓練出效果比單一方自行訓練的模型效果更佳，進而提升整體模型效度。我們將與大家分享以下內容：\n聯邦學習簡介 聯邦學習框架 KubeFate 使用評估 CaFe 部署於 OKD 上與內部資料科學平台的結合 POC 測試案 官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2350\n(八)Cloud-native messaging service by NATS NATS 是一個 open source pub/sub messaging system，於 2018 年成為 CNCF 的 incubating project 後，歷經快速的發展，2019 年 NATS 2.0 增加了 supercluster、 leafnode 和 decentralized security 功能，2021 年 NATS2.2 將新的分散式儲存系統 JetStream 正式 GA 整合進 NATS，直到最近的 NATS2.9 持續提升穩定性，此議程想讓觀眾了解 NATS 的功能、最新的 NATS 發展與佈署 NATS 在 K8s 上維運的建議。\nNATS 的基本介紹，什麼是 NATS Core 和 JetStream，以 demo 形式讓觀眾快速了解 NATS open source project 的發展現況 NATS cluster 於 K8s 的佈署、維運、如何持續擴充 導入 NATS 的建議流程 目前有哪些 open source project 支援 NATS JetStream 官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2325\n(九)Adopt Kubernetes for Infrastructure as Code (打造以 K8S 為底層的 IaC 系統） K8S 從開源以來，就以宣告式的方式，提供標準資源的自癒與擴充能力，在 1.13 後提供的客制資源 (CRD) 管理的擴充能力，延伸了 K8S 的宣告式平台。\nGoogle 在 GCP 上首先提出了 KCC (Kubernetes Config Connector) 的實作，通過 GKE 管理 GCP 各項 IT 資源的生命週期，Google 也進一步與開源社群 (Crossplane) 合作，將 KCC 的概念延伸到其他的基礎架構提供者中，打造新的 IaC 生命週期管理機制：Cloud Resource Accelerator。\n這個機制，通過 YAML 物件的解耦，有效的限制開發者與管理者對 IaC 的控制能力，同時通過 K8S 的宣告機制，讓部署出來的資源能受到 K8S 的完整保護，這些強化都有效的彌補現有 IaC CLI 的不足。\n官方網站連結： https://k8s.ithome.com.tw/2023/session-page/2322\n心得與收穫 由於去年參加過，今年參加Summit，我在議題上的選擇，著重於就比較往能協助公司導入Kubernetes的議題去參加，因為目前公司也是處於此階段，例如分享導入經驗與甘苦談的議題、導入有效管理工具使用的議題、最新Kubernetes技術分享的議題，像是一些公司新產品發表那些議題，我就沒去參加。\n至於印象比較深刻的議題如下：\n是Google分享了他們目前看到的趨勢，預計到2027，企業將正式生產環境導入容器或Kubernetes會高達90%，也就是說，那時候，會將近有90%的企業，會使用容器或Kubernetes當作直接對外服務的主要環境。\n也是Google分享了istio在網路流量治理的變革，以前，要使用istio進行Kubernetes流量治理與管理，是採用sidecar的方式，也就是說，在Kubernetes平台中，每起一個Pod(服務)，都得伴隨著一個邊車容器Sidecar，每個Pod(服務)流量進出，都得經過Sidecar，對於整個Kubernetes平台，侵入性非常高，等於現在如果有100個Pod(服務)，就得起100個Sidecar容器，對於Kubernetes平台的資源消耗也非常高，變革後，採用Istio Ambient Mesh，不用每個Pod都得起一個Sidecar容器，現在是改在每個Node節點部屬流量治理，容器改連至那裡，進行流量治理與管理，大大了減少整體Kubernetes平台性能與資源消耗，並能針對L4層和L7層，分別進行流量管理與治理。\n兩天下來，幾乎8成的公司，都是採用GitOps的方式，進行Kubernetes的業務部屬和管理，看到最多的方式，就是採用Argocd開源專案。\n再來是中華開發金分享的，如何讓主管們都聽的懂Kubernetes，當然關係到此專案最終能否執行下去，一定還是成本考量，如果達不到省錢，要老闆掏錢出來，難上加難。基於這個點往前探討，如何讓業務和PM單位聽的懂，需將系統與業務上的關連和影響點出來，讓他們知道，有什麼益處，能幫助到他們什麼。再來如何讓資訊單位聽的懂，需將現況系統遇到的瓶頸與導入後的關連和影響點出來，並將系統高可用、高彈性、穩定\u0026hellip;等益處突顯出來。\n再來是Line Pay，太讓我驚訝了，還沒有用到GitOps方式，他們在Kubernetes DevOps這方面，還是用傳統的方式，寫一個模版，透過linux指令sed，去替換模版裡面的變數，去部屬服務，當然講者的說法是，他們還是求穩定，所以才採取這個方式，當然未來也不排除會導入Argocd這個專案，讓他們管理起來更有效率。\n再來是Suse分享的資安攻防，Suse Rancher NeuVector這項開源產品，我已經聽過第二次了，非常好的產品，能跟Rancher平台直接做結合，部屬起來，非常方便，功能也非常強大，鏡像掃描、異常流量阻斷\u0026hellip;等。\n再來是玉山銀行分享的如何在內部用 K8s 打造無伺服器批次運算平台，由於玉山銀行內部，有專門跑排程的主機，好幾百台，佔用了非常多伺服器資源，他們將跑排程的主機改用Kubernetes裡面的一個Pod功能叫Job，需要跑排程時，Kubernetes會起一個一次性任務的Pod，執行完任務，Pod就會自動刪除，讓他們大大節省了伺服器資源的使用。\n","date":"2023-10-29T18:37:28+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-summit-2023/media/Pasted-image-20231029184656_hub7b044231ef4aeecfc91c4975bdc3f98_300198_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-summit-2023/","title":"Kubernetes Summit 2023"},{"content":"學習影片 單字 hesitant adj.猶豫的 pronounce v.發音；讀音 sealed adj.密封的 chew v.咀嚼 taro n.芋頭 flavor n.（食物或飲料的）風味；（某種）味道 honeydew n.蜜瓜 sour adj.酸的 powerful adj.強勁的 swallow v.吞嚥 文法 間接問句 (Indirect Questions)\n所謂間接問句，就是將一個問題嵌入一個句子之中，形成直述句。 例如影片中：I don\u0026rsquo;t know how I feel about chewing these weird gummy things. （我不知道我在咀嚼這些奇怪的、像軟糖的東西時有什麼感覺。） 這句就是把「我在咀嚼這些奇怪的、像軟糖的東西時有什麼感覺？」這個問句，嵌入另一個句子成為談話主題。因此，整個句子便不再是詢問答案的問句，而是陳述事實和感受的直述句。 倘若把此句還原成兩句，概念上是： 1. How do I feel about chewing these weird gummy things? 2. I don’t know the answer to the question. 又或是另一句：I don\u0026rsquo;t know whether to swallow them, or just like, let them hang out in my mouth. （我不知道應該要把它們吞下去，還是就讓它們在嘴巴裡。） 其中 “whether” 代表 「是否」之意，也可以用 “if” 來表達相同的概念。 倘若把此句還原成兩句，概念上是： 1. Should I swallow them, or just like, let them hang out in my mouth? 2. I don’t know the answer to the question. ☆須注意，一般來說，問句的動詞或助動詞會在主詞之前。不過，在與其他句子合併改寫為間接問句後，主詞需要在動詞或助動詞之前。 例如：How do I feel about chewing these weird gummy things? 此時的問句，助動詞do在主詞 I之前。 I don\u0026rsquo;t know how I feel about chewing these weird gummy things. 形成間接問句之後，助動詞去掉後，主詞I 在動詞feel之前。\n### 例句 - I don’t know who the man is. 我不知道那個男人是誰。 - I wonder why she can finish her homework so quickly. 我在想為什麼她作業可以那麼快寫完。 - I’m not sure whether/if Tom ate my cake. 我不確定湯姆是否有吃我的蛋糕。 ","date":"2023-10-29T16:33:10+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson011/","title":"Lesson011 - 感受 Q 彈滋味！外國人第一次喝波霸奶茶"},{"content":"學習影片 單字 incident n. （不愉快或不尋常的）事件 inhabitant n. 居民 distraction n. 消遣 rubberneck v. 看熱鬧，管閒事 fragile adj. 脆弱的 fierce adj. 兇猛的 evoke v. 喚起 disaster n. 災難 priority n. 優先考慮的事 文法 被動語態 (The Passive Voice)\nCertain verbs related to \u0026ldquo;moods\u0026rdquo; or \u0026ldquo;emotions\u0026rdquo; often appear in the passive voice. Take the sentence \u0026ldquo;We\u0026rsquo;re fascinated by landslides\u0026rdquo; from the lesson, \u0026ldquo;-ed\u0026rdquo; is added to \u0026ldquo;fascinate\u0026rdquo; to express landslides fascinate us, ie, we are obsessed with landslides. Other verbs such as \u0026ldquo;expose\u0026rdquo;, \u0026ldquo;dress\u0026rdquo;, \u0026ldquo;locate\u0026rdquo;, \u0026ldquo;make of\u0026rdquo;, \u0026ldquo;dedicate\u0026rdquo; are also often in the passive voice.\n某些跟「情緒、情感」有關的動詞，較常以被動語態的形式出現，例如本課中的 \u0026ldquo;We\u0026rsquo;re fascinated by landslides\u0026rdquo; 就是將 \u0026ldquo;fascinate\u0026rdquo; 加上 \u0026ldquo;ed\u0026rdquo; 表示「山崩令我們著迷」，也就是「我們著迷於山崩」的意思。諸如 expose、dress、locate、make of、dedicate 等動詞，也時常會以被動方式出現。\n### 例句 - The school was founded by Mr. Flemix. 這間學校是由 Flemix 先生所創建的。 - This pair of earrings is made of gold. 這對耳環是由黃金所製成的。 - My apartment is rented by a young couple. 我的公寓被一對年輕情侶所租。 ","date":"2023-10-28T21:46:30+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson010/","title":"Lesson010 - 為什麼我們喜歡聽到慘劇的新聞"},{"content":"Go介紹 GOOGLE開發的\nPYTHON開發效率極高 C語言、C++極致運行性能\nGO開發效率與運行性能都能兼具\nGo語言的誕生 三位創作者： 中間：Rob Pike unix開發者 utf8開發者\n右邊：Ken Thompson B語言開發者\n左邊：Robert Griesemer\n三位本身都是用C++編程的\nGo語言的優勢 優勢總結：\n開發效率高、運行性能好(均衡) 高併發 GO出現在雙核處理器後面，之前的語言都是基於單核，所以GO才能立足於高併發的優勢\nGo語言的應用領域 區塊鏈：Web3.0去中心化，Go就是在其中的語言\nGO主要就是在\u0026quot;網路併發層\u0026quot;發光發熱\n使用GO的大型網路公司： 計算機硬體組成 CPU：有兩個部分，運算器、控制器\n編程語言介紹 什麼是編程語言 人與計算機溝通的語言\n編程語言的發展經歷：\n機器語言(指令系統) =\u0026gt; 匯編語言 =\u0026gt; 高級語言 (C、java、Go等)\n匯編語言：指令符號化010010010101 =\u0026gt; ADD\n高級語言：多條指令合成一條指令\n編譯型語言與解釋型語言 編譯型：C++、C\n解釋型：python、js\n編譯型： 開發一個軟體，透過軟體(編譯器)，將程式語言，轉成可執行的二進制文件(EX: .exe)，調CPU執行這些程式的效果。\n優點：可執行的二進制文件，後續可一直覆用 缺點：因為編譯是基於當下環境，產生可執行文件，跨平台性弱 解釋型： 逐行逐行執行，不會編譯成一個可執行文件\n優點：不生成執行文件，跨平台性就比較好 缺點：每次要看結果，都要重新翻譯執行 go環境安裝 官網： https://go.dev/dl/\nmac系統 這裡是顯示，我之前已經安裝過go了 全程下一步就可以 安裝成功，檢查\nchenqingze@chenqingze-MBP ~ % go version go version go1.21.1 darwin/arm64 chenqingze@chenqingze-MBP ~ % 環境變數\nchenqingze@chenqingze-MBP ~ % go env # go安裝的根目錄 GOROOT=\u0026#39;/usr/local/go\u0026#39; # go代碼放置處 GOPATH=\u0026#39;/Users/chenqingze/go\u0026#39; # go代理位置 GOPROXY=\u0026#39;https://proxy.golang.org,direct\u0026#39; GOROOT='/usr/local/go' # 放編譯器 go/bin # 放置依賴包 go/src GOPATH='/Users/chenqingze/go' 第一個go程序 先關閉MODULE 啟用 Go 模組系統。在這種模式下，Go 會忽略 GOPATH 環境變數和其他傳統 Go 程序搜索路徑，並且只在當前模組的 go.mod 文件中指定的模組路徑中查找包\nchenqingze@chenqingze-MBP ~ % go env -w \u0026#34;GO111MODULE=off\u0026#34; # 退出當前terminal再登入，查看環境變數 chenqingze@chenqingze-MBP ~ % go env GO111MODULE=\u0026#39;off\u0026#39; 最小寫程式單元，一定要創建目錄，再來寫代碼\nchenqingze@chenqingze-MBP ~ % cd /Users/chenqingze/Desktop/ chenqingze@chenqingze-MBP Desktop % mkdir hello chenqingze@chenqingze-MBP Desktop % cd hello chenqingze@chenqingze-MBP hello % ls -l total 8 -rw-r--r--@ 1 chenqingze staff 70 11 4 15:16 main.go main.go\npackage main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;hello jimmy\u0026#34;) } 直接執行編譯，並執行\nchenqingze@chenqingze-MBP hello % go run main.go hello jimmy 生成可執行文件 配置GOPATH，將編程代碼都放置此處\n/Users/chenqingze/goWork\n# 當前家目錄創建goWork目錄 chenqingze@chenqingze-MBP ~ % mkdir goWork chenqingze@chenqingze-MBP ~ % cd goWork chenqingze@chenqingze-MBP goWork % mkdir src # 配置環境變數 chenqingze@chenqingze-MBP ~ % vim ~/.zprofile export GOPATH=$HOME/goWork # 退出當前terminal再登入，查看環境變數 chenqingze@chenqingze-MBP ~ % go env GOPATH=\u0026#39;/Users/chenqingze/goWork\u0026#39; 先執行編譯產生可執行文件，再執行\nchenqingze@chenqingze-MBP ~ % cd Desktop/hello chenqingze@chenqingze-MBP hello % ls -l total 8 -rw-r--r--@ 1 chenqingze staff 70 11 4 15:16 main.go # 編譯產生可執行文件 chenqingze@chenqingze-MBP hello % go build chenqingze@chenqingze-MBP hello % ls -l total 3776 -rwxr-xr-x@ 1 chenqingze staff 1925602 11 4 16:02 hello -rw-r--r--@ 1 chenqingze staff 70 11 4 15:16 main.go # 執行 chenqingze@chenqingze-MBP hello % ./hello hello jimmy 如果改源碼，需再執行編譯產生可執行文件，新代碼結果才會呈現\n自定義執行文件檔名\nchenqingze@chenqingze-MBP hello % go build -o hi chenqingze@chenqingze-MBP hello % ls -l total 7544 -rwxr-xr-x@ 1 chenqingze staff 1925602 11 4 16:02 hello -rwxr-xr-x@ 1 chenqingze staff 1925602 11 4 16:06 hi -rw-r--r--@ 1 chenqingze staff 70 11 4 15:16 main.go chenqingze@chenqingze-MBP hello % ./hi hello jimmy 小結 go build [-o] 生成一個可執行文件 go run 編譯並執行 寫代碼流程，先創建文件夾，進入創建xxx.go程式，開始撰寫代碼 代碼解釋\n/* 主包 */ package main import \u0026#34;fmt\u0026#34; /* 主程序入口 */ func main(){ fmt.Println(\u0026#34;hello jimmy\u0026#34;) } IDE的安裝和使用 安裝Goland或Vscode\n幫助快速開發\nmac系統 Goland官網： https://www.jetbrains.com/go/download/#section=mac\n我選擇使用較舊的版本 第一次打開畫面，選擇New Project 目錄選擇 創建go程序 生成可執行文件 先關閉go module\nIDE直接執行go run 基礎語法 註釋 ","date":"2023-10-28T09:31:05+08:00","image":"https://blog.goldfishbrain-fighting.com/2023/golang-self-learning-basic-introduction-golang001/media/golang_hue0faa416238e806283a48c54bb016671_65332_120x120_fill_box_smart1_3.png","permalink":"https://blog.goldfishbrain-fighting.com/2023/golang-self-learning-basic-introduction-golang001/","title":"go介紹、安裝配置環境、寫第一個go程序、go基礎語法、變量、基本數據類型、運算符、輸入輸出函數"},{"content":"學習影片 單字 artificial adj. 人工的；仿造的 cashless adj. 不用現金的 recognition n. 辨識；識別 analyze v. 分析 location n. 位置 boost v. 改善；提高；增強 disciplined adj. 守紀律的 enthusiastic adj. 熱衷的 privacy n. 隱私 consent n. 同意；許可 文法 名詞子句 (Noun Clause)\n所謂名詞子句，就是在句子當中嵌入一個地位形同名詞的子句。這些子句之前通常會由「連接詞（whether, if）」、「疑問詞（who, why, where, how 等）」或「關係代名詞（that, which, whom, whatever 等）」引導，其後結構為直述句（也就是 S+V）。以本支影片所出現的句子舉例，So while students are solving math problems, a teacher can quickly find out who\u0026rsquo;s paying attention and who\u0026rsquo;s not. 名詞子句便是who’s paying attention and who’s not，指稱「有專心和沒有專心的（學生）」。或是 We were curious if the headbands could actually measure concentration. 就是用 if（是否）帶出「這些頭帶是不是真的可以測量專注程度」這件事，此時 the headbands could actually measure concentration 既是有主詞（the headbands）有動詞（could (actually) measure）的子句，本身也是一個名詞。\n所謂名詞子句，就是在句子當中嵌入一個地位形同名詞的子句。這些子句之前通常會由「連接詞（whether, if）」、「疑問詞（who, why, where, how 等）」或「關係代名詞（that, which, whom, whatever 等）」引導，其後結構為直述句（也就是 S+V）。以本支影片所出現的句子舉例，So while students are solving math problems, a teacher can quickly find out who\u0026rsquo;s paying attention and who\u0026rsquo;s not. 名詞子句便是who’s paying attention and who’s not，指稱「有專心和沒有專心的（學生）」。或是 We were curious if the headbands could actually measure concentration. 就是用 if（是否）帶出「這些頭帶是不是真的可以測量專注程度」這件事，此時 the headbands could actually measure concentration 既是有主詞（the headbands）有動詞（could (actually) measure）的子句，本身也是一個名詞。\n### 例句 - I can get you whatever you want. 我可以給你你想要的任何東西。 （名詞子句為 whatever you want，你想要的任何東西） - I’m not sure whether I should tell her the truth. 我不確定要不要跟她說實話。 （名詞子句為 whether I should tell her the truth，要不要跟她說實話） - The little girl wonders how the magicians do their tricks. 小女孩在想魔術師是怎麼辦到那些把戲的。 （名詞子句為 how the magicians do their tricks，魔術師是怎麼辦到那些把戲的） ","date":"2023-10-27T21:46:23+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson009/","title":"Lesson009 - 中國 AI 科技進入校園！學生上課狀況一目了然！"},{"content":"學習影片 單字 renowned adj. 著名的 hang v. 懸掛 toss v. (隨意地) 扔，擲，拋 uproar n. 騷動 fever n. 狂熱 carpenter n. 木匠 suspect v. 認為…有嫌疑 文法 被動語態 (The Passive Voice)\nA passive voice consists of a be-verb and a past participle. Have you noticed that the \u0026ldquo;by\u0026hellip;\u0026rdquo; after a passive voice is quite often eliminated? In a sentence of active voice, if the subject is not the focal point or a generic term, \u0026ldquo;by\u0026hellip;\u0026rdquo; will be omitted so long as it doesn\u0026rsquo;t change the meaning of the sentence, as with the sentence in this lesson: He was caught in Florence. (\u0026ldquo;by someone is eliminated because it doesn\u0026rsquo;t matter who he was caught by\u0026rdquo;)\n「Be 動詞＋過去分詞」就是被動語態。不過你有沒有發現，我們常常會省略被動語態後面的 by.. .呢？在主動語態的句子中，若主詞不是重點，或是個籠統的總稱時，在不影響句意的情況下，by\u0026hellip; 則會被省略，像是本課的 He was caught in Florence. （省略 by someone，因為誰逮到犯人不是重點）。\n### 例句 - The popcorn maker was invented in 1885. 爆米花機是在 1885 年發明的。 （省略 by someone，因發明的人不是重點） - The machine is maintained every three weeks. 這部機器每三週會送修一次。 （省略 by someone，因送修的人不是重點） - The book was bought last week. 這本書是上週買的。 （省略 by someone，因買書的人不是重點） ","date":"2023-10-26T23:36:10+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson008/","title":"Lesson008 - 為什麼蒙娜麗莎的微笑如此聲名遠播？"},{"content":"學習影片 單字 completely adv. 完全地 transfer v. 轉移 zipper n. 拉鍊、夾鏈 spill v. 流出 mixture n. 混合物 seal v. 封 permit v. 允許 temperature n. 溫度 wrap v. 包 shake v. 搖動 文法 名詞子句 (Noun Clause)\nA noun clause acts as a noun and can be used as the subject, object, or complement. It starts with words like that, if, whether, where, when, how, and so on. For example, in this video, the speaker said, \u0026ldquo;I\u0026rsquo;m gonna show you how to make ice cream using ingredients you probably already have at home.\u0026rdquo; In this sentence, \u0026ldquo;how to make ice cream using ingredients you probably already have at home\u0026rdquo; is a noun clause. Though it starts with the question word \u0026ldquo;how\u0026rdquo;, the speaker wasn’t trying to ask the audience a question but to talk about \u0026ldquo;the way, the method\u0026rdquo; that you can make ice cream at home. Let’s look at the other example sentence: \u0026ldquo;This (salt) is what\u0026rsquo;s gonna help bring the temperature down.\u0026rdquo; Here, \u0026ldquo;what\u0026rsquo;s gonna help bring the temperature down\u0026rdquo; is also a noun clause, and it is not a question, either. The speaker was talking about \u0026ldquo;the thing\u0026rdquo; that is going to bring the temperature down.\n「名詞子句」是指能扮演名詞角色的子句，可以做為主詞、補語、受詞使用，由 that, if, whether, where, when, how 等等開頭，比如影片中講者說 I\u0026rsquo;m gonna show you how to make ice cream using ingredients you probably already have at home.「我要教你如何用家裡可能已經有的材料來製作冰淇淋。」此句中 how to make ice cream using ingredients you probably already have at home 為名詞子句，雖然以疑問詞 how 開頭，講者並不是在問觀眾問題，而是要講解你可以在家自己做冰淇淋的「方法」。 我們來看另一個例子：This (salt) is what\u0026rsquo;s gonna help bring the temperature down.「這（鹽巴）是用來幫忙降溫的。」這裡 what\u0026rsquo;s gonna help bring the temperature down 也是名詞子句，一樣不是問句，講者是在說明可以幫忙降溫的「事物」。\n### 例句 - What I want for dinner is a hamburger, not salad. 我晚餐想吃的是漢堡，才不是沙拉。 - My sister won\u0026#39;t tell me how she got into that trouble. 我妹妹不會跟我說她是怎麼惹上那種麻煩的。 - The question is how to define success and happiness. 問題是要如何定義成功和幸福。 ","date":"2023-10-26T23:30:50+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson007/","title":"Lesson007 - 夏天就是要吃冰啊！想知道怎麼自製冰淇淋嗎？"},{"content":"iTerm 常用快捷鍵 ⌘(command) + ⇧(shift) + i 當前窗口同時輸入指令 ⌘(command) + t 新建tab頁 ⌘(command) + d 水平分屏 ⌘(command) + 左右方向鍵 切換標籤 ⌘(command) + ; 查看歷史命令 ⌘(command) + ⇧(shift) + d 垂直分屏 ⌘(command) + ⇧(shift) + e 顯示時間線 ⌘(command) + ⇧(shift) + h 查看剪貼板歷史 ","date":"2023-10-24T21:33:34+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/iterm2-command/","title":"Iterm2常用快捷鍵"},{"content":"前情提要與架構規劃 參考專案: https://github.com/deviantony/docker-elk/tree/tls\n由於此專案演示的，是將所有角色在單機上佈屬， 然後我這裡是要示範，如何在跨節點主機上，去佈屬各項角色，達到角色拆分。 主機規劃，與角色分配\n主機名稱 主機IP node.name 角色 k8s-master71u 192.168.1.71 elasticsearch01 elasticsearch\nkibana k8s-master72u 192.168.1.72 elasticsearch02\nlogstach02 elasticsearch\nlogstach k8s-master73u 192.168.1.73 elasticsearch03\nlogstach03 elasticsearch\nlogstach 目錄結構 # 目錄結構 ./docker-compose.yml ./elasticsearch ├── config │ └── elasticsearch.yml ├── data ├── Dockerfile └── logs ./etc ├── localtime └── timezone ./extensions ./kibana ├── config │ └── kibana.yml ├── data └── Dockerfile ./LICENSE ./logstash ├── config │ └── logstash.yml ├── Dockerfile └── pipeline └── logstash.conf ./README.md ./setup ├── Dockerfile ├── entrypoint.sh ├── lib.sh └── roles ./tls ├── certs ├── Dockerfile ├── entrypoint.sh ├── instances.yml └── README.md Clone代碼，建立目錄 每一台皆要執行\n# git clone項目 root@k8s-master71u:/data# git clone --branch tls https://github.com/deviantony/docker-elk.git root@k8s-master71u:/data# cd docker-elk/ root@k8s-master71u:/data/docker-elk# ll total 48 drwxr-xr-x 10 root root 4096 Oct 23 23:14 ./ drwxr-xr-x 3 root root 24 Oct 23 23:14 ../ -rw-r--r-- 1 root root 5440 Oct 23 23:14 docker-compose.yml drwxr-xr-x 3 root root 59 Oct 23 23:14 elasticsearch/ -rw-r--r-- 1 root root 1502 Oct 23 23:14 .env drwxr-xr-x 9 root root 143 Oct 23 23:14 extensions/ drwxr-xr-x 8 root root 163 Oct 23 23:14 .git/ -rw-r--r-- 1 root root 83 Oct 23 23:14 .gitattributes drwxr-xr-x 4 root root 45 Oct 23 23:14 .github/ drwxr-xr-x 3 root root 59 Oct 23 23:14 kibana/ -rw-r--r-- 1 root root 1082 Oct 23 23:14 LICENSE drwxr-xr-x 4 root root 75 Oct 23 23:14 logstash/ -rw-r--r-- 1 root root 23158 Oct 23 23:14 README.md drwxr-xr-x 3 root root 93 Oct 23 23:14 setup/ drwxr-xr-x 3 root root 117 Oct 23 23:14 tls/ # 建立共用檔案，放置目錄 root@k8s-master71u:/data/docker-elk# mkdir etc root@k8s-master71u:/data/docker-elk# cd etc/ # 將localtime、timezone，校時與時區檔案傳入 root@k8s-master71u:/data/docker-elk# chmod 777 -R etc root@k8s-master71u:/data/docker-elk# ll etc/ total 12 drwxrwxrwx 2 root root 39 Oct 23 23:17 ./ drwxr-xr-x 11 root root 4096 Oct 23 23:15 ../ -rwxrwxrwx 1 root root 764 Oct 23 23:17 localtime* -rwxrwxrwx 1 root root 12 Oct 23 23:17 timezone* # 建立各功能，所需目錄 root@k8s-master71u:/data/docker-elk# mkdir elasticsearch/data root@k8s-master71u:/data/docker-elk# mkdir elasticsearch/logs root@k8s-master71u:/data/docker-elk# chmod 777 -R elasticsearch/data root@k8s-master71u:/data/docker-elk# chmod 777 -R elasticsearch/logs root@k8s-master71u:/data/docker-elk# mkdir kibana/data root@k8s-master71u:/data/docker-elk# chmod 777 -R kibana/data 生成憑證 選一台執行，再將生成憑證拷貝至其他主機\n# 編寫instances主機資訊，要用來產生憑證 root@k8s-master71u:/data/docker-elk# vim tls/instances.yml # This file is used by elasticsearch-certutil to generate X.509 certificates # for stack components. # # Ref. https://www.elastic.co/guide/en/elasticsearch/reference/current/certutil.html#certutil-silent # 多instance可以寫一起 instances: - name: elasticsearch dns: - elasticsearch01 - elasticsearch02 - elasticsearch03 # - elasticsearch # Compose service, resolved by the embedded Docker DNS server name # - localhost # local connections ip: - 192.168.1.71 - 192.168.1.72 - 192.168.1.73 # - 127.0.0.1 # local connections # - ::1 - name: kibana dns: - kibana # - kibana.127.0.0.1.nip.io # Examples of resolvable domains. # - kibana.127.0.0.1.sslip.io # # - localhost ip: - 192.168.1.71 # - 127.0.0.1 # - ::1 # 執行tls容器，產生憑證 root@k8s-master71u:/data/docker-elk# docker-compose up tls Attaching to docker-elk_tls_1 tls_1 | [+] CA certificate and key tls_1 | ⠿ Created tls_1 | ⠿ SHA256 fingerprint: 73cfd9c6c9220b46005ae2fcf0c0e1234093a70f4c62741ef9d701b192150a52 tls_1 | ⠿ tls/certs/ca/ca.crt tls_1 | ⠿ tls/certs/ca/ca.key tls_1 | [+] Server certificates and keys tls_1 | ⠿ Created tls_1 | ⠿ tls/certs/elasticsearch/elasticsearch.crt tls_1 | ⠿ tls/certs/elasticsearch/elasticsearch.key tls_1 | ⠿ tls/certs/kibana/kibana.crt tls_1 | ⠿ tls/certs/kibana/kibana.key tls_1 | ⠿ tls/certs/fleet-server/fleet-server.crt tls_1 | ⠿ tls/certs/fleet-server/fleet-server.key tls_1 | ⠿ tls/certs/apm-server/apm-server.crt tls_1 | ⠿ tls/certs/apm-server/apm-server.key root@k8s-master71u:/data/docker-elk# scp -r tls/certs root@192.168.1.72:/data/docker-elk/tls/ root@k8s-master71u:/data/docker-elk# scp -r tls/certs root@192.168.1.73:/data/docker-elk/tls/ 修改docker-compose設定 每一台皆要執行\n# 佈署檔案docker-compose設定 root@k8s-master71u:/data/docker-elk# vim docker-compose.yml version: \u0026#39;3.7\u0026#39; services: # The \u0026#39;tls\u0026#39; service runs a one-off script which initializes TLS certificates and # private keys for all components of the stack inside the local tls/ directory. # # This task only needs to be performed once, *before* the first stack startup. # # By default, it is excluded from the services started by \u0026#39;docker compose up\u0026#39; # due to the non-default profile it belongs to. To run it, either provide the # \u0026#39;--profile=setup\u0026#39; CLI flag to Compose commands, or \u0026#34;up\u0026#34; the service by name # such as \u0026#39;docker compose up tls\u0026#39;. tls: profiles: - setup build: context: tls/ args: ELASTIC_VERSION: ${ELASTIC_VERSION} user: root # ensures we can write to the local tls/ directory. init: true volumes: - ./tls/entrypoint.sh:/entrypoint.sh:ro,Z - ./tls/instances.yml:/usr/share/elasticsearch/tls/instances.yml:ro,Z - ./tls/certs:/usr/share/elasticsearch/tls/certs:z # The \u0026#39;setup\u0026#39; service runs a one-off script which initializes users inside # Elasticsearch — such as \u0026#39;logstash_internal\u0026#39; and \u0026#39;kibana_system\u0026#39; — with the # values of the passwords defined in the \u0026#39;.env\u0026#39; file. It also creates the # roles required by some of these users. # # This task only needs to be performed once, during the *initial* startup of # the stack. Any subsequent run will reset the passwords of existing users to # the values defined inside the \u0026#39;.env\u0026#39; file, and the built-in roles to their # default permissions. # # By default, it is excluded from the services started by \u0026#39;docker compose up\u0026#39; # due to the non-default profile it belongs to. To run it, either provide the # \u0026#39;--profile=setup\u0026#39; CLI flag to Compose commands, or \u0026#34;up\u0026#34; the service by name # such as \u0026#39;docker compose up setup\u0026#39;. setup: profiles: - setup build: context: setup/ args: ELASTIC_VERSION: ${ELASTIC_VERSION} init: true volumes: - ./setup/entrypoint.sh:/entrypoint.sh:ro,Z - ./setup/lib.sh:/lib.sh:ro,Z - ./setup/roles:/roles:ro,Z # (!) CA certificate. Generate using the \u0026#39;tls\u0026#39; service. - ./tls/certs/ca/ca.crt:/ca.crt:ro,z environment: ELASTIC_PASSWORD: ${ELASTIC_PASSWORD:-} LOGSTASH_INTERNAL_PASSWORD: ${LOGSTASH_INTERNAL_PASSWORD:-} KIBANA_SYSTEM_PASSWORD: ${KIBANA_SYSTEM_PASSWORD:-} METRICBEAT_INTERNAL_PASSWORD: ${METRICBEAT_INTERNAL_PASSWORD:-} FILEBEAT_INTERNAL_PASSWORD: ${FILEBEAT_INTERNAL_PASSWORD:-} HEARTBEAT_INTERNAL_PASSWORD: ${HEARTBEAT_INTERNAL_PASSWORD:-} MONITORING_INTERNAL_PASSWORD: ${MONITORING_INTERNAL_PASSWORD:-} BEATS_SYSTEM_PASSWORD: ${BEATS_SYSTEM_PASSWORD:-} networks: - elk depends_on: - elasticsearch elasticsearch: build: context: elasticsearch/ args: ELASTIC_VERSION: ${ELASTIC_VERSION} volumes: - ./elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml:ro,Z # elasticsearch存放data與logs目錄，依需求自行定義 - ./elasticsearch/data:/usr/share/elasticsearch/data:Z - ./elasticsearch/logs:/usr/share/elasticsearch/logs:Z # (!) TLS certificates. Generate using the \u0026#39;tls\u0026#39; service. - ./tls/certs/ca/ca.crt:/usr/share/elasticsearch/config/ca.crt:ro,z - ./tls/certs/elasticsearch/elasticsearch.crt:/usr/share/elasticsearch/config/elasticsearch.crt:ro,z - ./tls/certs/elasticsearch/elasticsearch.key:/usr/share/elasticsearch/config/elasticsearch.key:ro,z # 校時文件 - ./etc/localtime:/etc/localtime - ./etc/timezone:/etc/timezone ports: - 9200:9200 - 9300:9300 environment: # node.name 每一台要不一樣 node.name: elasticsearch01 ES_JAVA_OPTS: -Xms512m -Xmx512m # Bootstrap password. # Used to initialize the keystore during the initial startup of # Elasticsearch. Ignored on subsequent runs. ELASTIC_PASSWORD: ${ELASTIC_PASSWORD:-} # Use single node discovery in order to disable production mode and avoid bootstrap checks. # see: https://www.elastic.co/guide/en/elasticsearch/reference/current/bootstrap-checks.html #discovery.type: single-node # 主機IP network.publish_host: 192.168.1.71 # Use other cluster nodes for unicast discovery. discovery.seed_hosts: 192.168.1.71:9300,192.168.1.72:9300,192.168.1.73:9300 # Define initial masters, assuming a cluster size of at least 3. cluster.initial_master_nodes: 192.168.1.71,192.168.1.72,192.168.1.73 networks: - elk restart: unless-stopped logstash: build: context: logstash/ args: ELASTIC_VERSION: ${ELASTIC_VERSION} volumes: - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml:ro,Z - ./logstash/pipeline:/usr/share/logstash/pipeline:ro,Z # (!) CA certificate. Generate using the \u0026#39;tls\u0026#39; service. - ./tls/certs/ca/ca.crt:/usr/share/logstash/config/ca.crt:ro,z # 校時文件 - ./etc/localtime:/etc/localtime - ./etc/timezone:/etc/timezone ports: - 5044:5044 - 50000:50000/tcp - 50000:50000/udp - 9600:9600 environment: LS_JAVA_OPTS: -Xms256m -Xmx256m LOGSTASH_INTERNAL_PASSWORD: ${LOGSTASH_INTERNAL_PASSWORD:-} networks: - elk depends_on: - elasticsearch restart: unless-stopped kibana: build: context: kibana/ args: ELASTIC_VERSION: ${ELASTIC_VERSION} volumes: - ./kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml:ro,Z # kibana存放data目錄，依需求自行定義 - ./kibana/data:/usr/share/kibana/data:Z # (!) TLS certificates. Generate using the \u0026#39;tls\u0026#39; service. - ./tls/certs/ca/ca.crt:/usr/share/kibana/config/ca.crt:ro,z - ./tls/certs/kibana/kibana.crt:/usr/share/kibana/config/kibana.crt:ro,Z - ./tls/certs/kibana/kibana.key:/usr/share/kibana/config/kibana.key:ro,Z # 校時文件 - ./etc/localtime:/etc/localtime - ./etc/timezone:/etc/timezone ports: - 5601:5601 environment: KIBANA_SYSTEM_PASSWORD: ${KIBANA_SYSTEM_PASSWORD:-} networks: - elk depends_on: - elasticsearch restart: unless-stopped networks: elk: driver: bridge volumes: elasticsearch: 修改elasticsearch設定 需要安裝elasticsearch的執行\n# elasticsearch 設定檔設定 root@k8s-master71u:/data/docker-elk# vim elasticsearch/config/elasticsearch.yml --- ## Default Elasticsearch configuration from Elasticsearch base image. ## https://github.com/elastic/elasticsearch/blob/main/distribution/docker/src/docker/config/elasticsearch.yml # # cluster.name名稱，依需求自行定義 cluster.name: elk-cluster network.host: 0.0.0.0 ## X-Pack settings ## see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html # # 修改license，由trial改成basic xpack.license.self_generated.type: basic xpack.security.enabled: true ## ## TLS configuration ## See instructions from README to enable. ## ## Communications between nodes in a cluster ## see https://www.elastic.co/guide/en/elasticsearch/reference/current/configuring-tls.html#tls-transport # xpack.security.transport.ssl.enabled: true xpack.security.transport.ssl.verification_mode: certificate xpack.security.transport.ssl.certificate_authorities: [ ca.crt ] xpack.security.transport.ssl.certificate: elasticsearch.crt xpack.security.transport.ssl.key: elasticsearch.key ## HTTP client communications ## see https://www.elastic.co/guide/en/elasticsearch/reference/current/configuring-tls.html#tls-http # xpack.security.http.ssl.enabled: true xpack.security.http.ssl.certificate_authorities: [ ca.crt ] xpack.security.http.ssl.certificate: elasticsearch.crt xpack.security.http.ssl.key: elasticsearch.key 修改kibana設定 需要安裝kibana的執行\n# kibana 設定檔設定 root@k8s-master71u:/data/docker-elk# vim kibana/config/kibana.yml --- ## Default Kibana configuration from Kibana base image. ## https://github.com/elastic/kibana/blob/main/src/dev/build/tasks/os_packages/docker_generator/templates/kibana_yml.template.ts # server.name: kibana server.host: 0.0.0.0 # 多節點elasticsearch，都寫上 elasticsearch.hosts: [ \u0026#34;https://192.168.1.71:9200\u0026#34;,\u0026#34;https://192.168.1.72:9200\u0026#34;,\u0026#34;https://192.168.1.73:9200\u0026#34; ] monitoring.ui.container.elasticsearch.enabled: true monitoring.ui.container.logstash.enabled: true ## X-Pack security credentials # elasticsearch.username: kibana_system elasticsearch.password: ${KIBANA_SYSTEM_PASSWORD} ## ## TLS configuration ## See instructions from README to enable. ## ## Communications between Kibana and Elasticsearch ## see https://www.elastic.co/guide/en/kibana/current/configuring-tls.html#configuring-tls-kib-es # # 寫上根憑證位置 elasticsearch.ssl.certificateAuthorities: [ config/ca.crt ] ## Communications between web browsers and Kibana ## see https://www.elastic.co/guide/en/kibana/current/configuring-tls.html#configuring-tls-browser-kib # # 開啟kibana ssl，填寫憑證位置 server.ssl.enabled: true server.ssl.certificate: config/kibana.crt server.ssl.key: config/kibana.key ## Encryption keys (optional but highly recommended) ## ## Generate with either ## $ docker container run --rm docker.elastic.co/kibana/kibana:8.6.2 bin/kibana-encryption-keys generate ## $ openssl rand -hex 32 ## ## https://www.elastic.co/guide/en/kibana/current/using-kibana-with-security.html ## https://www.elastic.co/guide/en/kibana/current/kibana-encryption-keys.html # #xpack.security.encryptionKey: #xpack.encryptedSavedObjects.encryptionKey: #xpack.reporting.encryptionKey: ## Fleet ## https://www.elastic.co/guide/en/kibana/current/fleet-settings-kb.html # xpack.fleet.agents.fleet_server.hosts: [ https://fleet-server:8220 ] xpack.fleet.outputs: - id: fleet-default-output name: default type: elasticsearch # 多節點elasticsearch，都寫上 hosts: [ \u0026#34;https://192.168.1.71:9200\u0026#34;,\u0026#34;https://192.168.1.72:9200\u0026#34;,\u0026#34;https://192.168.1.73:9200\u0026#34; ] # Set to output of \u0026#39;docker-compose up tls\u0026#39;. Example: #ca_trusted_fingerprint: 846637d1bb82209640d31b79869a370c8e47c2dc15c7eafd4f3d615e51e3d503 is_default: true is_default_monitoring: true xpack.fleet.packages: - name: fleet_server version: latest - name: system version: latest - name: elastic_agent version: latest - name: apm version: latest xpack.fleet.agentPolicies: - name: Fleet Server Policy id: fleet-server-policy description: Static agent policy for Fleet Server monitoring_enabled: - logs - metrics package_policies: - name: fleet_server-1 package: name: fleet_server - name: system-1 package: name: system - name: elastic_agent-1 package: name: elastic_agent - name: Agent Policy APM Server id: agent-policy-apm-server description: Static agent policy for the APM Server integration monitoring_enabled: - logs - metrics package_policies: - name: system-1 package: name: system - name: elastic_agent-1 package: name: elastic_agent - name: apm-1 package: name: apm # See the APM package manifest for a list of possible inputs. # https://github.com/elastic/apm-server/blob/v8.5.0/apmpackage/apm/manifest.yml#L41-L168 inputs: - type: apm vars: - name: host value: 0.0.0.0:8200 - name: url value: https://apm-server:8200 - name: tls_enabled value: true - name: tls_certificate value: /usr/share/elastic-agent/apm-server.crt - name: tls_key value: /usr/share/elastic-agent/apm-server.key 修改logstash設定 需要安裝logstash的執行\n# logstash 設定檔設定 root@k8s-master72u:/data/docker-elk# vim logstash/config/logstash.yml --- ## Default Logstash configuration from Logstash base image. ## https://github.com/elastic/logstash/blob/main/docker/data/logstash/config/logstash-full.yml # http.host: 0.0.0.0 # node.name 每一台要不一樣 node.name: logstash02 # 測試抓容器內的log，發送到elasticsearch是否成功 root@k8s-master72u:/data/docker-elk# vim logstash/pipeline/logstash.conf input { beats { port =\u0026gt; 5044 } tcp { port =\u0026gt; 50000 } file { path =\u0026gt; [\u0026#34;/var/log/bootstrap.log\u0026#34;] type =\u0026gt; \u0026#34;system\u0026#34; start_position =\u0026gt; \u0026#34;beginning\u0026#34; } } ## Add your filters / logstash plugins configuration here output { elasticsearch { hosts =\u0026gt; [\u0026#34;192.168.1.71:9200\u0026#34;,\u0026#34;192.168.1.72:9200\u0026#34;,\u0026#34;192.168.1.73:9200\u0026#34;] user =\u0026gt; \u0026#34;logstash_internal\u0026#34; password =\u0026gt; \u0026#34;${LOGSTASH_INTERNAL_PASSWORD}\u0026#34; ssl =\u0026gt; true cacert =\u0026gt; \u0026#34;config/ca.crt\u0026#34; index =\u0026gt; \u0026#34;logstash-%{+YYYY.MM.dd}\u0026#34; codec =\u0026gt; \u0026#34;rubydebug\u0026#34; } } 啟動setup與elasticsearch 需要安裝elasticsearch的執行\n# setup腳本會帶憑證去判斷elasticsearch是否存活了，判斷存活才會設定elasticsearch所需要的帳號和密碼 # 所以將setup腳本中的環境變數elasticsearch:9200，替換成node.name名稱(前面有定義過) root@k8s-master71u:/data/docker-elk# sed -i \u0026#39;s/elasticsearch:9200/elasticsearch01:9200/g\u0026#39; setup/lib.sh root@k8s-master72u:/data/docker-elk# sed -i \u0026#39;s/elasticsearch:9200/elasticsearch02:9200/g\u0026#39; setup/lib.sh root@k8s-master73u:/data/docker-elk# sed -i \u0026#39;s/elasticsearch:9200/elasticsearch03:9200/g\u0026#39; setup/lib.sh # 添加hosts，node.name root@k8s-master71u:/data/docker-elk# vim /etc/hosts 192.168.1.71 elasticsearch01 192.168.1.72 elasticsearch02 192.168.1.73 elasticsearch03 root@k8s-master72u:/data/docker-elk# vim /etc/hosts 192.168.1.71 elasticsearch01 192.168.1.72 elasticsearch02 192.168.1.73 elasticsearch03 root@k8s-master73u:/data/docker-elk# vim /etc/hosts 192.168.1.71 elasticsearch01 192.168.1.72 elasticsearch02 192.168.1.73 elasticsearch03 **需要安裝elasticsearch的執行\n# 執行setup容器，啟動elasticsearch，並設定elasticsearch所需要使用到的帳號和密碼 root@k8s-master71u:/data/docker-elk# docker-compose up setup root@k8s-master72u:/data/docker-elk# docker-compose up setup root@k8s-master73u:/data/docker-elk# docker-compose up setup # 可以看到以下，就是elasticsearch成功啟動，且已設定elasticsearch所需要使用到的帳號和密碼 root@k8s-master71u:/data/docker-elk# docker-compose up setup docker-elk_elasticsearch_1 is up-to-date Starting docker-elk_setup_1 ... done Attaching to docker-elk_setup_1 setup_1 | [+] Waiting for availability of Elasticsearch. This can take several minutes. setup_1 | ⠿ Elasticsearch is running setup_1 | [+] Waiting for initialization of built-in users setup_1 | ⠿ Built-in users were initialized setup_1 | [+] Role \u0026#39;heartbeat_writer\u0026#39; setup_1 | ⠿ Creating/updating setup_1 | [+] Role \u0026#39;metricbeat_writer\u0026#39; setup_1 | ⠿ Creating/updating setup_1 | [+] Role \u0026#39;filebeat_writer\u0026#39; setup_1 | ⠿ Creating/updating setup_1 | [+] Role \u0026#39;logstash_writer\u0026#39; setup_1 | ⠿ Creating/updating setup_1 | [+] User \u0026#39;filebeat_internal\u0026#39; setup_1 | ⠿ No password defined, skipping setup_1 | [+] User \u0026#39;kibana_system\u0026#39; setup_1 | ⠿ User exists, setting password setup_1 | [+] User \u0026#39;logstash_internal\u0026#39; setup_1 | ⠿ User exists, setting password setup_1 | [+] User \u0026#39;heartbeat_internal\u0026#39; setup_1 | ⠿ No password defined, skipping setup_1 | [+] User \u0026#39;metricbeat_internal\u0026#39; setup_1 | ⠿ No password defined, skipping setup_1 | [+] User \u0026#39;monitoring_internal\u0026#39; setup_1 | ⠿ No password defined, skipping setup_1 | [+] User \u0026#39;beats_system\u0026#39; setup_1 | ⠿ No password defined, skipping docker-elk_setup_1 exited with code 0 root@k8s-master71u:/data/docker-elk# docker ps | grep -i elk 13130e0e2653 docker-elk_elasticsearch \u0026#34;/bin/tini -- /usr/l…\u0026#34; 3 minutes ago Up 3 minutes 0.0.0.0:9200-\u0026gt;9200/tcp, :::9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp, :::9300-\u0026gt;9300/tcp docker-elk_elasticsearch_1 https://192.168.1.71:9200/\nhttps://192.168.1.71:9200/_cat/health?v\n啟動kibana 需要安裝kibana的執行\n# 執行kibana容器，啟動kibana root@k8s-master71u:/data/docker-elk# docker-compose up -d kibana root@k8s-master71u:/data/docker-elk# docker ps | grep -i elk a652860861bc docker-elk_kibana \u0026#34;/bin/tini -- /usr/l…\u0026#34; 45 seconds ago Up 38 seconds 0.0.0.0:5601-\u0026gt;5601/tcp, :::5601-\u0026gt;5601/tcp docker-elk_kibana_1 13130e0e2653 docker-elk_elasticsearch \u0026#34;/bin/tini -- /usr/l…\u0026#34; 11 minutes ago Up 11 minutes 0.0.0.0:9200-\u0026gt;9200/tcp, :::9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp, :::9300-\u0026gt;9300/tcp docker-elk_elasticsearch_1 https://192.168.1.71:5601/\n啟動logstash 需要安裝logstash的執行\n# 執行logstash容器，啟動logstash root@k8s-master72u:/data/docker-elk# docker-compose up -d logstash root@k8s-master73u:/data/docker-elk# docker-compose up -d logstash root@k8s-master72u:/data/docker-elk# docker ps | grep -i elk c7712d2eb7bd docker-elk_logstash \u0026#34;/usr/local/bin/dock…\u0026#34; 31 seconds ago Up 30 seconds 0.0.0.0:5044-\u0026gt;5044/tcp, :::5044-\u0026gt;5044/tcp, 0.0.0.0:9600-\u0026gt;9600/tcp, :::9600-\u0026gt;9600/tcp, 0.0.0.0:50000-\u0026gt;50000/tcp, :::50000-\u0026gt;50000/tcp, 0.0.0.0:50000-\u0026gt;50000/udp, :::50000-\u0026gt;50000/udp docker-elk_logstash_1 678934a90729 docker-elk_elasticsearch \u0026#34;/bin/tini -- /usr/l…\u0026#34; 13 minutes ago Up 13 minutes 0.0.0.0:9200-\u0026gt;9200/tcp, :::9200-\u0026gt;9200/tcp, 0.0.0.0:9300-\u0026gt;9300/tcp, :::9300-\u0026gt;9300/tcp docker-elk_elasticsearch_1 可以從kibana頁面看到，有索引進來了\n創建Data Views\n可以從Discover查看到收集的log訊息了\n點擊，Stack Monitoring 可以簡單看到elasticsearch和kibana的狀態 (注意)自簽憑證3年到期 重新頒發憑證(並改10年到期) 停掉所有elasticsearch和kibana和logstash\nroot@k8s-master71u:/data/docker-elk# docker-compose down root@k8s-master72u:/data/docker-elk# docker-compose down root@k8s-master73u:/data/docker-elk# docker-compose down root@k8s-master71u:/data/docker-elk# docker-compose ps Name Command State Ports ------------------------------ root@k8s-master72u:/data/docker-elk# docker-compose ps Name Command State Ports ------------------------------ root@k8s-master73u:/data/docker-elk# docker-compose ps Name Command State Ports ------------------------------ 刪除原本憑證\nroot@k8s-master71u:/data/docker-elk# rm -rf tls/certs/* root@k8s-master72u:/data/docker-elk# rm -rf tls/certs/* root@k8s-master73u:/data/docker-elk# rm -rf tls/certs/* 選一台執行，再將生成憑證拷貝至其他主機\n# 修改憑證頒發到期時間為10年，有bin/elasticsearch-certutil這段，都加上--days 3650 root@k8s-master71u:/data/docker-elk# vim tls/entrypoint.sh echo \u0026#39;[+] CA certificate and key\u0026#39; if [ ! -f tls/certs/ca/ca.key ]; then symbol=⠿ bin/elasticsearch-certutil ca \\ --days 3650 \\ --silent \\ --pem \\ --out tls/certs/ca.zip echo \u0026#39;[+] Server certificates and keys\u0026#39; if [ ! -f tls/certs/elasticsearch/elasticsearch.key ]; then symbol=⠿ bin/elasticsearch-certutil cert \\ --days 3650 \\ --silent \\ --pem \\ --in tls/instances.yml \\ --ca-cert tls/certs/ca/ca.crt \\ --ca-key tls/certs/ca/ca.key \\ --out tls/certs/certs.zip # 頒發憑證 root@k8s-master71u:/data/docker-elk# docker-compose up tls Creating network \u0026#34;docker-elk_default\u0026#34; with the default driver Creating network \u0026#34;docker-elk_elk\u0026#34; with driver \u0026#34;bridge\u0026#34; Creating docker-elk_tls_1 ... done Attaching to docker-elk_tls_1 tls_1 | [+] CA certificate and key tls_1 | ⠿ Created tls_1 | ⠿ SHA256 fingerprint: d93ccec000656ad3cd2ea04e1de39c0c2d32eef1b20b32a117d3c92469ed94fb tls_1 | ⠿ tls/certs/ca/ca.crt tls_1 | ⠿ tls/certs/ca/ca.key tls_1 | [+] Server certificates and keys tls_1 | ⠿ Created tls_1 | ⠿ tls/certs/elasticsearch/elasticsearch.crt tls_1 | ⠿ tls/certs/elasticsearch/elasticsearch.key tls_1 | ⠿ tls/certs/kibana/kibana.crt tls_1 | ⠿ tls/certs/kibana/kibana.key tls_1 | ⠿ tls/certs/fleet-server/fleet-server.crt tls_1 | ⠿ tls/certs/fleet-server/fleet-server.key tls_1 | ⠿ tls/certs/apm-server/apm-server.crt tls_1 | ⠿ tls/certs/apm-server/apm-server.key docker-elk_tls_1 exited with code 0 root@k8s-master71u:/data/docker-elk# scp -r tls/certs root@192.168.1.72:/data/docker-elk/tls/ root@k8s-master71u:/data/docker-elk# scp -r tls/certs root@192.168.1.73:/data/docker-elk/tls/ 將各台服務啟動\nroot@k8s-master71u:/data/docker-elk# docker-compose up -d elasticsearch root@k8s-master72u:/data/docker-elk# docker-compose up -d elasticsearch root@k8s-master73u:/data/docker-elk# docker-compose up -d elasticsearch root@k8s-master71u:/data/docker-elk# docker-compose up -d kibana root@k8s-master72u:/data/docker-elk# docker-compose up -d logstash root@k8s-master73u:/data/docker-elk# docker-compose up -d logstash https://192.168.1.71:9200/\nelasticsearch憑證更換成10年了 kibana可以正常登入\nkibana憑證更換成10年了 資料也有正常進來了，完成更換憑證\n","date":"2023-10-24T06:52:48+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/docker-compose-elk-multinodes-cluster/","title":"ELK8.x 多節點集群佈署-啟用security(tls)登入驗證(Docker-Compose)"},{"content":"〈結語〉讓成果永續的祕訣 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n有個被稱為「堆垛悖論」的古希臘寓言，講述一個小行為被重複足夠多次之後所能產生的影響。\n同樣的道理也適用於原子習慣。一個小改變可以顛覆你的人生嗎？你不太可能給出肯定的答案。但假如你再做了一個小改變呢？再一個呢？再一個呢？到了某個時間點，你不得不承認自己的人生被一個小改變顛覆了。\n有時你很難記住某個習慣，就需要「讓提示顯而易見」；有時你會缺乏起頭的動力，就需要「讓習慣有吸引力」；許多時候，你也許會覺得某個習慣太過困難，就需要「讓行動輕而易舉」；有時候，你不想堅持下去，就需要「讓獎賞令人滿足」。\n一輪又一輪，持續尋找讓你獲得百分之一的進步的下一個方法。\n小習慣不只會累積，還有複利效應\n這就是原子習慣的力量：微小改變，非凡成果。\n","date":"2023-10-22T14:22:33+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary07/","title":"原子習慣 - Summary07 - 〈結語〉讓成果永續的祕訣"},{"content":"|進階策略| 如何從「A」到「A+」 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n18. 基因如何影響習慣的養成 讓成功機率最大化的祕訣就是選對戰場，這個道理適用於運動與商業，也適用於習慣的改變。\n基因無法被輕易改變，這代表它們會在有利的條件下提供強大的優勢，也會在不利的環境中帶來嚴重的劣勢。\n簡言之，基因決定的不是你的命運，而是你在哪個領域會有機會。\n蓋伯．麥特醫師所言：「基因能預先決定傾向，但不能預先決定命運。」\n「性格如何影響習慣」 最有科學根據的分析被稱為「五大人格特質」，它將性格特質分解為五種行為光譜。\n1.經驗開放性：一端是好奇且具創造力，另一端是謹慎而堅守例行公事。 2.嚴謹性：一端是有條理、有效率，另一端是隨和、隨性。 3.外向性：一端是外向、有活力，另一端是孤僻、保守（就是常聽到的外向者與內向者）。 4.友善性：一端是親切、有憐憫心，另一端是疏離、慣於質疑。 5.神經質：一端是焦慮、敏感，另一端是自信、冷靜、情緒穩定。 重點是，你應該配合性格打造習慣。\n選擇最適合你的習慣，而不是最受歡迎的習慣。\n每個習慣都有一個可以為你帶來喜悅與滿足的版本，把它找出來。若要長久維持，習慣必須讓人覺得愉快、享受，這是行為改變第四法則背後的核心概念。\n「如何找到對自己有利的賽場」 選到正確的習慣，進步就很簡單；選到錯誤的習慣，人生就充滿掙扎、搏鬥。\n最普遍的做法是「試誤」。當然，這項策略有個問題：人生苦短。你沒有時間去嘗試每一種職業、去跟每個中意的單身對象約會，或是練習每一種樂器。幸好，有個方法可以解決這個難題──一個被稱為「開發與善用權衡」的妙法。\n長久下來，最有效的做法也許是將百分之八十到九十的時間投注於帶來最佳結果的策略上，然後用剩餘的百分之十到二十的時間繼續開發、探索。\n在開發、探索不同選項時，可以問自己幾個問題，以持續縮小最能滿足自己的習慣與領域的範圍。\n什麼事情對別人來說是勞苦，對我來說卻是樂趣？ 什麼事情讓我忘記時間？ 什麼事情讓我比一般人得到更多報償？ 什麼事情對我來說是自然而然的？ 倘若無法找到對你有利的賽場，就自己創造一個吧。\n當你無法靠著「更好」來贏，可以憑藉「不同」勝出。\n滾水會讓馬鈴薯變軟，但會讓雞蛋變硬。你無法控制自己生來是顆馬鈴薯或雞蛋，但你可以決定要比硬，還是比軟。若能找到比較有利的環境，就能翻轉原本對你不利的條件。\n「如何善用你的基因」 基因不會消除努力的必要，而是讓努力的方向變清楚。基因告訴我們要努力去做什麼。\n人們太執著於自己「有極限」這件事，以致很少真正盡力去接近那些極限。\n總之，要確保習慣可以長期為你帶來滿足感，最好的方法之一，就是選擇符合你性格與能力的行為。在對自己來說輕而易舉的事情上努力就對了。\n「本章總覽」 讓成功機率最大化的祕訣，就是選對戰場。 選到正確的習慣，進步就很簡單；選到錯誤的習慣，人生就充滿掙扎、搏鬥。 基因無法被輕易改變，這代表它們會在有利的條件下提供強大的優勢，也會在不利的環境中帶來嚴重的劣勢。 符合你天生的能力時，習慣比較容易執行。請選擇最適合自己的習慣。 選擇對自身強項有利的賽場。如果找不到，就自己創造一個。 基因不會消除努力的必要，而是讓努力的方向變清楚。基因告訴我們要努力去做「什麼」。 19. 金髮女孩原則：如何在生活與工作中維持動力 如他所言：「十年學習，四年精進，四年紅透半邊天。」\n目前眾人最一致的發現是：維持動力並達到欲望最高點的關鍵，就是執行「難度恰到好處」的任務。\n根據金髮女孩原則，當執行的任務恰好位在當下能力的邊緣，人便會感受到最高程度的動力。不要太難，也不要太簡單，恰到好處就對了。\n然而，一旦建立習慣，重要的是持續產生微小的進步。這些小進步與新的挑戰可以讓你保持投入，若恰好擊中「金髮女孩區」，就能進入「心流狀態」。\n而在自我精進的征途上，無聊可能是大魔王。\n「如何在感到無聊時保持專注」 他提到幾個意料之中的因素：基因、運氣、天賦。不過，他接著丟出一個我沒料到的答案：「到了某個時間點，一切都歸結到誰能處理每天訓練的無聊，一次又一次，反覆做著相同的舉重動作。」\n但這位教練的意思是，真正成功的人也會跟一般人一樣覺得沒有動力，差別在於，儘管覺得厭倦、無聊，他們還是設法繼續。\n成功最大的威脅不是失敗，而是無聊。\n變動獎賞不會創造渴望──也就是說，你不能拿一個人們不感興趣的獎賞，以變動的間隔給他們，然後希望這個獎賞可以讓他們改變主意──但對於強化我們原本就有的渴望非常有效，因為變動獎賞能夠減低無聊。\n欲望的甜蜜點出現在成功與失敗的機率各半之時。一半的時間，你得償所願；另一半的時間，你求之不得。你需要恰好足夠的「勝利」來體驗滿足感，也需要恰好足夠的「想要」來感受欲望。這是遵循金髮女孩原則的好處之一。\n不管有沒有變動獎賞，任何習慣都無法永遠保持有趣。在自我精進的旅途上，到了某個時間點，每個人都會面對同樣的挑戰：你必須愛上無聊。\n專業人士堅守既定行程，業餘者接受生活的干擾；專業人士知道什麼事情對自己最重要，帶著決心奮力向前，業餘者則讓生活中的緊急事件拽離正軌。\n反覆做著一模一樣的事，卻無止境地感受到趣味，就是成就卓越的不二法門。你必須愛上無聊。\n「本章總覽」 根據金髮女孩原則，當執行的任務恰好位在當下能力的邊緣，人便會感受到最高程度的動力。 成功最大的威脅不是失敗，而是無聊。 當習慣變成例行公事，就會變得比較不有趣、比較不令人滿足。我們會無聊。 動力滿滿時，每個人都能努力打拚。在工作不令人興奮時繼續努力，這種能力才是造就差異的關鍵。 專業人士堅守既定行程，業餘者接受生活的干擾。 20. 建立好習慣的壞處 當你可以不假思索地把事情做得「夠好」，就不會去思考要怎麼樣才能做得「更好」。\n事實上，某些研究顯示，一旦精通某項技巧，隨著時間過去，表現反而會有些微退步。\n追求精通，習慣是必要的，但只有習慣並不夠，你需要的是自動化習慣與刻意練習的組合。\n習慣＋刻意練習＝精通\n精通是一個過程，你在此過程中將焦點鎖定在成功的一個微小元素，不斷重複該技能，直到將其內化，然後以這個新習慣為基礎，往個人發展的下一個疆界前進。第二次執行時，舊任務變得比較容易，但整體難度並沒有下降，因為現在你要把能量投入下一個挑戰中。每個習慣都為更高層次的表現解鎖，這是個無止境的循環。\n開始覺得自己已精通一項技能──事情變得自動化，讓你應付自如──的那個瞬間更須小心，不要踏入自滿的陷阱。\n解決辦法？建立一套反省與複查的系統。\n「如何複查習慣並做出調整」 隔年，萊里帶領球隊再次奪冠，湖人隊成為ＮＢＡ二十年來第一支完成二連霸的隊伍。後來，他如此說道：「對任何事業而言，維持努力都是最重要的。成功之道就是學會用正確的方法做事，然後每一次都用同樣的方法做。」\n改善不只關乎學習習慣，還關乎微調習慣。\n我個人主要運用的反省與複查模式有兩種。每年十二月，我會進行一次「年度審核」，反思過去的一年。我為那年的習慣打分數的方式，是計算自己發表了多少篇文章、健身了多少回、造訪了多少個新地方等等。接著，我透過回答以下三個問題，來反思自己的進步（或缺乏進步）：\n1.今年什麼事情很順利？ 2.今年什麼事情不順利？ 3.我從中學到什麼？ 六個月後，當夏季到來，我會進行「誠實報告」。跟每個人一樣，我會犯許多錯，而我的誠實報告讓我明白哪裡出錯，激勵我重回正軌。我運用這段時間重新審視自己的核心價值觀，思考自己是否有依照這些價值觀行事。我會思索自己的身分認同，看看應該如何努力成為自己想要成為的那種人。在每年的誠實報告中，我會問自己三個問題：\n1.驅動我的生活與工作的核心價值觀為何？ 2.我現在如何誠實地生活與工作？ 3.未來如何設定更高的標準？ 最後，反省與複查提供了一段理想的時間，讓我們重新檢視行為改變最重要的一個面向：身分認同。\n「如何破除妨礙你前進的信念」 解決方法之一，就是不要讓身分的任何單一面向決定你是誰。套句投資專家保羅．葛拉罕的話：「讓你的身分保持渺小。」愈是讓單一信念定義自己，愈無法適應生命的挑戰。\n要減輕身分喪失造成的影響，關鍵就是重新定義自己。如此一來，才能在特定角色改變時，仍保住你身分認同的重要面向。\n萬物皆無常，生命一直在改變，所以必須定期檢視舊有的習慣與信念是否仍然對自己有用。\n缺乏自我覺察是毒藥，反省與複查則是解藥。\n「本章總覽」 習慣的好處在於讓我們可以不經思考行事，壞處則在於讓我們不再注意到微小的失誤。 習慣＋刻意練習＝精通 反省與複查是一個讓你對自身表現長久保持覺察的過程。 愈是緊抓一個身分認同不放，愈難讓自己超越這個身分成長。 ","date":"2023-10-22T13:54:20+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary06/","title":"原子習慣 - Summary06 - |進階策略| 如何從「A」到「A+」"},{"content":"|法則4| 讓獎賞令人滿足 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n15. 行為改變的基本原則 這十分有力地證明了行為改變第四法則：讓獎賞令人滿足。\n這些故事證明了行為改變的基本原則：帶來獎賞的行為會被重複，帶來懲罰的行為會被避免。\n行為改變的前三條法則──讓提示顯而易見、讓習慣有吸引力、讓行動輕而易舉──增加了我們這一次執行某個行為的機率。行為改變的第四條法則──讓獎賞令人滿足──則增加我們下一次重複該行為的可能性。習慣迴路就這樣完成了。\n「立即獎賞與延遲獎賞之間的不一致」 當立即的結果讓人喜歡，後來的結果就會帶來災難，反之亦然──幾乎總是如此……一個習慣最初結的果實愈甜美，後來的果實往往愈苦澀。\n一般來說，一個行為讓你得到愈多立即的愉悅，你應該愈強烈地質疑該行為與自己的長遠目標是否一致。\n帶來立即獎賞的行為會被重複，帶來立即懲罰的行為會被避免。\n最好的辦法就是為長遠有益的習慣添加一些立即的愉悅，為長遠無益的習慣增添一些立即的痛苦。\n「如何把「立即滿足」變得對你有利」 維持一項習慣的關鍵重點是「成功」的感受，就算只是小規模。成功的感受讓你知道該習慣有所回報，努力是值得的。\n強化法則把習慣跟立即的獎賞綁在一起，讓你在結束時感到滿足。\n不過，證據的累積與新身分認同的出現都需要時間。在等待長期獎賞出現時，立即的強化能幫助你在短期內保持動機。\n「本章總覽」 行為改變第四法則，是「讓獎賞令人滿足」。 當經驗令人滿足，我們比較有可能重複一項行為。 人類的大腦演化為優先考慮立即的獎賞，而不是延遲的獎賞。 行為改變的基本原則：帶來立即獎賞的行為會被重複，帶來立即懲罰的行為會被避免。 維持一項習慣的關鍵重點是「成功」的感受──就算只是小規模。 行為改變的前三條法則──讓提示顯而易見、讓習慣有吸引力、讓行動輕而易舉──增加了我們這一次執行某個行為的機率。行為改變的第四條法則──讓獎賞令人滿足──則增加我們下一次重複該行為的可能性。 16. 如何每天堅持好習慣 進步令人滿足，視覺上的測量──例如移動迴紋針、髮夾或彈珠──則提供了你有所進步的清楚證據。 「習慣追蹤幫助你維持習慣」 「不要中斷連續紀錄」是個強大的咒語。\n習慣追蹤的力量很強大，因為用上了好幾條行為改變法則：它同時讓一項行為顯而易見、有吸引力，且令人滿足。\n「好處一習慣追蹤顯而易見」 「好處二習慣追蹤有吸引力」 「好處三習慣追蹤令人滿足」 習慣堆疊加習慣追蹤的公式是：\n做完〔目前的習慣〕之後，我會〔追蹤該習慣〕。 「如何在習慣中斷之後快速回復」 每當這種情況發生，我就會提醒自己守住一個簡單的原則：不要錯過兩次。\n如果錯過一天，我會盡快重回正軌。錯過一次健身難免，但我不會允許自己連續錯過兩次\n毀掉你的永遠不會是第一個錯誤，而是後續接連發生的一錯再錯。錯過一次是意外，錯過兩次就是另一項習慣的開始。\n如查理．蒙格所言：「複利的首要原則：非必要，別中斷。」\n動力滿滿的時候去鍛鍊很容易，但不想做的時候還是去做，才是最重要的──就算做的比希望的少。\n「弄清楚何時應該（及何時不該）追蹤一項習慣」 古德哈特定律，因經濟學家查爾斯．古德哈特而得名。此定律指出：「當測量成了目標，就不再是個好的測量方式。」測量只有在引導你、助你看清全局，而不是消耗你心神的時候，才對你有用。 「本章總覽」 最令人感到滿足的感覺之一，就是進步的感覺。 習慣追蹤器是測量自己有沒有執行某項習慣的簡單方式──例如在日曆上打一個勾。 藉由提供進步的清楚證據，習慣追蹤器與其他視覺化的測量方式可以讓習慣變得令人滿足。 不要中斷連續紀錄，試著讓連續執行習慣的紀錄延續下去。 不要錯過兩次。如果錯過一天，就盡快回歸正軌。 可以測量一樣事物，不代表那就是最重要的東西。 17. 問責夥伴作用大 在討論行為改變第四法則的過程中，我們談到讓好習慣帶來立即滿足感的重要性。費雪的提議則是第四法則的反轉：讓後果立即令人不滿。\n痛苦是效能卓越的老師。當失敗令人痛苦，就會被修正；反之，當失敗比較不令人痛苦，往往會被無視。\n我們之所以重複惡習，是因為它們在某方面對我們有用，這讓惡習變得難以擺脫。就我所知，克服這個困境最好的方法，就是加快與該行為相關的懲罰到來的速度。\n一般來說，後果愈切身、有形、具體、立即，愈有可能對個人行為產生影響；後果愈遙遠、無形、抽象、延遲，對個人行為產生影響的可能性愈低。\n「習慣契約讓違背承諾變成公開且令人痛苦的事」 要讓壞習慣令人不滿，最好的選擇就是讓它們在當下令人痛苦，而習慣契約正是為此而生的簡單做法。 「本章總覽」 行為改變第四法則的反轉，就是「讓後果令人不滿」。 我們比較不可能重複會令人不滿或痛苦的壞習慣。 問責夥伴能為「不作為」創造立即的代價。我們深深在乎他人如何看待自己，不希望別人對我們抱持較差的評價。 習慣契約可以被用來為任何行為添加社會代價，它讓違背承諾變成一件公開且令人痛苦的事。 知道有人在看著，會是個強大的動力。 ","date":"2023-10-22T13:51:44+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary05/","title":"原子習慣 - Summary05 - |法則4| 讓獎賞令人滿足"},{"content":"|法則3| 讓行動輕而易舉 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n11. 精通習慣由重複開始 嘗試找到改變的最佳計畫，往往讓人綁手綁腳：最快速的減重法、最棒的健身方式、開創副業的完美想法。\n這就是你一直處於啟動狀態，卻從不採取行動的最大原因：你想要延後失敗。\n當準備成了一種拖延，你就必須做出改變。你不會只想計畫，你要的是實行。\n想要精通一項習慣，關鍵是由重複開始，而非完美。你不必詳細列出新習慣的所有特徵，只要開始實行就好了。這就是行為改變第三法則的第一個重點：開始重複實行就對了。\n「習慣的養成取決於頻率，而非時間」 每一次重複都強化了細胞間的信號傳遞，神經連結變得緊密。神經心理學家唐諾．海伯於一九四九年首次提出這個現象，所以它通常被稱作海伯定律：「同步發射的神經元會連結在一起。」 習慣的養成取決於頻率，而非時間。 我最常聽到的一個問題是：「要花多久才能建立一項新習慣？」但大家真正應該問的是：「要花多少次才能建立一項新習慣？」\n要養成一項習慣，就必須去實踐；而讓實踐發生最有效的方法，就是遵守行為改變第三法則：讓行動輕而易舉。\n「本章總覽」 行為改變第三法則，是「讓行動輕而易舉」。 最有效的學習形式是實行，而非計畫。 把重點放在行動，而非啟動。 在習慣養成的過程中，透過不斷重複，一個行為漸漸變得自動化。 執行一項習慣的時間長短，不如執行該習慣的次數多寡重要。 12. 最小努力原則 而一項習慣所需的能量愈少，養成的可能性愈高。\n因此，讓習慣簡單到就算沒有意願也會執行至關重要。\n「讓行動輕而易舉」背後的概念並非叫你只做容易的事，而是要你盡可能讓「做那些長期下來會有回報的事」這個行動變得不費力。\n「如何用更少力氣成就更多」 與其試著克服生活中的阻力，不如將其減少。\n減少與習慣相關的阻力，最有效的方法之一就是環境設計。\n日本公司強調所謂的『精實生產』，不懈地在生產過程中移除各種浪費，包括重新設計工作空間，讓員工不必浪費時間轉身拿取工具。結果就是，日本工廠比美國的更有效率，日本製的產品也比美國製的更可靠。\n核心概念就是創造出一個讓正確的事情盡可能輕而易舉的環境。習慣打造的關鍵多半歸結到設法減少與好習慣相關的阻力，增加與壞習慣相關的麻煩。\n「為了以後方便，把環境準備好」 我們都應該問自己：「如何設計一個讓做正確的事變得容易的世界？」請重新設計你的生活，讓最重要的事做起來最簡單。 「本章總覽」 人類行為遵循最小努力原則，我們自然會被花費最少力氣的選項吸引。 創造一個讓正確的事情盡可能容易執行的環境。 減少與好習慣相關的阻力。阻力一少，養成習慣就簡單了。 增加與壞習慣相關的阻力。阻力一多，養成習慣就困難了。 把環境準備好，讓未來的行動容易執行。 13. 如何運用「兩分鐘法則」停止拖延 只要踏出第一步，接下來的每一件事──開車去健身房、決定要做哪些運動、站到槓鈴底下──都變得輕而易舉。\n每一天總有幾個這樣的瞬間，會在之後帶來巨大的影響。我把這些小選擇稱為「決定性瞬間」\n「兩分鐘法則」 新習慣不該讓你覺得像是一種挑戰，接下來的行動可以有挑戰性，但開頭的兩分鐘應該輕而易舉。你需要的是可以自然引導你走上比較有成效的路的「入門習慣」。 但重點不是做一件事，而是掌握「起頭」的習慣。\n對某些人來說，兩分鐘法則看起來可能像個花招。明知道真正的目標是在兩分鐘之後持續進行，運用兩分鐘法則好像在騙自己。\n其實，祕訣就是在覺得費力之前停止。英國一位領導力顧問葛瑞格．麥基昂就靠著特意寫得比自己想要的少，來養成每天寫日記的習慣。\n他說：「最棒的方式就是見好就收。」\n每當你覺得很難堅持某個習慣時，就運用兩分鐘法則吧。這是讓習慣變得輕而易舉的簡單方法。 「本章總覽」 習慣可以在幾秒內完成，卻會持續影響你幾分鐘、甚至幾小時後的行為。 許多習慣都發生在決定性瞬間。所謂決定性瞬間就是如同岔路般的種種選擇，可以讓你踏上成果豐碩的一日，也可以讓你踏上一事無成的一天。 兩分鐘法則就是：新習慣的開始應該要花不到兩分鐘。 愈是把一個過程的開頭儀式化，愈有可能進入成就大事所需的高度專注狀態。 要先標準化，才能最佳化。你無法改善不存在的習慣。 14. 如何讓好習慣變得無可避免，讓壞習慣不可能發生 這是行為改變第三法則的反轉：讓行動困難無比。\n承諾機制是用當下做的選擇來控制未來的行為。這是鎖定未來行為，把你跟好習慣綁在一起，並讓你遠離惡習的一個方法。\n關鍵在於改變任務，讓違背好習慣比開始執行好習慣更花力氣。\n「如何讓習慣自動化，從此不假思索便能執行」 數學家兼哲學家懷海德曾經寫道：「讓可以不假思索執行的事情變多，就是文明進步的基礎。」\n透過運用承諾機制、策略性的一次性選擇，以及科技，你可以打造一個充滿必然性的環境──在這個空間裡，好習慣不再只是你希望的結果，而是幾乎保證會發生的結果。\n「本章總覽」 行為改變第三法則的反轉，就是「讓行動困難無比」。 承諾機制就是用當下做的選擇來鎖定未來比較好的行為。 鎖定未來行為的終極之道，是將習慣自動化。 一次性選擇──例如購買更好的床墊或註冊自動儲蓄計畫──是能讓未來的習慣自動化，而且其回報會隨著時間增加的單一行為。 要確保採取正確的行動，使用科技來讓習慣自動化是最可靠且有效的方法。 ","date":"2023-10-22T13:49:28+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary04/","title":"原子習慣 - Summary04 - |法則3| 讓行動輕而易舉"},{"content":"|法則2| 讓習慣有吸引力 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n８. 如何讓習慣變得難以抗拒 現代食品工業及其造成的飲食過量習慣，恰恰驗證了行為改變的第二條法則：讓習慣有吸引力。一個機會愈有吸引力，形成習慣的可能性愈大。 「多巴胺驅動的回饋迴路」 縱使多巴胺被阻斷，牠們還是跟以前一樣喜歡糖，只是不再想要了。\n習慣就是多巴胺驅動的回饋迴路。\n論及習慣，關鍵重點是：大腦不只在你體驗愉悅時分泌\n你的大腦分配給想要獎賞的神經迴路，遠比分配給喜歡獎賞的要多。 「如何運用誘惑綑綁，讓習慣更有吸引力」 誘惑綑綁的運作方式，就是把想要做的事跟必須做的事綁在一起。以拜恩為例，他把看 Netflix（想要做的事）跟踩健身自行車（必須做的事）綁在一起了。\n誘惑綑綁是心理學理論「普氏原則」的一種應用。\n「較高可能性的行為會強化較低可能性的行為」；換句話說，就算你不是真的想要處理延誤的工作郵件，如果它意味著你可以在過程中做某件你真正想做的事，你就會訓練自己去做。\n習慣堆疊加誘惑綑綁的公式如下：\n1.做完〔目前的習慣〕之後，我會執行〔我需要的習慣〕。 2.做完〔我需要的習慣〕之後，我會執行〔我想要的習慣〕。 「本章總覽」 行為改變第二法則，是「讓習慣有吸引力」。 一個機會愈有吸引力，愈有可能形成習慣。 習慣是多巴胺驅動的回饋迴路。多巴胺升高，行為的動機也隨之提升。 讓我們採取行動的，是對獎賞的預期，而非獎賞的實現。期待愈大，多巴胺峰值愈高。 誘惑綑綁是讓習慣更有吸引力的一種方法，這個策略是將「想要」的行為與「需要」的行為配對。 ９. 家人與朋友如何形塑你的習慣 他的格言是：「天才不是生出來的，而是教育與訓練出來的。」 「社會常規的誘人拉力」 達爾文指出的：「在人類漫長的歷史中，學會合作且最能臨機應變的人總會取得優勢。」 我們尤其會模仿三種群體的習慣：\n1.親近的人 2.多數的人 3.有力的人 「1.模仿親近的人」 要打造更好的習慣，最有效的方法之一就是加入一個把你想要的行為視作常態的文化之中。 「2.模仿多數的人」 當改變習慣意味著挑戰族群，改變就沒有吸引力；而當改變習慣意味著融入族群，改變就變得很有吸引力了。 「3.模仿有力的人」 「本章總覽」 所處文化決定了哪些行為對我們有吸引力。 我們傾向養成被所處文化誇讚與認可的習慣，因為我們有融入與歸屬於族群的強烈渴望。 我們往往會模仿三種人：親近的人（家人與朋友）、多數的人（族群），以及有力的人（有地位與聲望的人）。 打造更好習慣最有效的方式之一，就是加入具備以下兩個特點的文化：一，你想要的行為是常態；二，你跟這個群體本來就有某些共同點。 族群的常態行為往往會壓過個人想要的行為。大多數時間，我們寧願跟大家一起錯，也不要自己一個人對。 若一個行為能獲得認可、尊敬與讚美，我們就會覺得那個行為有吸引力。 10. 如何找出並解決壞習慣的成因 這就是行為改變第二法則的反轉：讓習慣毫無吸引力。 「採取行動的渴望從何而來」 神經學家安東尼歐．達馬吉歐解釋的：「讓你決定事情是好、是壞，或無關緊要的，就是情緒。」 「如何重新設定大腦，讓自己享受困難的習慣」 重新思考你的習慣，把重點放在益處，而非壞處。這是一個快速而輕鬆的方式，使你重新設定大腦，讓習慣顯得比較有吸引力。\n想要找出並解決壞習慣的成因，關鍵就是重新架構你對它們的聯想。這並不容易，但如果可以重新設定你的預測，就可以把困難的習慣轉變為有吸引力的習慣。\n「本章總覽」 行為改變第二法則的反轉，就是「讓習慣毫無吸引力」。 每個行為都有表層的渴望與深層的潛在動機。 習慣是古老欲望的現代解決方案。 習慣的成因，其實就是行為發生前的預測。預測帶來感覺。 強調避免某個壞習慣的益處，會讓它顯得沒有吸引力。 與正面感受產生連結，習慣就有吸引力；與負面感受產生連結，習慣就沒有吸引力。創造一個動機儀式：在執行困難的習慣之前，做一件你很享受的事。 ","date":"2023-10-22T13:44:07+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary03/","title":"原子習慣 - Summary03 - |法則2| 讓習慣有吸引力"},{"content":"|法則1| 讓提示顯而易見 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n４. 行為改變的過程始於覺察 在能夠有效建立新習慣之前，必須先掌握現有的習慣。 「習慣記分卡幫助你覺察自身習慣」 這套被稱為「指差確認」的程序是被設計來減少錯誤的安全系統\n指差確認減少了百分之八十五的錯誤，並避免了百分之三十的事故。\n指差確認之所以如此有效，就是因為把無意識的習慣拉到有意識的層次。\n對自己實際的作為保持意識、保持覺察，是改變習慣最大的挑戰之一。\n能夠強化你渴望的身分認同的習慣，通常是好習慣；與之相悖的，則通常是壞習慣。\n改變惡習的第一步，就是密切注意它們。\n行為改變的過程始終始於覺察。指差確認與習慣記分卡這類策略的重點，在於讓你認出自己的習慣及觸發這些習慣的提示，這樣你才有可能以對自己有益的方式做出回應。\n「本章總覽」 只要有足夠的練習，你的大腦就會不假思索地挑出預示某些結果的提示。 習慣一旦自動化，我們就不會再注意自己所做的事。 行為改變的過程始終始於覺察。必須先意識到自己的習慣，才能改變它們。 指差確認」透過開口說出自己的行為，把無意識的習慣拉到有意識的層次。 你可以運用「習慣記分卡」這個簡單的練習，來增加對自身行為的覺察。 ５. 開始一個新習慣最好的方法 下週，我會於〔某日〕的〔某時〕在〔某處〕進行至少二十分鐘的激烈運動。\n第三組受試者填寫的句子，就是研究人員所謂的「執行意向」，一份你要在何時何處行動的預先計畫；換句話說，就是你打算如何執行某一特定習慣。\n概括地說，執行意向大致是長這樣：\n當Ｘ情境發生時，我就會執行Ｙ回應。\n對何時何地執行一項新習慣做出確切計畫的人，比較可能真的去執行。\n執行意向掃除模糊的概念，像是「我要多運動」或「我要更有生產力」或「我該去投票」，以具體的行動計畫取而代之。\n一旦設定執行意向，就不用等靈感來敲門。\n我會於〔時間〕，在〔地點〕進行〔行為〕。\n如果不確定要何時開始執行新習慣，試試每年、每月或每週的第一天。人比較可能在這些時間點展開行動，因為比較有充滿希望的感覺。\n當你的夢想太模糊，就很容易整天將小例外合理化，而不去處理成功所需的確切任務。\n「徹底修正習慣的「習慣堆疊」」 狄德羅效應顯示，取得一項新的所有物往往會帶來連鎖消費反應，平添額外的購物。\n建立新習慣最好的方法之一，就是先找出自己目前的每日習慣，然後把新的行為堆疊上去。這就叫作習慣堆疊。\n習慣堆疊的公式如下：\n做完〔目前的習慣〕之後，我會執行〔新的習慣〕。 關鍵在於把想要的行為跟每天已經在做的事情綁在一起。\n這讓你得以利用「一個行為導致下一個行為」的慣性──狄德羅效應的正面版本。\n無論你是如何運用這項策略，成功創造習慣堆疊的祕訣，就是找到觸發行為的正確提示。\n行為改變的第一條法則，是「讓提示顯而易見」。\n「本章總覽」 行為改變的第一條法則，是「讓提示顯而易見」。 最常見的兩種提示是時間與地點。 可以運用執行意向這個策略，將新習慣與確切的時間和地點配對。 執行意向的公式是：我會於〔時間〕，在〔地點〕進行〔行為〕。 習慣堆疊的公式是：做完〔目前的習慣〕之後，我會執行〔新的習慣〕。 ６. 激勵被高估了，環境往往更重要 人們選擇某樣產品，往往不是因為那樣產品是什麼，而是因為產品在哪裡。\n習慣改變取決於你身處的空間，以及眼前的提示。\n換言之，有時顧客購買產品，不是因為想要，而是因為這些產品被呈現的方式。\n然而，人類所有感覺能力中最強的一項，是視覺。\n因此，所見稍有不同，就可能造成所為的巨大變動。\n「如何打造成功養成好習慣的環境」 想要讓習慣成為生活的一大部分，就讓提示成為環境的一大部分。\n不要只當你所處世界的顧客，也要成為它的設計者。\n「情境是觸發習慣的提示」 習慣可能不只跟單一提示聯想在一起，而是與圍繞著該行為的整個情境連結。\n定義行為的並非環境中的物品，而是我們與物品的關係。\n不要認為環境中充滿物品，要認為環境中充滿關係。\n情境的力量也透露了一項重要策略：在新環境中比較容易改變習慣。\n我個人覺得很有用的一句口號是：「一個空間，一個用途。」\n如果可以，盡量避免把一個習慣的情境跟另一個習慣的情境混在一起。\n我認識一個作家，他的電腦只用來寫作，平板只用來閱讀，手機只用來上社群媒體與收發訊息。每個習慣都應該有個自己的家。\n一個凡事各安其位、各司其職的穩定環境，就是可以輕鬆養成習慣的環境。\n「本章總覽」 隨著時間過去，情境的小改變可能造成行為的大變化。 每個習慣都是被提示觸發的。我們比較容易注意到突出的提示。 讓環境裡可以觸發好習慣的提示顯而易見。 漸漸地，你的習慣不是與單一提示聯想在一起，而是與圍繞著該行為的整個情境連結。情境成了提示。 在新的環境養成新的習慣比較簡單，因為不用對抗舊提示。 ７. 自制力的祕密 「自律者」只是擅長建構生活，好讓自己不需要展現超凡的意志力與自我控制力。換言之，他們不常讓自己處於充滿誘惑的情境。\n最有自制力的，通常是最少用到自制力的人。\n習慣一旦建立，只要環境裡的提示再度出現，行動的渴望便隨之而來。\n研究人員將此現象稱為「提示引起的想望」：一個外在刺激造成了一股想要重複惡習的強迫性渴望。\n直白地說，我不曾看過有誰可以在負面環境裡一直保持正面習慣。\n要剷除一項壞習慣，最實用的方法之一就是減少接觸會激發此惡習的提示。\n這個做法是行為改變第一條法則的反轉：讓提示隱而不現，而非顯而易見。\n自制力是一種短期策略，不適用於長期。\n讓好習慣的提示顯而易見，讓壞習慣的提示隱而不現。\n「本章總覽」 行為改變第一法則的反轉，就是「讓提示隱而不現」。 習慣一旦形成，就很難被遺忘。 有高度自制力的人不常待在充滿誘惑的環境裡。迴避誘惑比抗拒誘惑簡單。 要剷除一項壞習慣，最實用的方法之一就是減少接觸會激發此惡習的提示。 自制力是一種短期策略，不適用於長期。 ","date":"2023-10-22T13:39:24+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary02/","title":"原子習慣 - Summary02 - |法則1| 讓提示顯而易見"},{"content":"|基本原理| 為何細微改變會帶來巨大差異? 以下是我從書中提取出來，對我來說，是不錯的句子。 全出自《原子習慣》https://readmoo.com/book/210109063000101\n〈前言〉原子習慣改變了我的人生 我進入丹尼森大學時。那是一個新的開始，也是在那個地方，我初次發現微小習慣的驚人力量。\n只要你願意堅持多年，起初看似微不足道的改變終將像以複利計算一樣利滾利，滾出非比尋常的結果。\n唯一讓我進步的方式──我唯一做的選擇──就是由小做起。\n微小的習慣幫助我發揮自身潛能\n本書的骨幹是我所謂「習慣的四階段模型」──提示、渴望、回應、獎賞\n這本書探討的是不變的部分\n人很容易高估一個決定性瞬間的重要性，也很容易低估每天都做些小改善的價值\n本書的骨幹是我所謂「習慣的四階段模型」──提示、渴望、回應、獎賞\n這本書探討的是不變的部分\n1. 原子習慣的驚人力量 「複利效應，讓小習慣造就大不同」 人很容易高估一個決定性瞬間的重要性，也很容易低估每天都做些小改善的價值\n造就成功的，是日常習慣，而不是千載難逢的轉變。\n好習慣讓時間成為你的盟友，壞習慣讓時間與你為敵。\n「建立持久的習慣為何這麼難？」 在任何追尋的前期或中期，常常出現所謂的「失望之谷」──你期待有線性進展，但在前幾天、幾週，甚至幾個月，效果都很不顯著，令人感到挫敗。 強大的成果總是姍姍來遲。 「別管目標，專注於系統就好」 目標是你想要達到的成果，而系統是讓你達到那些成果的過程。\n想要更好的成果，就不要管目標了，把焦點放在系統上就好。\n目標有助於確立方向，但系統是進步的最佳解答。如果花太多時間思考目標，卻花太少時間設計系統，會浮現許多問題。\n問題一贏家跟輸家擁有同樣的目標\n問題二目標達成不過是短暫的改變\n目標的達成只能暫時改變你的生活。 問題三目標限制了你的快樂\n系統優先的心態提供了解藥。當你愛上過程，而非產物，就不必等到獲得自己的許可才能快樂。 問題四目標與長期進步互相矛盾\n最後，目標取向的心態可能造成一種「溜溜球效應」。許多跑者連續努力數月，但衝過終點線之後，就停止訓練了。\n到頭來，progress（進步）的必要條件，是對 process（過程）的投入。\n「原子習慣的系統」 本書的核心主旨之一，就是教你聚焦於整體系統，而非單一目標。這也是「原子」一詞背後較為深層的意義之一。\n原子習慣指的是微小的改變、微不足道的增長、百分之一的改善。\n習慣雖小，力量無窮，這便是「原子習慣」一詞的真義\n「本章總覽」 習慣是「自我改善」這件事的複利。每天進步百分之一，長久下來，進境可觀。 習慣是一把兩面刃，能載舟亦能覆舟，因此了解細節是必要的。 在跨越關鍵門檻之前，小改變往往看似無足輕重。所有複利過程的強大成果總是遲來，你要有耐性。 原子習慣是構成大系統的小習慣。如同原子是分子的組成單元，原子習慣是建構非凡成果的元件。 想要更好的結果，就別管目標設定，而是專注於你的系統。 決定你成功或失敗的，不是你的目標，而是你的系統。 ２. 改變習慣最有效的方法，是改變身分認同 改變習慣之所以如此具有挑戰性，原因有二：一，我們試圖改變的東西不對；二，我們試圖改變習慣的方式不對。\n第一個錯誤是試圖改變的東西不對。要了解我的意思，必須知道改變的發生分成三個層次，你可以想成洋蔥的三層皮。\n第一層是改變結果。\n第二層是改變過程。\n最深的第三層是改變身分認同。\n結果關乎你得到什麼，過程關乎你做了什麼，身分認同則關乎你相信什麼。\n問題在於改變的方向。\n許多人在展開改變習慣的過程時，都把重點放在想要達成什麼。這會將我們引至以結果為基礎的習慣。替代做法是建立以身分認同為基礎的習慣──在這種方式下，我們一開始就把重點放在希望成為什麼樣的人。\n每個行動系統的背後都是一個信念系統。\n一組信念與假設形塑了系統，習慣背後存在著一個身分認同。\n你也許想要更有錢，但倘若你的身分認同就是個傾向消費而非創造收入的人，你就會一直被吸引去花錢，而不是賺錢\n你也許想要變得更健康，但倘若你繼續把舒適擺在成就之前，你便會選擇放鬆而非訓練\n你有新的目標與新的計畫，但你還沒改變自己是個什麼樣的人。\n內在動機的終極型態，就是讓習慣成為身分認同的一部分。覺得自己是想要這樣的人是一回事，覺得自己就是這樣的人又是另一回事。\n反覆對自己述說同一個故事，多年下來就很容易陷入這個心理慣例，認為它就是事實。\n然而長遠來說，未能維持習慣的真正原因，都是被你的自我形象阻攔。\n想要成為最好的自己，就要持續編輯、修訂自己的信念，升級並拓展你的身分認同。\n「改變身分認同的兩個步驟」 習慣就是身分認同的具體化。\n有愈多證據支持某個信念，你愈會深信不疑。\n我並非一開始就是個作家，而是透過習慣成為一名作家。\n當然，習慣並非影響身分認同的唯一因素，但因為頻率的關係，它們往往是最重要的因素。\n藉由提供新身分的證據，小習慣可以造就有意義的差異；而當一個改變有意義，它實際上就是一個大改變。\n要改變你是什麼樣的人，最實際的方法就是改變你做的事。\n1.決定你想要成為什麼樣的人。\n2.透過生活中的小勝利來向自己證明。\n以身分認同為基礎的習慣這個概念是一塊敲門磚，引出本書另一個關鍵主題：回饋迴路。\n焦點永遠都要放在成為某一種人，而非得到某一種成果。\n「習慣會讓你變成你想要成為的人」 第一個步驟不是什麼，也不是如何，而是什麼樣的人。\n習慣可以幫助你達成上述這些，但根本上，習慣的精髓並非擁有，而是成為。\n「本章總覽」 改變分為三個層次：成果改變、過程改變，以及身分認同改變。 改變習慣最有效的方法，就是把焦點放在想要成為什麼樣的人，而不是想要達到什麼成果。 你的身分認同源自你的習慣。每個行動都是一張選票，投給你想要成為的那種人。 要成為最好的自己，就必須持續編輯、修訂自己的信念，升級並拓展你的身分認同。 習慣之所以重要的真正原因，不是因為可以讓你得到更好的成果（雖然確實有這個功效），而是因為可以讓你改變對自身的信念。 ３. 四個簡單的步驟，讓你建立更好的習慣 桑代克如此描述學習的過程：「帶來可喜後果的行為往往會被重複，而帶來可厭後果的行為比較不可能被重複。」 「習慣可以讓你騰出自由思考與創意所需的心理空間」 所謂習慣，就是重複次數多到足以自動化的行為。\n碰巧遇上意料之外的獎賞後，你下次就會變更策略。大腦會立刻開始記錄獎賞出現之前的行為。等一下，這感覺真棒。我在這之前做了什麼？\n所謂習慣，就是針對規律遇上的問題與壓力的一組自動化解決方案。\n科學家傑森．瑞哈所言：「習慣不過是環境中反覆出現的問題的可靠解決之道。」\n習慣減輕了認知負荷，釋出心智容量，好讓你把注意力分配給其他任務。\n習慣不會限制自由，而是創造了自由。事實上，沒能掌握習慣的人往往擁有最少的自由。少了良好的財務習慣，你永遠在操心下一餐的著落；少了良好的健康習慣，你會永遠缺乏活力；少了良好的學習習慣，你會一直感覺自己追不上別人。\n「習慣形成的四步驟」 提示、渴望、回應、獎賞 我們因為兩個目的追求獎賞：一，獎賞滿足我們；二，獎賞教育我們。\n這四個步驟合在一起，形成了一個神經學上的回饋迴路──提示、渴望、回應、獎賞；提示、渴望、回應、獎賞──最終讓你建立了自動化的習慣。這樣的循環被稱為習慣迴路。\n「適用於任何領域的行為改變四法則」 每當你想要改變一個行為，只要自問：\n1.我要怎麼讓提示顯而易見？ 2.我要怎麼讓習慣有吸引力？ 3.我要怎麼讓行動輕而易舉？ 4.我要怎麼讓獎賞令人滿足？ 「本章總覽」 習慣就是重複次數多到足以自動化的行為。 習慣的終極目標，就是用最少的能量與努力解決生活中的問題。 所有習慣都能被分解為包括提示、渴望、回應、獎賞等四步驟的回饋迴路。 行為改變四法則是一組能幫助我們建立更好習慣的簡單規則：一，讓提示顯而易見；二，讓習慣有吸引力；三，讓行動輕而易舉；四，讓獎賞令人滿足。 ","date":"2023-10-22T13:31:39+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/atomic-habits-day011-summary01/","title":"原子習慣 - Summary01 - |基本原理| 為何細微改變會帶來巨大差異?"},{"content":"學習影片 單字 significant adj. 顯著的；有效的 ; 重大的 diet n. 飲食 factor n. 因素，要素 maintenance n. 維持；保持 combination n. 結合 calorie n. 卡，卡路里 aging adj. 老化的 文法 「要不是\u0026hellip;就是\u0026hellip;」、「要麼\u0026hellip;要麼\u0026hellip;」 (Either\u0026hellip;or\u0026hellip;)\n\u0026ldquo;Either\u0026hellip;or\u0026hellip;,\u0026rdquo; indicating a choice between two options. It is important to note that the part of speech following \u0026ldquo;or\u0026rdquo; must be equivalent to that following \u0026ldquo;either.\u0026rdquo; For example, if \u0026ldquo;either\u0026rdquo; is followed by a verb phrase, \u0026ldquo;or\u0026rdquo; should typically be followed by another verb phrase.\nEither 若是與連接詞 or 連用，中文意思是「要不是\u0026hellip;就是\u0026hellip;」、「要麼\u0026hellip;要麼\u0026hellip;」，帶有兩者擇一的概念。要特別注意的是，either 與 or 後面一個字的詞性通常必須對等。例如 either 後面接一個動詞片語，or 後面通常也須接一個動詞片語。\n### 例句 - Emily will visit you either today or tomorrow. Emily 要不是今天會拜訪你，就是明天。 - You can either play the card game or see a film. 你要麼可以玩牌，要麼可以看場電影。 Either I drive to the restaurant or I get a taxi. 要麼我開車去餐廳，要麼我搭計程車去。 ","date":"2023-10-21T23:23:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson006/","title":"Lesson006 - 想瘦身？運動跟節食哪個比較有效？"},{"content":"學習影片 單字 invent v. 發明 preserve v. 保存，對食物進行保鮮處理 freeze v. 冷凍 cell n. 細胞 conditions n. 環境，（天氣）情況 damage v. 破壞 combine v. 結合 inspired adj. 受到啟發的 文法 分詞構句 (Participle Clauses)\nIn this lesson, we\u0026rsquo;ve learned the participle clause formed using past participles. Past participle clauses can replace passive voice finite clauses. By omitting the same subject and verb to be, past participle (which functions as an adjective) is left, making the sentence simpler. Let\u0026rsquo;s take a look at the following examples:\n本堂課中我們介紹了由過去分詞 (P.P.) 所形成的分詞構句。過去分詞構句的原句主要是包含主詞以及 be 動詞的「被動句」。藉由省略了相同的主詞、be 動詞，最後留下了過去分詞 (功能類似形容詞) 進而精簡句子。看看下面例句，你會更了解過去分詞構句的形成過程唷！\n### 例句 - When threatened, they will definitely fight back. 當被威脅時，他們將會反擊。（原句為 When/If they are threatened, they will definitely fight back.。） - Written in simple English, the book is suitable for the beginners. 以淺顯易懂的英語所寫成，這本書適合初級學生使用。（原句為Because the book is written in simple English, it is suitable for the beginners.。） - Worried by the news, she called the hospital. 她對這個消息感到很擔心，所以就打電話到醫院。（原句為 Because she was worried by the news, she called the hospital.） ","date":"2023-10-19T22:56:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson005/","title":"Lesson005 - 你所不知道「冷凍食品」的秘密！"},{"content":"學習影片 單字 briefing n. 簡報，簡要介紹 fasten v. 繫上 illegal adj. 違法的 prohibited adj. 禁止的 emergency n. 緊急情況 aircraft n. 飛機 operate v. 操作 takeoff n. 起飛 upright adj. 豎直的 文法 助動詞 May、Might (Modal Verbs - May, Might)\nThe auxiliary verb \u0026ldquo;may\u0026rdquo; is often used to express possibility, and \u0026ldquo;might\u0026rdquo; is the past tense of \u0026ldquo;may.\u0026rdquo; However, in modern English, we can use both \u0026ldquo;might\u0026rdquo; and \u0026ldquo;may\u0026rdquo; to talk about something likely to happen at present or in the future. In this case, there is only a small difference in the level of probability: \u0026ldquo;might\u0026rdquo; suggests a lower probability than \u0026ldquo;may.\u0026rdquo; Note that \u0026ldquo;may\u0026rdquo; can also be used to give permission. Therefore, in a negative hypothetical situation, we should use \u0026ldquo;might not\u0026rdquo; instead of \u0026ldquo;may not;\u0026rdquo; otherwise, the listener may be confused about whether what we mean is something \u0026ldquo;is not allowed\u0026rdquo; or \u0026ldquo;is not likely to happen.\u0026rdquo; For example, the sentence \u0026ldquo;You may not go to the store\u0026rdquo; has two possible meanings: 1) You are not allowed to go to the store. 2) You probably will not go to the store. On the other hand, \u0026ldquo;You might not go to the store\u0026rdquo; has only one meaning: You probably will not go to the store. Hence, when talking about something that is not likely to happen, it can be better to use \u0026ldquo;might\u0026rdquo; to avoid confusion with the permissive \u0026ldquo;may.\u0026rdquo;\nMay 這個助動詞常見的意思是「可能，也許」，而 might 則是它的過去式。但其實在現代英文中，若要表示「現在或未來有可能會發生的情況」，兩者皆可使用。這種情形下，語意上唯一的小小差異是 may 所表達的可能性比 might 還要高一點。 要注意的是，may 也能用來表達「禮貌表達許可與否」，所以如果要表示「現在或未來可能不會發生的情況」，就要使用 might not，而不是 may not，否則會讓聆聽者不知道到底是要表達「不允許」還是「可能不會」。舉例來說，You may not go to the store 有可能是「你不能去商店」或是「你可能不會去商店」，但You might not go to the store 只有一種意思：「你可能不會去商店」。所以當要表達可能不會發生的事情時，要用 might not 才不會造成誤解喔！\n### 例句 - I may grab some snacks and drinks on my way. 我路上可能會買些零食飲料。 - There may be a delay in the delivery on weekends. 週末時運送可能會延遲。 - I might be wrong, but don\u0026#39;t you think watching TV is a total waste of time? 我不一定是對的，不過你不覺得看電視根本是浪費時間嗎？ ","date":"2023-10-17T23:59:03+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson004/","title":"Lesson004 - 魔術師現身：這個搭機安全介紹影片我看得完！"},{"content":"學習影片 單字 keep v. 保持 hate v. 厭惡 improve v. 改善 thought n. 想法 change n. 改變 awful adj. 糟糕的 straight adj. 直的 suffer v. 受苦 hardly adv. 幾乎不 文法 過去進行式 (The Past Continuous)\nThe past continuous is mostly used to express \u0026ldquo;past\u0026rdquo; actions or states that are \u0026ldquo;incomplete\u0026rdquo;, and its constructed by \u0026ldquo;be-verb (was/were) + present participle (V-ing)\u0026rdquo;. We all know that present participles function similar to \u0026ldquo;adjectives\u0026rdquo;, and following be-verbs, they describe a \u0026ldquo;state\u0026rdquo;. it is because of this characteristic that this state has the feature of \u0026ldquo;continuity\u0026rdquo; or \u0026ldquo;frequent\u0026rdquo;. Take this sentence from the lesson, \u0026ldquo;Why was I completely leaving out my left hand?\u0026rdquo;, the action was not completed or concluded in the past. It is a state that \u0026ldquo;continued for a period of time; was undergoing in the past\u0026rdquo;.\n過去進行式多用來表達「過去未完成或不完整」的動作或狀態，由 be 動詞的過去式 (was/were) ＋ 現在分詞 (V-ing) 構成。 我們都知道現在分詞類似於「形容詞」，而接在 be 動詞後，就是描述一種「狀態」。所以注意，就是因為這樣的特性，這種狀態是會有「持續性」或「經常性」的特性。例如本課 Why was I completely leaving out my left hand? 這句，這個動作並不是在過去就完成、結束的，反而是一種「持續了一段時間、過去正在進行中」的狀態。\n### 例句 - They were seeing a film last night. 他們昨晚在看一部電影。 - He was playing basketball this morning. 今天早上他在打籃球。 - I was running this time yesterday. 我昨天這個時候在跑步。 ","date":"2023-10-15T19:55:30+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson003/","title":"Lesson003 - 你有強迫症嗎？來看看你是否也有這些症狀"},{"content":"學習影片 單字 mean adj. 卑鄙的；刻薄的；惡毒的 shut v. （使）停止運作；（使）關閉 level n. 程度；高度；層次 fragile adj. 易損壞的；易碎的；脆弱的 journey n. 旅行；旅程 tremendous adj. 巨大的；極好的；大量的 sensitive adj. 神經過敏的；易被冒犯的；敏感的 horrible adj. 極糟的 dependent adj. 依賴的 文法 虛主詞 - There (Dummy Subjects - There)\n英文的句子，有個規定，就是「主詞的位置」是需要被填滿的。舉例來說，當我們在中文裡說：「有個東西在那」，嚴格說起來這句是沒有主詞的，然而英文不允許這樣的事發生，因此我們會安插入「虛主詞」。英文的虛主詞主要包含 It 與 There 兩者。本課主要聚焦在 there 上，這個字原本作為地方副詞，放在句尾，其意義為強調動作發生的「地方」，而其本身亦是名詞。作為虛主詞，其實是由倒裝句型的演變而成，There 成為主詞後，失去其原本表達地方的意義，反而變成強調動作發生的事實，用來引出某人、事、物的存在。There 所銜接的動詞的「數」，由後方的名詞所決定。\n英文的句子，有個規定，就是「主詞的位置」是需要被填滿的。舉例來說，當我們在中文裡說：「有個東西在那」，嚴格說起來這句是沒有主詞的，然而英文不允許這樣的事發生，因此我們會安插入「虛主詞」。英文的虛主詞主要包含 It 與 There 兩者。本課主要聚焦在 there 上，這個字原本作為地方副詞，放在句尾，其意義為強調動作發生的「地方」，而其本身亦是名詞。作為虛主詞，其實是由倒裝句型的演變而成，There 成為主詞後，失去其原本表達地方的意義，反而變成強調動作發生的事實，用來引出某人、事、物的存在。There 所銜接的動詞的「數」，由後方的名詞所決定。\n### 例句 - There are two people waiting outside. 外頭有兩個人在等。 - There was once a poor farmer with his little farm. 從前有位窮農夫，他有座小農場。 - There could be three typhoons coming next month. 下個月可能會有三個颱風接力而來。 ","date":"2023-10-11T23:50:17+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson002/","title":"Lesson002 - 【艾倫秀】安海瑟威如何看待自己被霸凌"},{"content":"架構修改如下圖： 參考網站： https://www.criwits.top/page/20220828132827-0gnvmfs\n原始workflow yml檔如下：\n# chingtsechen.github.io/.github/workflows/gh-pages.yml name: github pages on: push: branches: - main # Set a branch to deploy jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # \u0026#39;0.83.1\u0026#39; extended: true # 有用擴充套件則將 # 移除 - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 創建Source Code Repository 設定為Private，外部無法直接訪問 生成公鑰與私鑰 chenqingze@chenqingze-MBP 8. blog % ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; chenqingze@chenqingze-MBP 8. blog % ll total 16 drwxr-xr-x@ 6 chenqingze staff 192 9 21 00:37 Kubernetes drwxr-xr-x@ 5 chenqingze staff 160 9 30 21:37 Python drwxr-xr-x@ 21 chenqingze staff 672 10 9 15:25 chingtsechen.github.io -rw------- 1 chenqingze staff 3389 10 10 11:02 gh-pages -rw-r--r-- 1 chenqingze staff 750 10 10 11:02 gh-pages.pub 配置Source Code Repository 私鑰 chenqingze@chenqingze-MBP 8. blog % cat gh-pages 將Source Code 推送進去Repository 由於Source Code Repository是Private的，所以pull code與push code要用帳號和密碼， 現在密碼都改用token的方式，所以要生成一個token\n使用帶帳號的方式git clone代碼\n# git clone帶帳號 https://chingtsechen@ # @git clone的連結 github.com/chingtsechen/blog-goldfishbrain-fighting.git # 完整動作 git clone https://chingtsechen@github.com/chingtsechen/blog-goldfishbrain-fighting.git # 會要求打密碼，就是使用token chenqingze@chenqingze-MBP 8. blog % git clone https://chingtsechen@github.com/chingtsechen/blog-goldfishbrain-fighting.git Cloning into \u0026#39;blog-goldfishbrain-fighting\u0026#39;... Password for \u0026#39;https://chingtsechen@github.com\u0026#39;: warning: You appear to have cloned an empty repository. clone下來會是空目錄，將blog源碼檔案放置進去\nchenqingze@chenqingze-MBP blog-goldfishbrain-fighting % ll total 32 -rw-r--r--@ 1 chenqingze staff 1066 10 10 11:24 LICENSE -rw-r--r--@ 1 chenqingze staff 2874 10 10 11:24 README.md drwxr-xr-x@ 7 chenqingze staff 224 10 10 11:24 assets drwxr-xr-x@ 4 chenqingze staff 128 10 10 11:24 config drwxr-xr-x@ 7 chenqingze staff 224 10 10 11:24 content -rw-r--r--@ 1 chenqingze staff 130 10 10 11:25 go.mod -rw-r--r--@ 1 chenqingze staff 199 10 10 11:25 go.sum drwxr-xr-x@ 5 chenqingze staff 160 10 10 11:25 layouts drwxr-xr-x@ 3 chenqingze staff 96 10 10 11:25 resources drwxr-xr-x@ 9 chenqingze staff 288 10 10 11:25 static drwxr-xr-x@ 3 chenqingze staff 96 10 10 11:25 template drwxr-xr-x@ 3 chenqingze staff 96 10 10 11:26 themes 推送至github\nchenqingze@chenqingze-MBP blog-goldfishbrain-fighting % git add . -A chenqingze@chenqingze-MBP blog-goldfishbrain-fighting % git commit -m \u0026#34;first commit\u0026#34; chenqingze@chenqingze-MBP blog-goldfishbrain-fighting % git push 可以看到，代碼都push上來了 配置靜態頁Repository 公鑰 chenqingze@chenqingze-MBP 8. blog % cat gh-pages.pub 為Source Code Repository創建workflow Actions → set up a workflow yourself\nworkflow代碼如下，#處要注意，需依自己需求去修改\n# blog-goldfishbrain-fighting/.github/workflows/main.yml name: GitHub Pages on: push: branches: - main jobs: deploy: runs-on: ubuntu-20.04 steps: - name: Checkout repositories uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 有用擴充套件則將 # 移除 - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: chingtsechen/chingtsechen.github.io # 要發佈的repository publish_branch: main publish_dir: ./public # 要發佈的目錄 cname: blog.goldfishbrain-fighting.com # 如果有修改域名，這裡打上 可以看到佈屬成功 到靜態頁Repository查看是否佈屬成功 確認Settings-\u0026gt;Pages，使用Branch和Custom domain是否設定正確 測試發佈文章 推送代碼至blog-goldfisnbrain-fighting後，workflow執行編譯並推送編譯後靜態頁至chingtsechen.github.io中 可以看到，發佈文章成功，就此，整體hugo架構修改已大功告成了 ","date":"2023-10-10T10:38:49+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/blog-hugo-architecture/","title":"修改hugo在github上的架構"},{"content":"分享一下，為了想讓生活多點想法，想知道成功人士分享的經驗，於是我開始閱讀習慣，選擇使用電子書，試閱讀之後，選擇用Readmoo讀墨這個平台，整體使用感受非常好，尤其能夠使用朗讀方式，幫我朗讀書，因為專注力很難集中，有了這個功能，大大增加了我對書的閱讀興趣，以下是使用平板試閱的影片，往後會再來分享，讀書心得。\n","date":"2023-10-10T00:49:07+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/readmoo-book000/","title":"我開始使用Readmoo讀墨 閱讀電子書"},{"content":"簡單來說，將圖片存在google drive，設定共享，複製連結，將連結修改即可。\n點複製連結\n# 連結如下 https://drive.google.com/file/d/1Gdh2dKRP1X4xv8Br6K56SZdn_RwgTOj1/view?usp=sharing 修改連結\n# 1. 只要提取上述連結中的字串 ....../file/d/字串/view?...... 字串 = 1Gdh2dKRP1X4xv8Br6K56SZdn_RwgTOj1 # 2. 將字串與以下連結合併 https://drive.google.com/uc?export=view\u0026amp;id=字串 完整連結 = https://drive.google.com/uc?export=view\u0026amp;id=1Gdh2dKRP1X4xv8Br6K56SZdn_RwgTOj1 # 3. 此完整連結就能永久分享在各處，例如以下markdown插入圖片分享 ![](https://drive.google.com/uc?export=view\u0026amp;id=1Gdh2dKRP1X4xv8Br6K56SZdn_RwgTOj1) 插入圖片效果\n","date":"2023-10-09T22:34:26+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/google-drive-image/","title":"使用google drive當作圖床"},{"content":"學習影片 單字 colorblind adj. 色盲的 issue n. 問題 occasional adj. 偶爾的；不經常的 entire adj. 整個的；完全的 supposed to adj. 應該 emotional adj. 激動的；感情強烈的 excitement n. 興奮；令人興奮的事情 文法 過去簡單式 (The Past Simple)\nWe use past simple tense to describe actions that happened and finished in the past. For regular past tense forms, we add -d or -ed to the root form of the verb. On the other hand, there is no rule for irregular verbs, and we should learn them by heart.\n過去簡單式表示過去所發生的動作，而且這個動作在過去某一時間點已經結束。過去式動詞有分規則與不規則兩種。規則動詞過去式通常在字尾加上 -ed；不規則則須加以熟悉。\n### 例句 - Sara refused her boyfriend\u0026#39;s proposal. Sara 拒絕了她男友的求婚。 - I went fishing with my grandpa last weekend. 上週末我和爺爺釣魚去了。 - Andy bought some bread for tomorrow\u0026#39;s breakfast on his way home. Andy 在回家的路上買了一些麵包作為明天的早餐。 ","date":"2023-10-09T21:44:08+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson001/","title":"Lesson001 - 第一次看見色彩"},{"content":"先稍微記錄一下，整體建置與工作流程：\nhugo官網找喜歡的theme(https://themes.gohugo.io/) 選擇使用Stack(https://themes.gohugo.io/themes/hugo-theme-stack/) 作者github裡面有教學，可以直接clone代碼匯入我的github repositiry 新repositiry名稱使用：github帳號id.github.io git clone代碼到本機，hugo server執行看看，打上http://localhost:1313，就能直接看到頁面效果 修改手機版無法看到大綱toc問題(直接複製貼上裡面四個檔案到相對的目錄中) 參考網站(https://github.com/CaiJimmy/hugo-theme-stack/pull/615/files#diff-eef437e68bc6669e72d9b52c51e6f18c33aaedc919cd231abc1a68aa7030fcb3) 網站左邊menu 透明漂亮icon使用，svg檔製作 參考網站(https://tablericons.com/) 網站左邊page新增與修改 色碼表，網站各處顏色更改會用到 參考網站(https://www.ifreesite.com/color/) 開始優化美化頁面 參考網站(https://blog.linsnow.cn/p/modify-hugo/) 參考網站(https://ponder.lol/2023/custom-hugo-theme-stack/) 添加網站底部顯示發表xx文章、本站運行xx天、本站總訪問量xx次功能 參考網站(https://thirdshire.com/post/hugo-stack-renovation/) 修改文章description描述字體大小，縮小(在article.scss裡面的.article-subtitle) 添加disqus評論功能 參考網站(https://blog.tershi.com/pages/cafd93/#%E8%A8%BB%E5%86%8A-disqus-%E5%B8%B3%E8%99%9F) 添加channel.io頁面即時聊天功能 參考網站(https://thirdshire.com/post/hugo-stack-renovation/) 以上在本地修改與美化頁面功能驗證完畢後，將代碼推送到github中 使用github workflow建立自動發佈gh-pages branch功能 參考網站(https://www.zoeydc.com/zh/posts/2021-05-23-hugo-website_github-pages_custom-domain/) 網頁測試打(https://github帳號id.github.io)，網站是否呈現 購買domain name，我使用cloudflare(https://dash.cloudflare.com/) 購買domain name 更新DNS記錄，設定CNAME，名稱blog，內容github預設pages頁面網址(github帳號id.github.io) 啟用http強制轉到https 將github pages自訂網域名 至github專案中，Settings-\u0026gt;Pages-\u0026gt;Branch選擇gh-pages分支 Custom domain-\u0026gt;設定已註冊的domain name(blog.goldfishbrain-fighting.com) 網頁測試打domain name，網站是否呈現(https://blog.goldfishbrain-fighting.com/) google-search-console添加 會需要驗證網站擁有權，將google提供檔案放置網站根目錄下(static/googlexxxxxx.html) 添加sitemap，好讓google幫我們產生索引，後續才能夠過google瀏覽器，搜尋到我的網站(可能會需要好多天，才能完成) google-analytics添加 好讓後續可以分析網站使用狀況 以上就完成了使用hugo在github架站 後續新文章撰寫，我是使用obsidian撰寫文章 使用template功能，寫文章時，快速插入front matter 如果categories有新增，記得要先去categories目錄新增出來 如有快速貼上圖片，圖片記得改檔名，因為會有空格，網站會無法正常辨識路徑和檔名 撰寫文章完畢，使用obsidian git插件，直接使用快捷鍵ctrl+p叫出命令面板，執行Commit all changes、Push就能將文章推送到我的github中 github接收到commit，就會自動使用workflow幫我佈屬gh-pages 以下就是網站呈現的樣子 ","date":"2023-10-09T09:53:09+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/blog-hugo/","title":"我使用hugo在github架設我的第一個Blog"},{"content":"我選擇免費方案，每天能遊玩30分鐘，體驗一下 使用我的MACBOOK M1 PRO登入Counter-Strike 2中，需要排隊一下 下方就是我的遊玩體驗影片，很久沒玩CS，有點爛，見諒 :)\n","date":"2023-10-09T07:33:09+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/geforce-now/","title":"我的Macbook M1 Pro，使用Geforce Now遊玩Steam遊戲(Counter-Strike 2)"},{"content":"紀錄一下，為什麼要購買此課程，很久以前，就有這樣的目標，想要將英文這門語言學好， 礙於工作轉職、人生待辦事項優先順序，所以一直遲遲沒有開始。\n近期是在學習程式語言python與django，想要將工作更有效率的完成(辦公自動化)與管理平台化(網頁點一點完成需求)，陸陸續續學習了快一年了，開始覺得不是我的興趣，也常常會提不起勁繼續學習，或許是沒有能大量應用上的環境，變的學習時感覺很孤單、很無趣，也跟著導致我連生活也提不起勁，因為會覺得，有很多資料要看、要練習，但是要看、要練習時，就又會覺得提不起勁，就在這樣的心態上拉扯，也就因為這樣，導致生活和精神也越來越疲憊。\n因為上述的狀況，讓我心態有所轉變，人生還那麼長，還有很多事情等著我去探險與嘗試，於是就將人生待辦事項優先順序調整了，從影片去學習語言，讓學習不再那麼枯燥乏味，又能藉由影片瞭解更多新知與世界上發生了什麼事，同時也能讓我藉由這門語言，未來能與世界各地更拉近一點距離。\n我是直接購買12個月，一個月675台幣，無限堂學習，不強求變的多厲害，考什麼多益、雅思，只希望能在未來(1年之後)，遇到外國人，能與之簡單對談(不會害怕)，聽到電影影集，能夠聽懂在說什麼，最後給自己加油打氣，加油我一定行，堅持下去。\n現在夜深了，其實也該睡了。\n","date":"2023-10-09T01:37:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/voicetube-hero-learn-english-lesson000/","title":"我開始使用VoiceTube-Hero學習英文"},{"content":"\n分享我自己平常使用剪映這個軟體，影片快速上字幕及冗言、停頓刪除。\nYouTube教學影片 ","date":"2023-10-08T12:38:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/capcut/","title":"剪映 - 影片快速上字幕及冗言、停頓刪除"},{"content":"今日大綱 Ansible自動化安裝Redis、Redis-Sentinel服務 Gitlab redis-config設定檔管理 創建project 將設定檔傳入 Ansible佈屬腳本撰寫 Jenkins Free-Style專案建立 創建Free-Style軟體專案 參數化構建 原始碼管理 Build Steps: Invoke Ansible Playbook 建置測試 Ansible自動化安裝Redis、Redis-Sentinel服務 # ansible佈屬腳本目錄 [root@ansible ansible]# ll 總計 24 -rw-r--r--. 1 root root 12593 9月 11 22:52 hosts drwxr-xr-x. 33 root root 4096 9月 12 21:05 roles -rw-r--r--. 1 root root 2091 9月 11 22:38 site.yml # 主機清單 [root@ansible ansible]# cat hosts [redis] 192.168.1.11 ansible_nodename=redis01 192.168.1.12 ansible_nodename=redis02 192.168.1.13 ansible_nodename=redis03 192.168.1.14 ansible_nodename=redis04 # 選擇要佈屬的主機和角色，使用become: yes(sudo su -) [root@ansible ansible]# cat site.yml - hosts: redis remote_user: root gather_facts: false become: yes roles: - roles/redis # 要佈屬的任務腳本 [root@ansible ansible]# cat roles/redis/tasks/main.yml # 執行佈屬 [root@ansible ansible]# ansible-playbook -i hosts site.yml --ask-pass PLAY RECAP ******************************************************************************************************************* 192.168.1.11 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.12 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.13 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 192.168.1.14 : ok=46 changed=45 unreachable=0 failed=0 skipped=0 rescued=0 ignored=2 Gitlab redis-config設定檔管理 1. 創建project 2. 將設定檔傳入 # 使用已存在目錄的方式，將設定檔傳入 # 當前目錄 chenqingze@chenqingze-MBP redis-config-test % ll total 0 drwxr-xr-x@ 5 chenqingze staff 160 9 12 22:49 batch drwxr-xr-x@ 4 chenqingze staff 128 9 12 22:44 t1zone drwxr-xr-x@ 4 chenqingze staff 128 9 12 22:45 t2zone # 傳入gitlab chenqingze@chenqingze-MBP redis-config-test % git init Initialized empty Git repository in /Users/chenqingze/Desktop/redis-config-test/redis-config-test/.git/ chenqingze@chenqingze-MBP redis-config-test % git remote add origin http://gitlab.jimmyhome.tw/root/redis-config-test.git chenqingze@chenqingze-MBP redis-config-test % git add . chenqingze@chenqingze-MBP redis-config-test % git commit -m \u0026#34;Initial commit\u0026#34; chenqingze@chenqingze-MBP redis-config-test % git branch -m main master chenqingze@chenqingze-MBP redis-config-test % git push -u origin master Enumerating objects: 19, done. Counting objects: 100% (19/19), done. Delta compression using up to 10 threads Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 45.79 KiB | 7.63 MiB/s, done. Total 19 (delta 6), reused 0 (delta 0), pack-reused 0 To http://gitlab.jimmyhome.tw/root/redis-config-test.git * [new branch] master -\u0026gt; master branch \u0026#39;master\u0026#39; set up to track \u0026#39;origin/master\u0026#39;. redis-sentinel.conf -\u0026gt; redis-sentinel設定檔 redis.conf -\u0026gt; redis設定檔 sentinel-users.acl -\u0026gt; redis-sentinel的acl設定檔 users.acl -\u0026gt; redis的acl設定檔 Ansible佈屬腳本撰寫 1. 變數定義與獲取、判斷輸入選項(Jenkins本地端操作) 1. 獲取項目的工作目錄 {{ workspace.stdout }} 2. 確認function是否沒有選擇，沒有選擇，報錯終止流程 3. 確認masterip不能沒有輸入，沒有輸入，報錯終止流程 4. 確認masterip只能一個，一個以上則報錯，報錯終止流程 5. 確認slaveip不能沒有輸入，沒有輸入，報錯終止流程 2. masterip開始流程 0. 確認Redis服務是否活著，活著的話，報錯終止流程 0. 確認Redis-Sentinel服務是否活著，活著的話，報錯終止流程 1. 拷貝檔案至遠端主機 2. 替換redis-sentinel.conf配置文件，將masterip寫入 3. slaveip開始流程 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 1. 拷貝檔案至遠端主機 2. 替換redis-sentinel.conf配置文件，將masterip寫入 3. 將slaveof masterip 6379寫入redis.conf配置文件 4. all開始流程 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 1. 啟動，開機自啟動redis服務 2. 確認Redis服務是否正常啟動，不啟動的話，報錯終止流程 3. 啟動，開機自啟動redis-sentinel服務 4. 確認Redis-Sentinel服務是否正常啟動，不啟動的話，報錯終止流程 redis-sentinel剛啟動連接，需要一點時間偵測，所以流程暫停5秒 5. 查看Redis-Sentinel狀態連接狀態(/usr/local/bin/redis-cli -p 26379 info | grep -i {{ function }}) [root@ansible ansible]# cat se_redis-config-test_deploy.yml ##################變數定義與獲取、判斷輸入選項(Jenkins本地端操作)################### - hosts: all gather_facts: no tasks: # 1. 獲取項目的工作目錄 {{ workspace.stdout }} - name: Get WorkSpace Work Path shell: cmd: \u0026#34;echo ${WORKSPACE}\u0026#34; register: workspace delegate_to: 127.0.0.1 # 2. 確認function是否沒有選擇，沒有選擇，報錯終止流程 - name: Check Function Choice shell: cmd: \u0026#34;echo {{ function }} | wc -w\u0026#34; register: is_function delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_function.stdout\u0026#34; # 3. 確認masterip不能沒有輸入，沒有輸入，報錯終止流程 - name: Check Masterip Input shell: cmd: \u0026#34;echo {{ masterip }} | wc -w\u0026#34; register: is_masterip delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_masterip.stdout\u0026#34; # 4. 確認masterip只能一個，一個以上則報錯，報錯終止流程 - name: Check Masterip Count shell: cmd: \u0026#34;echo -e \u0026#39;{{ masterip }}\u0026#39; | wc -l\u0026#34; register: is_masterip delegate_to: 127.0.0.1 failed_when: \u0026#34;is_masterip.stdout \u0026gt; \u0026#39;1\u0026#39;\u0026#34; # 5. 確認slaveip不能沒有輸入，沒有輸入，報錯終止流程 - name: Check Slaveip Input shell: cmd: \u0026#34;echo {{ slaveip }} | wc -w\u0026#34; register: is_slaveip delegate_to: 127.0.0.1 failed_when: \u0026#34;\u0026#39;0\u0026#39; == is_slaveip.stdout\u0026#34; ################################masterip開始流程################################### - hosts: \u0026#34;{{ masterip }}\u0026#34; gather_facts: no tasks: # 0. 確認Redis服務是否活著，活著的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否活著，活著的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 拷貝檔案至遠端主機 - name: Copy Filepath To Remote Server copy: src: \u0026#34;{{ workspace.stdout }}/{{ zone }}/{{ function }}/\u0026#34; dest: \u0026#34;/usr/local/redis/\u0026#34; owner: redis group: redis mode: \u0026#39;0644\u0026#39; # 2. 替換redis-sentinel.conf配置文件，將masterip寫入 - name: Replace Masterip To redis-sentinel.conf shell: \u0026#34;sed -i \u0026#39;s/o.o.o.o/{{ masterip }}/g\u0026#39; /usr/local/redis/redis-sentinel.conf\u0026#34; ################################slaveip開始流程################################### - hosts: \u0026#34;{{ slaveip }}\u0026#34; gather_facts: no tasks: # 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 拷貝檔案至遠端主機 - name: Copy Filepath To Remote Server copy: src: \u0026#34;{{ workspace.stdout }}/{{ zone }}/{{ function }}/\u0026#34; dest: \u0026#34;/usr/local/redis/\u0026#34; owner: redis group: redis mode: \u0026#39;0644\u0026#39; # 2. 替換redis-sentinel.conf配置文件，將masterip寫入 - name: Replace Masterip To redis-sentinel.conf shell: \u0026#34;sed -i \u0026#39;s/o.o.o.o/{{ masterip }}/g\u0026#39; /usr/local/redis/redis-sentinel.conf\u0026#34; # 3. 將slaveof masterip 6379寫入redis.conf配置文件 - name: Add Slaveof To redis.conf blockinfile: path: /usr/local/redis/redis.conf block: | slaveof {{ masterip }} 6379 ##################################all開始流程##################################### - hosts: all gather_facts: no tasks: # 0. 確認Redis服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 0. 確認Redis-Sentinel服務是否啟動，啟動的話，報錯終止流程 - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;active\u0026#39; == command_result.stdout\u0026#34; # 1. 啟動，開機自啟動redis服務 # 2. 確認Redis服務是否正常啟動，不啟動的話，報錯終止流程 - name: Enabled、Started Redis systemd: name: redis enabled: true state: started - name: Check Redis Service command: /usr/bin/systemctl is-active redis register: command_result failed_when: \u0026#34;\u0026#39;failed\u0026#39; in command_result.stdout or \u0026#39;unknown\u0026#39; in command_result.stdout or \u0026#39;inactive\u0026#39; in command_result.stdout\u0026#34; # 3. 啟動，開機自啟動redis-sentinel服務 # 4. 確認Redis-Sentinel服務是否正常啟動，不啟動的話，報錯終止流程 - name: Enabled、Started Redis-Sentinel systemd: name: redis-sentinel enabled: true state: started - name: Check Redis-Sentinel Service command: /usr/bin/systemctl is-active redis-sentinel register: command_result failed_when: \u0026#34;\u0026#39;failed\u0026#39; in command_result.stdout or \u0026#39;unknown\u0026#39; in command_result.stdout or \u0026#39;inactive\u0026#39; in command_result.stdout\u0026#34; # redis-sentinel剛啟動連接，需要一點時間偵測，所以流程暫停5秒 - name: Pause for 5 seconds to build app cache pause: seconds: 5 # 5. 查看Redis-Sentinel狀態連接狀態(/usr/local/bin/redis-cli -p 26379 info | grep -i web-front) - name: Check Redis-Sentinel info shell: \u0026#34;/usr/local/bin/redis-cli -p 26379 info | grep -i {{ function }}\u0026#34; register: \u0026#34;command_result\u0026#34; args: warn: no ignore_errors: True - name: Runcommand Redis-Sentinel info Msg debug: msg: \u0026#34;{{ command_result.stdout_lines }}\u0026#34; ignore_errors: True Jenkins Free-Style專案建立 1. 創建Free-Style軟體專案 2. 參數化構建 Active Choices Parameter Active Choices Reactive Parameter 文字參數 文字參數 使用ansible這台主機來跑佈屬流程 3. 原始碼管理 原始碼管理(連接Gitlab) ##### Gitlab複製下來的clone http://gitlab.jimmyhome.tw/root/redis-config-test.git ##### Credential 連接gitlab帳號和密碼 4. Build Steps: Invoke Ansible Playbook Invoke Ansible Playbook ##### ansible腳本位置 Playbook path: /root/ansible/se_redis-config-test_deploy.yml ##### Inventory主機IP 以下撰寫方式，ip都會傳入 連接要佈屬的主機，使用帳號，我這裡用key， 所以我有從ansible主機，產生key，ssh-copy-id 要佈屬的主機 [root@ansible ~]# ssh-copy-id 192.168.1.11 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026#34;/root/.ssh/id_rsa.pub\u0026#34; /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys root@192.168.1.11\u0026#39;s password: Number of key(s) added: 1 Now try logging into the machine, with: \u0026#34;ssh \u0026#39;192.168.1.11\u0026#39;\u0026#34; and check to make sure that only the key(s) you wanted were added. [root@ansible ~]# ssh-copy-id 192.168.1.12 [root@ansible ~]# ssh-copy-id 192.168.1.13 [root@ansible ~]# ssh-copy-id 192.168.1.14 Jenkins參數，要傳入ansible內 Extra Variables 5. 建置測試 可以看到，zone選擇，function也會跟著變動 輸入IP處，slaveip可以輸入多個 可以看到，redis-sentinel已經成功啟動，有偵測到目前master是誰，也偵測到slaves主機有3台，總共4台主機啟動sentinel服務 進redis主機直接確認，使用redis-cli登入，選擇index 1， set 1個key為test value為1 get key test，value為1 [root@redis01 redis]# redis-cli 127.0.0.1:6379\u0026gt; select 1 OK 127.0.0.1:6379[1]\u0026gt; set test 1 OK 127.0.0.1:6379[1]\u0026gt; get test \u0026#34;1\u0026#34; [root@redis01 redis]# redis-cli -p 26379 master0:name=search,status=ok,address=192.168.1.11:6379,slaves=3,sentinels=4 可以看到，如果再次佈屬，會顯示失敗，因為主機redis和redis-sentinel服務如果是active狀態，就不能佈屬(腳本一開始就有添加此段）， 防止輸入IP輸錯，導致設定檔覆蓋，營運中的redis服務異常 YouTube教學影片 ","date":"2023-10-08T11:49:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/devops-jenkins-gitlab-ansible-redis/","title":"Jenkins+Gitlab+Ansible 版控與佈屬 Redis Redis-Sentinel集群"},{"content":"基本數據類型之布爾值bool 1.用來判斷事物的對錯 是否可行 只要用於流程控制中 2.只有兩種狀態 True 對的 真的 可行的 False 錯的 假的 不可行的 3.python中所有數據都自帶布爾值 布爾值為False的數據有：0 None \u0026#39;\u0026#39; [] {} 布爾值為True的數據有：除了上面的都是True 4.存儲布爾值的變數名一般推薦使用is開頭 is_delete = False is_alive = True \u0026#34;\u0026#34;\u0026#34; 很多程式中提供的註銷帳戶的功能 其實底層並沒有刪除數據 而是修改了數據的狀態 id username password phone is_delete 1 jimmy 123 110 1 2 kevin 321 120 0 \u0026#34;\u0026#34;\u0026#34; EX： 基本數據類型之元組tuple 1.也稱為『不可變』的列表 元組內索引綁定的記憶體位址不能修改 2.小括弧括起來 內部存放多個數據值 數據值與數據值之間逗號隔開 數據值可以是任何數據類型 3.代碼實現 t1 = (11, 22, \u0026#39;jimmy\u0026#39;) 4.元組與列表的對比 # 列表 l1 = [11, 22, 33] print(l1[0]) # 獲取索引0對應的數據值 l1[0] = 666 print(l1) # [666, 22, 33] # 元組 t1 = (11, 22, 33) print(t1[0]) t1[0] = 999 print(t1) # 報錯 # 練習題 元組混列表 t1 = (11, 22, [111, 222]) t1[2][1] = 666 print(t1) # (11, 22, [111, 666]) \u0026#34;\u0026#34;\u0026#34; A.直接報錯 B.(11, 22, [111, 666]) C.不知道 超出了我的認知 \u0026#34;\u0026#34;\u0026#34; 5.元組內如果只有一個數據值 t1 = (1) t2 = (11.11) t3 = (\u0026#39;Jimmy\u0026#39;) print(type(t1), type(t2), type(t3)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; t1 = (1,) t2 = (11.11,) t3 = (\u0026#39;Jimmy\u0026#39;,) print(type(t1), type(t2), type(t3)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; \u0026#34;\u0026#34;\u0026#34; 建議：以後在使用可以存放多個數據值的數據類型時 如果裡面暫時只有一個數據值 那麼也建議你加上逗號 \u0026#34;\u0026#34;\u0026#34; EX1：元組與列表的對比\n列表： 圖解： 元組： 圖解： EX2：練習題 元組混列表 圖解：\nEX3：元組內如果只有一個數據值\n基本數據類型之集合set 1.集合只能用於去重和關係運算 後面再講 暫且忽略 2.集合內數據只能是不可變類型 後面再講 暫且忽略 3.大括弧括起來 內部存放多個數據值 數據值與數據值之間逗號隔開 數據值不是k：v鍵值對 4.代碼實現 s1 = {1, 2, 3, 4, 5, 6} 5.定義空集合與空字典 {} 預設是字典 set() 定義空集合 EX1：定義空集合\n與使用者交互 1.獲取使用者輸入 input # 獲取使用者輸入 username = input(\u0026#39;請輸入您的使用者名\u0026gt;\u0026gt;\u0026gt;：\u0026#39;) \u0026#34;\u0026#34;\u0026#34; 1.先執行input獲取用戶輸入 2.將輸入的數據綁定給變數名username 3.以後在程式中就可以使用變數名反覆調用用戶數據 \u0026#34;\u0026#34;\u0026#34; 強調：input獲取到的數據都會統一處理成字串類型 2.輸出內部資訊 print 1.括弧內既可以放數據值也可以放變數名 並且支援多個 逗號隔開即可 2.print自帶換行符 換行符：\\r\\n \\n(斜杠與字母組合到一起可能會產生特殊的含義) 3.print也可以切換結束符 print(數據,end=\u0026#39;預設是\\n\u0026#39;) 擴展：python2與python3中兩個關鍵字的區別 python2中 input方法需要使用者自己提前指定數據類型 寫什麼類型就是什麼類型 raw_input方法與python3中input一致 輸入的統一處理成字串 python2中 print方法有兩種使用方式 print 數據值 print(資料值) EX1：1.獲取使用者輸入\nEX2：input獲取到的數據都會統一處理成字串類型\nEX3：輸出內部資訊 EX4：2.print自帶換行符\nEX5：3.print也可以切換結束符 EX6：python2與python3中兩個關鍵字的區別\npython2\ninput方法需要使用者自己提前指定數據類型 寫什麼類型就是什麼類型 raw_input方法與python3中input一致 輸入的統一處理成字串 python2\nprint方法有兩種使用方式 print 數據值 print(資料值) 格式化輸出 提前定義好一些內容 將來需要使用的時候可以局部修改 代碼實現 在現實生活中大部分情況下使用下劃線提示別人填寫內容 但是在程式中需要使用佔位元：%s %d info = \u0026#39;%s同學你好\u0026#39; \u0026#39;\u0026#39;\u0026#39;單個佔位符\u0026#39;\u0026#39;\u0026#39; # print(info % \u0026#39;Jimmy\u0026#39;) # Jimmy同學你好 # print(\u0026#39;%s同學你好\u0026#39; % \u0026#39;Tony\u0026#39;) # Tony同學你好 # print(info % (\u0026#39;Jimmy\u0026#39;,)) # print(\u0026#39;%s同學你好\u0026#39; % (\u0026#39;Tony\u0026#39;,)) \u0026#39;\u0026#39;\u0026#39;多個佔位符\u0026#39;\u0026#39;\u0026#39; # desc = \u0026#39;姓名：%s 年齡：%s 愛好：%s\u0026#39; # print(desc % (\u0026#39;Jimmy\u0026#39;, 18, \u0026#39;read\u0026#39;)) # print(\u0026#39;姓名：%s 年齡：%s 愛好：%s\u0026#39; % (\u0026#39;tony\u0026#39;, 28, \u0026#39;rap\u0026#39;)) \u0026#39;\u0026#39;\u0026#39;注意事項：有幾個佔位符就需要幾個數據值\u0026#39;\u0026#39;\u0026#39; # print(\u0026#39;my name is %s my age is %s\u0026#39; % (\u0026#39;Jimmy\u0026#39;,)) # 少了不行 # print(\u0026#39;my name is %s my age is %s\u0026#39; % (\u0026#39;Jimmy\u0026#39;, 18, \u0026#39;read\u0026#39;)) # 多了不行 \u0026#39;\u0026#39;\u0026#39;不同佔位符的區別\u0026#39;\u0026#39;\u0026#39; # demo1 = \u0026#39;%s您好 您本月的話費是%s 餘額是%s\u0026#39; # %s常見數據類型都支援 # print(demo1 % (\u0026#39;Jimmy\u0026#39;, 100, 10000000000000)) # demo2 = \u0026#39;%d您好 您本月的話費是%d 餘額是%d\u0026#39; # %d只支援數字類型 # print(demo2 % (\u0026#39;tony\u0026#39;, 1000000000, -100000)) print(\u0026#39;%08d\u0026#39;% 123) # 00000123 print(\u0026#39;%08d\u0026#39;% 1234324324) # 1234324324 EX1：單個佔位符 EX2：多個佔位符\nEX3：注意事項：有幾個佔位符就需要幾個數據值\nEX4：不同佔位符的區別\n%s常見數據類型都支援 %d只支援數字類型 EX5：%d補位功能 基本運算符 以下假設變數： a=10，b=20：\n運算符 描述 實例 + 加 - 兩個物件相加 a + b 輸出結果 30 - 減 - 得到負數或是一個數減去另一個數 a - b 輸出結果 -10 * 乘 - 兩個數相乘或是返回一個被重複若干次的字串 a * b 輸出結果 200 / 除 - x除以y b / a 輸出結果 2 % 取餘 - 返回除法的餘數 b % a 输出结果 0 ** 次方 - 返回x的y次方 a**b 為10的20次方， 輸出結果 100000000000000000000 // 取整除 - 傳回商的整數部分（向下取整） \u0026raquo;\u0026gt;9//2 4, \u0026raquo;\u0026gt;-9//2 -5 1.數學運算符 + - * / % // ** 簡化寫法 n = 10 n += 1 # n = n + 1 n -= 1 # n = n - 1 n *= 1 # n = n * 1 n /= 1 # n = n / 1 n %= 1 # n = n % 1 n //= 1 # n = n // 1 n **= 1 # n = n ** 1 2.比較運算符 \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= ==(等於號) !=(不等於) 常用賦值符 1.鏈式賦值 # name = \u0026#39;jimmy\u0026#39; # name1 = name # name2 = name # 鏈式賦值 name = name1 = name2 = \u0026#39;jimmy\u0026#39; 2.交叉賦值 m = 100 n = 999 \u0026#39;\u0026#39;\u0026#39;讓m和n互相轉換綁定的值\u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34;奇葩式寫法\u0026#34;\u0026#34;\u0026#34; # m = n # n = m # print(m, n) # 999 999 \u0026#39;\u0026#39;\u0026#39;方式1:採用中間變數\u0026#39;\u0026#39;\u0026#39; # temp = m # m = n # n = temp # print(m, n) # 999 100 \u0026#39;\u0026#39;\u0026#39;方式2:交叉賦值語法\u0026#39;\u0026#39;\u0026#39; m, n = n, m print(m, n) # 999 100 3.解壓賦值 name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] \u0026#39;\u0026#39;\u0026#39;low的寫法\u0026#39;\u0026#39;\u0026#39; # name1 = name_list[0] # name2 = name_list[1] # name3 = name_list[2] # name4 = name_list[3] \u0026#39;\u0026#39;\u0026#39;解壓賦值語法\u0026#39;\u0026#39;\u0026#39; # name1, name2, name3, name4 = name_list \u0026#39;\u0026#39;\u0026#39;解壓賦值在使用的時候 正常情況下需要保證左邊的變數名與右邊的數據值個數一致\u0026#39;\u0026#39;\u0026#39; # a, b = name_list # 變數名少了不行 # a, b, c, d, e = name_list # 變數名多了也不行 \u0026#39;\u0026#39;\u0026#39;當需要解壓的數據個數特別多 並且我們只需要使用其中的幾個 那麼可以打破上述的規則\u0026#39;\u0026#39;\u0026#39; # a, *b = name_list # *會自動接收多餘的數據 組織成列表賦值給後面的變數名 # print(a) # jimmy # print(b) # [\u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] # a, c, *b = name_list # print(a) # print(c) # print(b) # [\u0026#39;tony\u0026#39;, \u0026#39;oscar\u0026#39;] # a, *b, c = name_list # print(a) # jimmy # print(b) # [\u0026#39;kevin\u0026#39;, \u0026#39;tony\u0026#39;] # print(c) # oscar \u0026#39;\u0026#39;\u0026#39;當數據值不準備使用的時候 可以使用下劃線作為變數名綁定\u0026#39;\u0026#39;\u0026#39; a, *_, c = name_list EX1：1.鏈式賦值 EX2：2.交叉賦值\n奇葩式寫法： 圖解： 方式1:採用中間變數：\n圖解：\n方式2:交叉賦值語法：\nEX3：3.解壓賦值\n解壓賦值在使用的時候 正常情況下需要保證左邊的變數名與右邊的數據值個數一致 變數名少了不行 變數名多了也不行 當需要解壓的數據個數特別多 並且我們只需要使用其中的幾個 那麼可以打破上述的規則 *會自動接收多餘的數據 組織成列表賦值給後面的變數名 當數據值不準備使用的時候 可以使用下劃線作為變數名綁定 邏輯運算符 \u0026#39;\u0026#39;\u0026#39;主要配合條件一起使用\u0026#39;\u0026#39;\u0026#39; and 與 and連接的多個條件必須全部成立 結果才成立 1 \u0026gt; 2 and 4 \u0026lt; 8 and 10 \u0026lt; 1 and 1 == 2 如果條件中全部由and組成那麼判斷起來非常的簡單 只要發現一個不成立 結果就不成立 print(1 \u0026lt; 10 and 666) # 666 成立 print(1 \u0026lt; 10 and 2 \u0026lt; 8) # True 成立 print(111 and 222) # 222 成立 如果需要你準確的說出具體的結果值 那麼需要按照下列方式 如果and左邊的條件是成立的 那麼就完全取決於右邊的條件 右邊如果直接是數據值 那麼結果就是該數據值 如果是含有表達式 則為布爾值 or 或 or連接的多個條件只要有一個成立 結果就成立 1 \u0026gt; 2 or 4 \u0026lt; 8 or 10 \u0026lt; 1 or 1 == 2 如果條件中全部由or組成那麼判斷起來非常的簡單 只要發現一個成立 結果就成立 # print(1 \u0026lt; 10 or 666) # True # print(666 or 1 \u0026gt; 10) # 666 print(0 or False) # False print(0 or 111) # 111 規律用and not 非 取反 類似於說反話 print(not 1) # False print(not 0) # True \u0026#34;\u0026#34;\u0026#34; 三者混合使用的時候有優先順序之分 但是我們不需要記憶優先順序 應該通過代碼的形式提前規定好優先順序 eg: 先乘除後加減 但是可以使用括弧來改變優先順序 (3\u0026gt;4 and 4\u0026gt;3) or ((1==3 and \u0026#39;x\u0026#39; == \u0026#39;x\u0026#39;) or 3 \u0026gt;3) \u0026#34;\u0026#34;\u0026#34; EX1：and\nEX2：or\nEX3：not\n三者混合使用的時候有優先順序之分 但是我們不需要記憶優先順序 應該通過代碼的形式提前規定好優先順序 成員運算符 判斷個體在不在群體內 # name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;oscar\u0026#39;, \u0026#39;jerry\u0026#39;] # print(\u0026#39;tony\u0026#39; in name_list) # False # print(\u0026#39;tony\u0026#39; not in name_list) # True # print(\u0026#39;j\u0026#39; in name_list) # False 列表最小單位是數據值 不能再細分 # s1 = \u0026#39;hello world\u0026#39; # print(\u0026#39;d\u0026#39; in s1) # 字串最小單位是單個單個的字元 d1 = { \u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;pwd\u0026#39;: 123 } print(\u0026#39;jimmy\u0026#39; in d1) # False 字典成員運算只有鍵參與 print(\u0026#39;username\u0026#39; in d1) # True \u0026#39;username\u0026#39; \u0026#39;pwd\u0026#39; EX1：成員運算符\n列表 字串 字典 身份運算符 \u0026#34;\u0026#34;\u0026#34; id() 返回一串數字 該數字可以看成是記憶體位址 \u0026#34;\u0026#34;\u0026#34; is 判斷記憶體位址是否相同 == 判斷數據值是否相同 # l1 = [11, 22, 33, 44, 55, 66, 77, 88] # l2 = [11, 22, 33, 44, 55, 66, 77, 88] # print(l1 == l2) # True # print(id(l1)) # print(id(l2)) # print(l1 is l2) # False # 小整數池 i1 = 11 i2 = 11 print(i1 is i2) s1 = \u0026#39;jason jason jason\u0026#39; s2 = \u0026#39;jason jason jason\u0026#39; print(s1 is s2) 不同的環境下可能優化的程度不一樣 \u0026#34;\u0026#34;\u0026#34; 了解 值相同 内存地址可能不同 内存地址相同 值肯定相同 \u0026#34;\u0026#34;\u0026#34; EX1：身份運算符\nis 判斷記憶體位址是否相同 == 判斷數據值是否相同 EX2：不同的環境下可能優化的程度不一樣\npycharm有額外做優化和解釋器出來結果不一樣\n練習題 1.獲取使用者輸入並列印成下列格式 ------------ info of Jimmy ----------- Name : Jimmy Age : 18 Job : Teacher ---------------- end ----------------- # 1.先制定一個列印的範本 info_demo = \u0026#34;\u0026#34;\u0026#34; ------------ info of %s ------------- Name : %s Age : %s Job : %s ---------------- end ----------------- \u0026#34;\u0026#34;\u0026#34; # 2.獲取用戶輸入 username = input(\u0026#39;username\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) age = input(\u0026#39;age\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) job = input(\u0026#39;job\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) # 3.格式化輸出 print(info_demo % (username, username, age, job)) 2.下列變數名v綁定的結果 v1 = 1 or 3 # 1 v2 = 1 and 3 # 3 v3 = 0 and 2 and 1 # 0 v4 = 0 and 2 or 1 # 1 沒寫執行順序，是not-\u0026gt;and-\u0026gt;or v5 = 0 and 2 or 1 or 4 # 1 沒寫執行順序，是not-\u0026gt;and-\u0026gt;or v6 = 0 or False and 1 # False EX1：1.獲取使用者輸入並列印成下列格式\nEX2：2.下列變數名v綁定的結果\n","date":"2023-10-07T03:02:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day04/","title":"Day04 - 基本數據類型(bool、tuple、set)，與使用者交互，格式化輸出，基本運算符，常用賦值符，邏輯運算符，成員運算符，身份運算符，練習題"},{"content":"pycharm下載與使用 1.該軟體分為收費版和免費版 免費版功能太少(community) 我們盡量使用收費版(professional) 30天試用 2.pycharm比較笨重 本身占據的資源較多 並且保持運行的情況下需要消耗計算機1GB多的資源 3.文件後綴名 儲存python代碼的文件後綴名一般叫.py 4.如何創建py文件 使用pycharm創建的py文件在編寫程式碼的時候有自動提示 tab補全 方向鍵選擇 5.配置調整 字體大小 編程背景 解釋器選擇 6.運行python代碼 Pycharm官網下載網址： https://www.jetbrains.com/pycharm/download/?section=mac\nMAC版安裝： 下載最新版Pycharm 下載其他版本，我電腦是mac m1晶片 拖曳過去Applications檔案夾即可 需要licenses授權，因為我是有購買的，所以我採取登入JB帳號，即可使用 windows版安裝： Next 目錄選擇簡單一點的名稱，方便後續查找 安裝後，桌面會一個PyCharm的icon捷徑 回到我的MAC電腦，創建項目 1. 處建項目 2. Location要填寫、解釋器選擇，先不要用虛擬環境 3. 儲存python代碼的文件後綴名一般叫.py 項目創建的資料，就會看到上面創建的.py文件 4. 使用pycharm創建的py文件在編寫程式碼的時候有自動提示 tab補全 方向鍵選擇 5. 配置調整 字體 背景，我習慣用白的，這裡再依各位個人喜好去修改 可以看到選擇Darcula，視窗就變暗色系了 如果pycharm無法找到python解釋器，可以再來這裡再設定 有新安裝版本，也能從旁右方齒輪按鍵，去新增 6.運行python代碼 代碼行處，右鍵，即可執行此當下這個.py文件代碼 或者視窗右上面，也能執行 python語法之注釋 1.什麼是注釋 注釋其實就是對一段代碼的解釋說明 2.如何編寫注釋 方式1:解釋說明文字前加警號 pycharm中有快捷鍵 ctrl + / mac電腦，用 command + / # 注釋(單行注釋) 方式2:鍵盤enter鍵左邊那個鍵英文輸入法下連續按三下 \u0026#39;\u0026#39;\u0026#39; 多行注釋 \u0026#39;\u0026#39;\u0026#39; 方式3:鍵盤enter鍵左邊那個鍵英文輸入法下+shift 連續按三下 \u0026#34;\u0026#34;\u0026#34; 多行注釋 \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;hello world\u0026#39;) #1. 這是列印數據方式，單行註釋 # print(\u0026#39;hello world\u0026#39;) # Prcharm快捷鍵，command + /(右邊shift左邊那個鍵) \u0026#39;\u0026#39;\u0026#39; 2. 多行註釋: 大家好，我是翻轉吧金魚腦 \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 3. 多行註釋: 哈摟，我是翻轉吧金魚腦 \u0026#34;\u0026#34;\u0026#34; PEP8規範 \u0026#34;\u0026#34;\u0026#34; pycharm中很多時候會有各種顏色提示還有波浪線 只要不是紅線一般都不影響代碼運行 \u0026#34;\u0026#34;\u0026#34; python代碼編寫規範 1.單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 2.如果單行注釋自成一行 那麼內容與警號空一格 ps:如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 EX1: 單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 EX2: 如果單行注釋自成一行 那麼內容與警號空一格 EX3: 如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 變數與常量 變數與常量就是為了讓程序具備人記錄事物狀態的能力 1.什麼是變數? 記錄變化(可能會經常改變)的事物狀態 eg:年齡 容貌 薪資 2.什麼是常量? 記錄固定(可能不經常改變)的事物狀態 eg:圓周率 重力加速度 變數的基本使用 日常生活中的變數案例 翻轉吧金魚腦 姓名叫jimmy 年齡是20 性別是男性 代碼中如何記錄事物狀態 name = \u0026#39;jimmy\u0026#39; age = 20 gender = \u0026#39;male\u0026#39; 變數使用的語法結構與底層原理 \u0026#34;\u0026#34;\u0026#34; name = \u0026#39;jimmy\u0026#39; 變數名 賦值符號 數據值 1.一旦看到賦值符號 那麼一定先看符號的右側 2.在記憶體空間中申請一塊記憶體空間儲存數據值 3.給數據值綁定一個變數名 4.以後就可以通過變數名訪問到數據值 \u0026#34;\u0026#34;\u0026#34; 注意事項: 1.同一個數據值可以綁定多個變數名 2.賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值 3.一個變數名同一時間只能綁定一個數據值 name = \u0026#39;jimmy\u0026#39; name1 = name name2 = name1 x = 10 x = x + 1 print(x) 1. 日常生活中的變數案例 2. 變數使用的語法結構與底層原理 \u0026#34;\u0026#34;\u0026#34; name = \u0026#39;jimmy\u0026#39; 變數名 賦值符號 數據值 1.一旦看到賦值符號 那麼一定先看符號的右側 2.在記憶體空間中申請一塊記憶體空間儲存數據值 3.給數據值綁定一個變數名 4.以後就可以通過變數名訪問到數據值 \u0026#34;\u0026#34;\u0026#34; EX1: 變數名 賦值符號 數據值 注意事項: 1. 同一個數據值可以綁定多個變數名 2.賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值 3.一個變數名同一時間只能綁定一個數據值 EX1: 一個數據值可以綁定多個變數名(賦值符號也可能是變數名 如果是就先找該變數名綁定的數據值) EX2: 一個變數名同一時間只能綁定一個數據值 3. 變數名的命名規範 變數名的命名規範 1.中文是可以用作變數名的 但是不建議使用 並且容易報錯 2.變數名只能出現字母、數字、下劃線 3.數字不能開頭 4.變數名盡量做到見名知意 5.變數名不能與關鍵字衝突 EX1: 中文是可以用作變數名的 但是不建議使用 並且容易報錯 EX2: 變數名只能出現字母、數字、下劃線、數字不能開頭 EX3: 見名之意 EX4: 關鍵字 4. 變數名的命名風格 變數名的命名風格 1.下劃線式 python推薦使用 變數名中單字很多 彼此使用下劃線隔開 name_from_mysql_db1_userinfo = \u0026#39;jimmy\u0026#39; 2.駝峰體式 JS推薦使用 大駝峰 NameFromMysqlDb1Userinfo = \u0026#39;jimmy\u0026#39; 小駝峰 nameFromMysqlDb1Userinfo = \u0026#39;jimmy\u0026#39; ps:在同一個程式語言中盡量固定使用一種 不要隨意切換 EX1: 下劃線式 (變數名中單字很多 彼此使用下劃線隔開)\n常量的基本使用 1.在python沒有真正意義上的常量(定義了就不能改) 定義了可以隨時修改 2.在python中如果想表示出常量 那麼可以使用全大寫的變數名 HOST = \u0026#39;127.0.0.1\u0026#39; ps:除了全大寫之外 其他與變數用法一致 數據類型 1.什麼是數據類型 在日常生活中數據的表現形式多種多樣 在程序中也是如此 2.為何學習數據類型 針對不同的數據採用最佳的數據類型來表示出該數據的價值 3.本次學習數據類型僅僅是了解 只要看到每個數據類型能夠叫出它們的名字以及代碼如何編寫即可 4.學前必會 如何查看數據值的數據類型 type(數據值)\\type(變數名) EX1: 數據類型之整型int 大白話的意思其實就是整數 應用場景:年齡 班級人數 年份 EX1: 數據類型之浮點型float 大白話的意思其實就是小數 應用場景:身高 體重 薪資 EX1: 數據類型之字串str 大白話的意思其實就是文本類型的數據\u0026gt;\u0026gt;\u0026gt;:引號引起來的部分都是字串 應用場景:姓名 地址 愛好 1.定義字串有四種方式 name = \u0026#39;jimmy\u0026#39; name1 = \u0026#34;jimmy\u0026#34; name2 = \u0026#39;\u0026#39;\u0026#39;jimmy\u0026#39;\u0026#39;\u0026#39; name3 = \u0026#34;\u0026#34;\u0026#34;jimmy\u0026#34;\u0026#34;\u0026#34; 2.為什麼定義字串需要有多種方式 我們在字串中編寫文本也可能會使用到引號 為了避免衝突 有了多種方式 info = \u0026#34;jimmy說:\u0026#39;好學\u0026#39;\u0026#34; 3.如何區分三引號是字串還是注釋 關注左側是否含有賦值符號和變數名 如果有則為字串 沒有則為注釋 EX1: 1.定義字串有四種方式 1.定義字串有四種方式 name = \u0026#39;jimmy\u0026#39; name1 = \u0026#34;jimmy\u0026#34; name2 = \u0026#39;\u0026#39;\u0026#39;jimmy\u0026#39;\u0026#39;\u0026#39; name3 = \u0026#34;\u0026#34;\u0026#34;jimmy\u0026#34;\u0026#34;\u0026#34; 2.為什麼定義字串需要有多種方式 我們在字串中編寫文本也可能會使用到引號 為了避免衝突 有了多種方式 info = \u0026#34;jimmy說：\u0026#39;好學\u0026#39;\u0026#34; 3.如何區分三引號是字串還是注釋 關注左側是否含有賦值符號和變數名 如果有則為字串 沒有則為注釋 EX1: EX2: 為什麼定義字串需要有多種方式(為了避免衝突) 數據類型之列表list 大白話的意思其實就是可以儲存多個數據值的類型 並且可以非常方便的取 應用場景:儲存多個數據值 並且將來可能需要單獨取其中一些 代碼實現: name_list = [\u0026#39;jimmy\u0026#39;, \u0026#39;tony\u0026#39;, \u0026#39;kevin\u0026#39;, \u0026#39;oscar\u0026#39;, \u0026#39;jerry\u0026#39;] 1.列表的文字描述 中括號括起來 內部可以存放多個數據值 數據值與數據值之間逗號隔開 數據值可以是任意數據類型 l1 = [11, 11.11, \u0026#39;jimmy\u0026#39;,[11, 22]] 2.索引取值 起始數字是從0開始 l1[索引值] \u0026#34;\u0026#34;\u0026#34; PEP8規範補充 1.逗號後面與數據值空一格 2.賦值符號左右都得空一格 \u0026#34;\u0026#34;\u0026#34; EX1: EX2: 數據類型之字典dict 能夠非常精確的儲存和表達數據值的含義 代碼實現: info_dict = { \u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;hobby\u0026#39;: \u0026#39;coding\u0026#39;, } 1.字典文字描述 大括號括起來 內部可以存放多個數據 數據的組織形式是K:V鍵值對 鍵值對與鍵值對之間逗號隔開 K是對V的描述性性質的資訊(解釋說明) 一般都是字串類型 V是真正的數據值 可以是任意數據類型 2.按K取值 字典只能按K取值 因為字典是無序的 沒有索引的概念 info_dict[\u0026#39;username\u0026#39;] \u0026#34;\u0026#34;\u0026#34; PEP8規範補充 1.字典K:V，:右邊要空一格 \u0026#34;\u0026#34;\u0026#34; EX1:字典 EX2: 按鍵取值 小結 今日PEP8規範 1.單行注釋如果跟在代碼之後 那麼警號與代碼之間需要空兩格 內容與警號空一格 2.如果單行注釋自成一行 那麼內容與警號空一格 3.list 1.逗號後面與數據值空一格 2.賦值符號左右都得空一格 4.dict 1.字典K:V，:右邊要空一格 ps:如何學習規範 可以借助於pycharm自動化格式程式碼反向學習 (mac快捷鍵command+option+L) 練習題(數據類型) # 附加練習題(提示:一步步拆解) # 1.想辦法列印出jimmy l1 = [11, 22, \u0026#39;kevin\u0026#39;, [\u0026#39;tony\u0026#39;, \u0026#39;jerry\u0026#39;, [123, 456, \u0026#39;jimmy\u0026#39;]] ] \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # 1.先看大列表到底有幾個數據值 以及我們想要的數據值在哪個裡面 # print(l1[3]) l2 = l1[3] # [\u0026#39;tony\u0026#39;, \u0026#39;jerry\u0026#39;, [123, 456, \u0026#39;jimmy\u0026#39;]] # 2.再次思考小列表有幾個數據值 以及我們想要的數據值在哪個裡面 # print(l2[2]) l3 = l2[2] # [123, 456, \u0026#39;jimmy\u0026#39;] # 3.最後轉化成了簡單的索引直接取值 print(l3[2]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(l1[3][2][2]) # 2.想辦法列印出大寶貝 d1 = {\u0026#39;name\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;others\u0026#39;: {\u0026#39;a1\u0026#39;: \u0026#39;heiheihei\u0026#39;, \u0026#39;a2\u0026#39;: {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;} } } \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # 1.先拿大字典第二個鍵值對的值 # print(d1[\u0026#39;others\u0026#39;]) d2 = d1[\u0026#39;others\u0026#39;] # {\u0026#39;a1\u0026#39;: \u0026#39;heiheihei\u0026#39;, \u0026#39;a2\u0026#39;: {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;}} # 2.再拿小字典第二個鍵值對的值 # print(d2[\u0026#39;a2\u0026#39;]) d3 = d2[\u0026#39;a2\u0026#39;] # {\u0026#39;k1\u0026#39;: \u0026#39;hahaha\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;hehehe\u0026#39;, \u0026#39;k3\u0026#39;: \u0026#39;大寶貝\u0026#39;} # 3.轉化成簡單的按k直接取值 print(d3[\u0026#39;k3\u0026#39;]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(d1[\u0026#39;others\u0026#39;][\u0026#39;a2\u0026#39;][\u0026#39;k3\u0026#39;]) # 3.想辦法列印出run data = {\u0026#39;username\u0026#39;: \u0026#39;jimmy\u0026#39;, \u0026#39;hobby\u0026#39;: [11, 22, {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39; ] } ] } \u0026#39;\u0026#39;\u0026#39;分步操作\u0026#39;\u0026#39;\u0026#39; # print(data[\u0026#39;hobby\u0026#39;]) data1 = data[\u0026#39;hobby\u0026#39;] # [11, 22, {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;]}] # print(data1[2]) data2 = data1[2] # {\u0026#39;height\u0026#39;: 183, \u0026#39;hobby\u0026#39;: [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;]} # print(data2[\u0026#39;hobby\u0026#39;]) data3 = data2[\u0026#39;hobby\u0026#39;] # [\u0026#39;read\u0026#39;, \u0026#39;run\u0026#39;, \u0026#39;music\u0026#39;] print(data3[1]) \u0026#39;\u0026#39;\u0026#39;簡化操作\u0026#39;\u0026#39;\u0026#39; print(data[\u0026#39;hobby\u0026#39;][2][\u0026#39;hobby\u0026#39;][1]) EX1: 想辦法列印出jimmy EX2: 想辦法列印出大寶貝 EX3: 想辦法列印出run YouTube教學影片 ","date":"2023-10-07T03:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day03/","title":"Day03 - pycharm，註解，PEP8規範，變量與常量，基本數據類型int、float、str、list、dict(初探)，練習題(數據類型)"},{"content":"計算機三大核心硬體 計算機三大核心硬體: 1.CPU 2.記憶體 3.硬碟 為什麼不直接省略記憶體，跟硬碟溝通就好? 1.記憶體的容量一般比硬碟小的多得多 2.CPU運行速度快，硬碟運行速度慢，記憶體搭配CPU運作，提升CPU運行效率 3.只要是運行的程序 產生的數據第一時間肯定在記憶體，突然斷電數據會立刻遺失 操作系統 https://ithelp.ithome.com.tw/upload/images/20230909/20132481mxrUPlFKDC.png\n控制 協調 管理計算機各個硬體的工作 PC端常見操作系統: windows、macOS、linux 行動端常見操作系統: Android、IOS、 程式語言的分類 1.編譯型語言 C++、Java、Golang 類似於GOOGLE翻譯(一次性翻譯) 翻譯之後可以反覆使用翻譯的結果 優勢: 一次翻譯可以反覆使用 執行效率高 速度快 劣勢: 當程序中頻繁出現bug 那麼需要反覆編譯 2.解釋型語言 python 類似於翻譯官(說一句翻一句) 優勢: 有bug和沒有bug執行效率幾乎一樣 劣勢: 速度沒有編譯型語言快 \u0026#39;\u0026#39;\u0026#39;要想讓計算機能夠識別並運行高級語言需要對應類型的翻譯官\u0026#39;\u0026#39;\u0026#39; python解釋器 1.python發展方向 web方向、自動化運維、自動化測試、自動化辦公、網路爬蟲、金融量化、人工智慧、機器學習、數據分析 2.python解釋器 1.歷史 荷蘭的Guido van Rossum因為當時的程式語言存在缺陷，聖誕節期間，他決定創建一種新的語言。一種更易於使用又功能強大的語言。 2.版本 版本其實是軟體更新疊代的紀錄 python1.X:初期版本 幾乎不用 python2.X:python2.7(2020年就已經不再維護更新) python3.X:python3.6 python3.8 python3.10+ ps:學習python語法 對版本的區別差異不大 目前常用:python2.7 python3.6 python3.8 3.下載 官網:https://www.python.org/downloads/windows/ ps:蘋果電腦macOS、linux系統(centos7、rhel7...等)自帶python2.7 4.安裝(如本頁後面:mac、windows電腦安裝python解釋器(多版本)) 自訂安裝 路徑盡量簡單一些 示範:windows電腦、mac電腦 5.使用 1.windows+r 2.輸入cmd回車 3.切換盤符 C: 4.切換目錄 cd python38 5.運行解釋器 python 6.退出解釋器 exit() 7.退到上一層目錄 cd .. 運行python程序的三種方式 1.cmd直接編寫運行 適用於較短 臨時執行的代碼 2.解釋器命令運行 可以編寫較長的代碼 並且可以長久保存 3.利用IDE工具編寫並運行 IDE開發者工具:自動提示 攜帶各種功能插件 編寫程式碼效率更高更快 1.sublime 2.vscode 3.pycharm cmd直接編寫運行 解釋器命令運行 利用IDE工具編寫並運行(pycharm 2021.3.3) mac、windows電腦安裝python解釋器(多版本) mac電腦安裝python解釋器(多版本) 官網Downloads網址：https://www.python.org/downloads/macos/\n1. Downloads 2. 找到要安裝的版本 3. 全程點繼續，完成安裝 4. 打開termimel，可以看到使用者環境變數已自動加上python3.9路徑 5. 直接可以使用 6. 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6本版的 Downloads 找到要安裝的版本，因為我的電腦是m1晶片，所以就不能選擇intel-only，選擇universal2 全程點繼續，完成安裝 打開termimel，可以看到使用者環境變數已自動加上python3.9路徑 直接可以使用 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6本版的 可以看到使用者環境變數也已自動加上python3.8路徑\nwindows電腦安裝python解釋器(多版本) 官網Downloads網址：https://www.python.org/downloads/windows/\n1. Downloads 2. 找到要安裝的版本 3. 注意，點選Customize installation 4. 打開termimel，到安裝目錄下 5. 可以看到有一個python.exe檔案，執行即可使用 6. 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可 7. 每次都要到安裝目錄下，才能使用python，故將路徑直接加入環境變數。 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 Downloads 找到要安裝的版本，因為我的電腦是w11 64bit，所以選擇Windows installer (64-bit) 注意，點選Customize installation，自訂安裝路徑，不然原安裝路徑名稱非常長，以後要找，不易 我選擇在C:\\，創建一個python39資料夾，將python3.9安裝在此位置 打開termimel，到安裝目錄下 可以看到有一個python.exe檔案，執行即可使用 要使用多版本共存，同前面1~3步驟，到官網下載並安裝版本即可，我這裡示範3.8.6、本版的 我選擇在C:\\，創建一個python38資料夾，將python3.8安裝在此位置\n每次都要到安裝目錄下，才能使用python，故將路徑直接加入環境變數。 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 7.1 將各版本目錄下python.exe再複製出來，並命名為版本號 7.2 檔案總管-\u0026gt;本機右鍵-\u0026gt;內容 7.3 進階系統設定-\u0026gt;環境變數 7.4 找到系統變數-\u0026gt;path點兩下 7.5 新增C:\\python38、C:\\python38\\Scripts、C:\\python39、C:\\python39\\Scripts，確認 7.6 開啟terminel測試 YouTube教學影片 ","date":"2023-10-07T02:50:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day02/","title":"Day02 - 計算機三大核心，操作系統，程式語言分類，Python解釋器，Mac、Windows電腦安裝Python解釋器"},{"content":"計算機五大組成部分 控制器 似大腦控制各器官與四肢 運算器 似大腦運算，邏輯思考 存儲器 似人記憶，短期記憶(記憶體)，長期記憶(硬盤) 輸入設備 似眼睛，接收外在訊息 輸出設備 似嘴巴，講述想法 計算機單位與轉換 1 Byte = 8 bit 1024Byte = 1KB 1024KB = 1MB 1024MB = 1GB 1024GB = 1TB 二進制、十六進制、十進制、八進制 的轉換 自我介绍 就學歷程 高中：就讀普通高中，讀2類自然組，對化學很有興趣，也考過全校化學競賽第一名，代表學校去參加全市比賽，但沒得名。 就是在那次比賽後，有深刻的體悟，普通高中，實作實驗真的太少，去比賽時，幾乎都是實作實驗，讓我不知所措，才會再報考大學時，轉而去讀科技大學，希望能學到一技之常。\n大學：就讀科技大學電機系，果然是科技大學，很多都是實作課，那時候才發現我與同學們的差距那麼大，因為他們幾乎都是專科進來的，所以大部分實驗，很多都接觸過了，我那時候連麵包版都不會插，電阻看不懂，剛開始實在是超辛苦，還好有同儕的教學，讓我挺過來。\n當兵：海軍陸戰隊，戰車營，去新竹受訓3個月，回來營上，開戰車下基地，是我人生中，非常特殊的回憶。\n工作經歷 弱電工程師：不超過110V的工程都做，佈網路線、電話線、監控、廣播，建置網路機房\u0026hellip;等，全台有配合的裝修場、配合的維護銀行，都要跑。做了3年半，做到主任，但考量薪水、工作環境差、未來規劃，裸辭，決定轉職進IT領域。\n特訓班：前份工作裸辭，就是為了能進特訓班，此特訓班不用費用，但前提是要沒有工作的人(就是勞動部幫助失業的人轉職)，同時也要進過考試和面試，學習到的課程：Windows Server管理、Linux Server管理、Cisco網路設備管理。(特訓完：考取CCNA證照)\n網路FAE：特訓班結訓後，進入通路商，負責公司販賣的網路設備售後技術支援。\nMIS：和網路FAE是同一家公司，因為公司內部缺網管，長官希望我過去幫忙，就內轉到MIS部門，負責公司內部網路、伺服器建置與管理，會選擇離開，主要是MIS負責太多事了，沒辦法專心在一個領域技術提升。(考取：CCNP證照、RHCSA7證照、RCHE7證照、RHCSA8證照)\n電商伺服器工程師：到此公司，就是專門負責電商對外伺服器管理和建置，原則上就幾乎都是linux系統和pve虛擬化系統，會選擇只做4個月就離開，主要是因為公司文化、公司凝聚力、部門間協調、SOP不明確、公司不賺錢，基於以上原因，才會選擇盡快離開。當然在此公司是非常好的經歷，因為電商領域，就是我轉職到IT時，一直想走上的路，也算讓我進到這個領域有了第一個敲門磚。\n電商伺服器 資深工程師：負責電商伺服器管理與建置、Redis服務管理與建置、K8S平台管理與建置、目前自學Python、前端、Django，主要是為了讓管理方式能更有效率、更系統化。目前在公司也會安排向內部員工進行教育訓練課程、分享技術，讓我在此工作上得到滿滿的成就感。就我自己認為，會再多，如果不能說到讓別人也瞭解，那就不是真的瞭解這個技術了。所以我熱衷於這份工作，能讓我分享技術，公司也不斷的引進新技術、新想法，讓我們去嘗試，所以目前在此工作，是非常開心的狀態，希望這種感覺，能一直持續下去。(考取：CKA證照、CKAD證照、CKS證照)\nYouTube教學影片 ","date":"2023-10-07T02:45:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/python-self-learning-day01/","title":"Day01 - 計算機五大組成、三大核心、自我介紹"},{"content":"\n一、節點規劃 部署k8s集群的節點按照用途可以劃分為如下2類角色：\nmaster：集群的master節點，集群的初始化節點，基礎配置不低於2C4G node：集群的node節點，可以多台，基礎配置不低於2C4G K8S實體機網段: 192.168.1.0/24\nPOD網段: 10.244.0.0/16\nSERVICE網段: 10.245.0.0/16\n主機名 節點ip 角色 部署組件 k8s-master71u 192.168.1.71 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico k8s-master72u 192.168.1.72 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico k8s-master73u 192.168.1.73 master etcd, kube-apiserver, kube-controller-manager, kubectl, kubeadm, kubelet, kube-proxy, calico 192.168.1.74 VIP 作為3台master節點的LB使用 k8s-node75u k8s-node75u node kubectl, kubelet, kube-proxy, calico k8s-node76u k8s-node76u node kubectl, kubelet, kube-proxy, calico 二、組件版本 組件 版本 說明 Ubuntu 22.04.3 LTS Kernel 5.15.0-83-generic etcd 3.5.6-0 使用Pod方式部署，默認數據掛載到本地路徑 coredns v1.9.3 kubeadm v1.26.3 kubectl v1.26.3 kubelet v1.26.3 kube-proxy v1.26.3 calico v3.26.0 cri-dockerd 0.3.3.3-0 安裝前準備 一、設置hosts解析 操作節點：所有節點（k8s-master，k8s-node）均需執行\n添加hosts解析 root@k8s-master71u:~# cat \u0026gt;\u0026gt;/etc/hosts\u0026lt;\u0026lt;EOF 192.168.1.71 k8s-master71u 192.168.1.72 k8s-master72u 192.168.1.73 k8s-master73u 192.168.1.75 k8s-node75u 192.168.1.76 k8s-node76u EOF root@k8s-master71u:~# cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 k8s-master71u # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 192.168.1.71 k8s-master71u 192.168.1.72 k8s-master72u 192.168.1.73 k8s-master73u 192.168.1.75 k8s-node75u 192.168.1.76 k8s-node76u 二、調整系統配置 操作節點： 所有的master和node節點（k8s-master,k8s-node）需要執行\n本章下述操作均以k8s-master為例，其他節點均是相同的操作（ip和hostname的值換成對應機器的真實值）\n設置安全組開放端口 如果節點間無安全組限制（內網機器間可以任意訪問），可以忽略，否則，至少保證如下端口可通： k8s-master節點：TCP：6443，2379，2380，60080，60081UDP協議端口全部打開 k8s-node節點：UDP協議端口全部打開\n關閉防火牆 root@k8s-master71u:~# ufw status Status: inactive 關閉swap root@k8s-master71u:~# swapoff -a \u0026amp;\u0026amp; sysctl -w vm.swappiness=0 vm.swappiness = 0 root@k8s-master71u:~# sed -i \u0026#39;s/.*swap.*/#\u0026amp;/g\u0026#39; /etc/fstab #/dev/disk/by-id/dm-uuid-LVM-kAtY9KpfwxzNTDEpBzFkOODzcZgK93hc3OfpHLBwOVbgBZUOZC21pLNScKzDP2aI none swap sw 0 0 修改內核參數 root@k8s-master71u:~# cat \u0026lt;\u0026lt;EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF root@k8s-master71u:~# systemctl restart systemd-modules-load.service root@k8s-master71u:~# systemctl status systemd-modules-load.service ● systemd-modules-load.service - Load Kernel Modules Loaded: loaded (/lib/systemd/system/systemd-modules-load.service; static) Active: active (exited) since Wed 2023-09-20 00:23:11 UTC; 6s ago Docs: man:systemd-modules-load.service(8) man:modules-load.d(5) Process: 2322 ExecStart=/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS) Main PID: 2322 (code=exited, status=0/SUCCESS) CPU: 39ms Sep 20 00:23:11 k8s-master71u systemd[1]: Starting Load Kernel Modules... Sep 20 00:23:11 k8s-master71u systemd-modules-load[2322]: Inserted module \u0026#39;overlay\u0026#39; Sep 20 00:23:11 k8s-master71u systemd-modules-load[2322]: Inserted module \u0026#39;br_netfilter\u0026#39; Sep 20 00:23:11 k8s-master71u systemd[1]: Finished Load Kernel Modules. root@k8s-master71u:~# lsmod |grep -e overlay overlay 151552 0 root@k8s-master71u:~# lsmod |grep -e br_netfilter br_netfilter 32768 0 bridge 307200 1 br_netfilter root@k8s-master71u:~# cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf vm.max_map_count=262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory=1 vm.panic_on_oom=0 fs.inotify.max_user_watches=89100 fs.file-max=52706963 fs.nr_open=52706963 net.netfilter.nf_conntrack_max=2310720 net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl =15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 EOF root@k8s-master71u:~# sysctl -p /etc/sysctl.d/k8s.conf vm.max_map_count = 262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory = 1 vm.panic_on_oom = 0 fs.inotify.max_user_watches = 89100 fs.file-max = 52706963 fs.nr_open = 52706963 sysctl: cannot stat /proc/sys/net/netfilter/nf_conntrack_max: No such file or directory net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl = 15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 # 報錯 sysctl: cannot stat /proc/sys/net/netfilter/nf_conntrack_max: 沒有此一檔案或目錄 # 解決方式 root@k8s-master71u:~# modprobe ip_conntrack root@k8s-master71u:~# sysctl -p /etc/sysctl.d/k8s.conf vm.max_map_count = 262144 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 vm.overcommit_memory = 1 vm.panic_on_oom = 0 fs.inotify.max_user_watches = 89100 fs.file-max = 52706963 fs.nr_open = 52706963 net.netfilter.nf_conntrack_max = 2310720 net.ipv4.tcp_keepalive_time = 600 net.ipv4.tcp_keepalive_probes = 3 net.ipv4.tcp_keepalive_intvl = 15 net.ipv4.tcp_max_tw_buckets = 36000 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_max_orphans = 327680 net.ipv4.tcp_orphan_retries = 3 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_max_syn_backlog = 16384 net.ipv4.tcp_timestamps = 0 net.core.somaxconn = 16384 添加ipvs，安裝套件 root@k8s-master71u:~# apt -y install ipvsadm ipset sysstat conntrack libseccomp2 libseccomp-dev root@k8s-master71u:~# cat \u0026gt; /etc/modules-load.d/ipvs.conf \u0026lt;\u0026lt; EOF ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_fo ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack ip_tables ip_set xt_set ipt_set ipt_rpfilter ipt_REJECT ipip EOF root@k8s-master71u:~# systemctl restart systemd-modules-load.service root@k8s-master71u:~# systemctl status systemd-modules-load.service ● systemd-modules-load.service - Load Kernel Modules Loaded: loaded (/lib/systemd/system/systemd-modules-load.service; static) Active: active (exited) since Wed 2023-09-20 00:28:06 UTC; 7s ago Docs: man:systemd-modules-load.service(8) man:modules-load.d(5) Process: 3116 ExecStart=/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS) Main PID: 3116 (code=exited, status=0/SUCCESS) CPU: 76ms Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_fo\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_nq\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_sed\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_vs_ftp\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ip_set\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;xt_set\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipt_rpfilter\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipt_REJECT\u0026#39; Sep 20 00:28:06 k8s-master71u systemd-modules-load[3116]: Inserted module \u0026#39;ipip\u0026#39; Sep 20 00:28:06 k8s-master71u systemd[1]: Finished Load Kernel Modules. root@k8s-master71u:~# lsmod |grep -e ip_vs -e nf_conntrack_ipv4 ip_vs_ftp 16384 0 nf_nat 49152 1 ip_vs_ftp ip_vs_sed 16384 0 ip_vs_nq 16384 0 ip_vs_fo 16384 0 ip_vs_sh 16384 0 ip_vs_dh 16384 0 ip_vs_lblcr 16384 0 ip_vs_lblc 16384 0 ip_vs_wrr 16384 0 ip_vs_rr 16384 0 ip_vs_wlc 16384 0 ip_vs_lc 16384 0 ip_vs 176128 24 ip_vs_wlc,ip_vs_rr,ip_vs_dh,ip_vs_lblcr,ip_vs_sh,ip_vs_fo,ip_vs_nq,ip_vs_lblc,ip_vs_wrr,ip_vs_lc,ip_vs_sed,ip_vs_ftp nf_conntrack 172032 2 nf_nat,ip_vs nf_defrag_ipv6 24576 2 nf_conntrack,ip_vs libcrc32c 16384 7 nf_conntrack,nf_nat,btrfs,nf_tables,xfs,raid456,ip_vs 三、安裝docker 所有的master和node節點（k8s-master,k8s-node）需要執行\nhttps://docs.docker.com/engine/install/ubuntu/\n# 1. Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install ca-certificates curl gnupg # 2. Add Docker’s official GPG key: sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # 3. Use the following command to set up the repository: echo \\ \u0026#34;deb [arch=\u0026#34;$(dpkg --print-architecture)\u0026#34; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \u0026#34;$(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)\u0026#34; stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/docker.list deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu jammy stable # 5. Update the apt package index sudo apt-get update # 查看所有的可用版本 root@k8s-master71u:~# apt-cache madison docker-ce | awk \u0026#39;{ print $3 }\u0026#39; 5:24.0.6-1~ubuntu.22.04~jammy 5:24.0.5-1~ubuntu.22.04~jammy 5:24.0.4-1~ubuntu.22.04~jammy 5:24.0.3-1~ubuntu.22.04~jammy 5:24.0.2-1~ubuntu.22.04~jammy 5:24.0.1-1~ubuntu.22.04~jammy 5:24.0.0-1~ubuntu.22.04~jammy 5:23.0.6-1~ubuntu.22.04~jammy 5:23.0.5-1~ubuntu.22.04~jammy 5:23.0.4-1~ubuntu.22.04~jammy 5:23.0.3-1~ubuntu.22.04~jammy 5:23.0.2-1~ubuntu.22.04~jammy 5:23.0.1-1~ubuntu.22.04~jammy 5:23.0.0-1~ubuntu.22.04~jammy 5:20.10.24~3-0~ubuntu-jammy 5:20.10.23~3-0~ubuntu-jammy 5:20.10.22~3-0~ubuntu-jammy 5:20.10.21~3-0~ubuntu-jammy 5:20.10.20~3-0~ubuntu-jammy 5:20.10.19~3-0~ubuntu-jammy 5:20.10.18~3-0~ubuntu-jammy 5:20.10.17~3-0~ubuntu-jammy 5:20.10.16~3-0~ubuntu-jammy 5:20.10.15~3-0~ubuntu-jammy 5:20.10.14~3-0~ubuntu-jammy 5:20.10.13~3-0~ubuntu-jammy # 指定版本，安裝docker-ce root@k8s-master71u:~# VERSION_STRING=5:20.10.13~3-0~ubuntu-jammy root@k8s-master71u:~# sudo apt-get install docker-ce=$VERSION_STRING docker-ce-cli=$VERSION_STRING containerd.io ## 配置docker使用cgroupdriver=systemd root@k8s-master71u:~# mkdir -p /etc/docker root@k8s-master71u:~# vim /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] } root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl restart docker ## 啟動docker root@k8s-master71u:~# systemctl enable docker \u0026amp;\u0026amp; systemctl start docker root@k8s-master71u:~# systemctl status docker ## 測試起一個容器 root@k8s-master71u:~# sudo docker run hello-world Unable to find image \u0026#39;hello-world:latest\u0026#39; locally latest: Pulling from library/hello-world 719385e32844: Pull complete Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db Status: Downloaded newer image for hello-world:latest Hello from Docker! 四、安裝cri-docker 所有的master和node節點（k8s-master,k8s-node）需要執行\nhttps://github.com/Mirantis/cri-dockerd\nroot@k8s-master71u:~# wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.3/cri-dockerd_0.3.3.3-0.ubuntu-jammy_amd64.deb root@k8s-master71u:~# sudo dpkg -i cri-dockerd_0.3.3.3-0.ubuntu-jammy_amd64.deb root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl enable cri-docker \u0026amp;\u0026amp; systemctl start cri-docker \u0026amp;\u0026amp; systemctl status cri-docker ● cri-docker.service - CRI Interface for Docker Application Container Engine Loaded: loaded (/lib/systemd/system/cri-docker.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2023-09-20 00:44:58 UTC; 25s ago TriggeredBy: ● cri-docker.socket Docs: https://docs.mirantis.com Main PID: 5055 (cri-dockerd) Tasks: 10 Memory: 9.8M CPU: 83ms CGroup: /system.slice/cri-docker.service └─5055 /usr/bin/cri-dockerd --container-runtime-endpoint fd:// Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Start docker client with reque\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Hairpin mode is set to none\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Loaded network plugin cni\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker cri networking managed \u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker Info: \u0026amp;{ID:ZVOJ:5V6C:QO\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Setting cgroupDriver systemd\u0026#34; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Docker cri received runtime co\u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Starting the GRPC backend for \u0026gt; Sep 20 00:44:58 k8s-master71u cri-dockerd[5055]: time=\u0026#34;2023-09-20T00:44:58Z\u0026#34; level=info msg=\u0026#34;Start cri-dockerd grpc backend\u0026#34; Sep 20 00:44:58 k8s-master71u systemd[1]: Started CRI Interface for Docker Application Container Engine. 初始化集群 一、安裝kubeadm、kubelet、kubectl 操作節點： 所有的master和node節點(k8s-master,k8s-node) 需要執行\nhttps://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n# 1. Update the apt package index and install packages needed to use the Kubernetes apt repository: sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl # 2. Download the Google Cloud public signing key: curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg # 3. Add the Kubernetes apt repository: echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/kubernetes.list deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main # 5. Update apt package index, install kubelet, kubeadm and kubectl, and pin their version: sudo apt-get update root@k8s-master71u:~# sudo apt-get install -y kubelet=1.26.3-00 kubeadm=1.26.3-00 kubectl=1.26.3-00 ## 查看kubeadm 版本 root@k8s-master71u:~# kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;26\u0026#34;, GitVersion:\u0026#34;v1.26.3\u0026#34;, GitCommit:\u0026#34;9e644106593f3f4aa98f8a84b23db5fa378900bd\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2023-03-15T13:38:47Z\u0026#34;, GoVersion:\u0026#34;go1.19.7\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} ## 設置kubelet開機啟動，並使用ipvs與systemd root@k8s-master71u:~# vim /etc/default/kubelet KUBE_PROXY_MODE=\u0026#34;ipvs\u0026#34; KUBELET_EXTRA_ARGS=\u0026#34;--cgroup-driver=systemd --pod-infra-container-image=registry.k8s.io/pause:3.6\u0026#34; root@k8s-master71u:~# systemctl enable --now kubelet 二、安裝配置haproxy、keepalived 操作節點： 所有的master\n注意：如果有兩個集群，都在同一網段內，/etc/keepalived/keepalived.conf裡面的virtual_router_id 60記得要不一樣，不然/var/log/message會一直報錯。\nroot@k8s-master71u:~# apt-get install keepalived haproxy -y # 所有master節點執行,注意替換最後的master節點IP地址 root@k8s-master71u:~# vim /etc/haproxy/haproxy.cfg global maxconn 2000 ulimit-n 16384 log 127.0.0.1 local0 err stats timeout 30s defaults log global mode http option httplog timeout connect 5000 timeout client 50000 timeout server 50000 timeout http-request 15s timeout http-keep-alive 15s frontend monitor-in bind *:33305 mode http option httplog monitor-uri /monitor frontend k8s-master bind 0.0.0.0:7443 bind 127.0.0.1:7443 mode tcp option tcplog tcp-request inspect-delay 5s default_backend k8s-master backend k8s-master mode tcp option tcplog option tcp-check balance roundrobin default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100 server k8s-master71u 192.168.1.71:6443 check server k8s-master72u 192.168.1.72:6443 check server k8s-master73u 192.168.1.73:6443 check # 在k8s-master71u節點，注意mcast_src_ip換成實際的master1ip地址，virtual_ipaddress換成lb地址，interface要替換成主機IP使用的介面 root@k8s-master71u:~# vim /etc/keepalived/keepalived.conf ! Configuration File for keepalived global_defs { router_id LVS_DEVEL script_user root enable_script_security } vrrp_script chk_apiserver { script \u0026#34;/etc/keepalived/check_apiserver.sh\u0026#34; interval 5 weight -5 fall 2 rise 1 } vrrp_instance VI_1 { state MASTER interface ens160 mcast_src_ip 192.168.1.71 virtual_router_id 60 priority 101 advert_int 2 authentication { auth_type PASS auth_pass K8SHA_KA_AUTH } virtual_ipaddress { 192.168.1.74 } track_script { chk_apiserver } } # 在k8s-master52u和k8s-master53u分別創建/etc/keepalived/keepalived.conf，注意修改mcast_src_ip和virtual_ipaddress #所有master節點配置KeepAlived健康檢查文件： root@k8s-master71u:~# vim /etc/keepalived/check_apiserver.sh #!/bin/bash err=0 for k in $(seq 1 3) do check_code=$(pgrep haproxy) if [[ $check_code == \u0026#34;\u0026#34; ]]; then err=$(expr $err + 1) sleep 1 continue else err=0 break fi done if [[ $err != \u0026#34;0\u0026#34; ]]; then echo \u0026#34;systemctl stop keepalived\u0026#34; /usr/bin/systemctl stop keepalived exit 1 else exit 0 fi # 啟動haproxy和keepalived----\u0026gt;所有master節點 root@k8s-master71u:~# chmod +x /etc/keepalived/check_apiserver.sh root@k8s-master71u:~# systemctl daemon-reload root@k8s-master71u:~# systemctl enable --now haproxy root@k8s-master71u:~# systemctl enable --now keepalived root@k8s-master71u:~# systemctl restart haproxy root@k8s-master71u:~# systemctl restart keepalived root@k8s-master71u:~# systemctl status haproxy root@k8s-master71u:~# systemctl status keepalived # 測試lbip是否生效(從node節點測試的) root@k8s-node76u:~# telnet 192.168.1.74 7443 Trying 192.168.1.74... Connected to 192.168.1.74. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. 三、初始化配置文件 操作節點： 只在master節點（k8s-master）執行\nhttps://kubernetes.io/docs/reference/config-api/kubeadm-config.v1beta3/\n# 1.24.0版本之後，需修改為criSocket: unix:///var/run/cri-dockerd.sock # 1.27.x版本之後，需修改為apiVersion: kubeadm.k8s.io/v1beta3，v1beta2不能用了 # imageRepository: k8s.gcr.io已不更新，改imageRepository: registry.k8s.io # clusterName: kubernetes -\u0026gt;依自己需求修改 # dns: type: CoreDNS 已棄用，不用寫 root@k8s-master71u:~# vim kubeadm.yaml apiVersion: kubeadm.k8s.io/v1beta3 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: 7t2weq.bjbawausm0jaxury ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration localAPIEndpoint: advertiseAddress: 192.168.1.71 bindPort: 6443 nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock name: k8s-master71u taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: certSANs: - 192.168.1.74 timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta3 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controlPlaneEndpoint: 192.168.1.74:7443 controllerManager: {} etcd: local: dataDir: /var/lib/etcd imageRepository: registry.k8s.io kind: ClusterConfiguration kubernetesVersion: v1.26.3 networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 serviceSubnet: 10.245.0.0/16 scheduler: {} 四、提前下載鏡像 操作節點：所有master節點執行\nroot@k8s-master71u:~# kubeadm config images list --config kubeadm.yaml registry.k8s.io/kube-apiserver:v1.26.3 registry.k8s.io/kube-controller-manager:v1.26.3 registry.k8s.io/kube-scheduler:v1.26.3 registry.k8s.io/kube-proxy:v1.26.3 registry.k8s.io/pause:3.9 registry.k8s.io/etcd:3.5.6-0 registry.k8s.io/coredns/coredns:v1.9.3 root@k8s-master71u:~# kubeadm config images pull --config kubeadm.yaml [config/images] Pulled registry.k8s.io/kube-apiserver:v1.26.3 [config/images] Pulled registry.k8s.io/kube-controller-manager:v1.26.3 [config/images] Pulled registry.k8s.io/kube-scheduler:v1.26.3 [config/images] Pulled registry.k8s.io/kube-proxy:v1.26.3 [config/images] Pulled registry.k8s.io/pause:3.9 [config/images] Pulled registry.k8s.io/etcd:3.5.6-0 [config/images] Pulled registry.k8s.io/coredns/coredns:v1.9.3 五、初始化master節點 操作節點：只在master節點（k8s-master）執行，找一台master執行即可\nroot@k8s-master71u:~# kubeadm init --config kubeadm.yaml --upload-certs ## 若初始化成功後，最後會提示如下信息： Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of the control-plane node running the following command on each as root: kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a Please note that the certificate-key gives access to cluster sensitive data, keep it secret! As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use \u0026#34;kubeadm init phase upload-certs --upload-certs\u0026#34; to reload certs afterward. Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 ## 接下來按照上述提示信息操作，配置kubectl客戶端的認證 root@k8s-master71u:~# mkdir -p $HOME/.kube root@k8s-master71u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master71u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config 若執行初始化過程中出錯，根據錯誤信息調整後，執行 kubeadm reset -f ; ipvsadm \u0026ndash;clear ; rm -rf ~/.kube ; rm -rf /etc/kubernetes/manifests/* ; rm -rf /var/lib/etcd/\n六、添加其他master節點到集群中 # k8s-master72u主機 root@k8s-master72u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a \\ --cri-socket=unix:///var/run/cri-dockerd.sock root@k8s-master72u:~# mkdir -p $HOME/.kube root@k8s-master72u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master72u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config # k8s-master73u主機 root@k8s-master73u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --control-plane --certificate-key a543d4775e0ca9787d4d2936758a3447d189cdae117170512b4de60a23b59e8a \\ --cri-socket=unix:///var/run/cri-dockerd.sock root@k8s-master73u:~# mkdir -p $HOME/.kube root@k8s-master73u:~# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config root@k8s-master73u:~# sudo chown $(id -u):$(id -g) $HOME/.kube/config 七、添加node節點到集群中 操作節點：所有的node節點（k8s-node）需要執行 在每台node節點，執行如下命令，該命令是在kubeadm init成功後提示信息中打印出來的，需要替換成實際init後打印出的命令。\n# k8s-node75u主機 root@k8s-node75u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --cri-socket=unix:///var/run/cri-dockerd.sock # k8s-node76u主機 root@k8s-node76u:~# kubeadm join 192.168.1.74:7443 --token 7t2weq.bjbawausm0jaxury \\ --discovery-token-ca-cert-hash sha256:86af29371fd57d46a8592782fb4ae158035711372c0541449dcadfdc8f7fc243 \\ --cri-socket=unix:///var/run/cri-dockerd.sock 如果忘記添加命令，可以通過如下命令生成：\n$ kubeadm token create --print-join-command 查看目前node狀況:\nroot@k8s-master71u:~# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master71u NotReady control-plane 10m v1.26.3 k8s-master72u NotReady control-plane 3m58s v1.26.3 k8s-master73u NotReady control-plane 2m57s v1.26.3 k8s-node75u NotReady \u0026lt;none\u0026gt; 55s v1.26.3 k8s-node76u NotReady \u0026lt;none\u0026gt; 51s v1.26.3 部署容器網絡（calico） 操作節點：只在master節點（k8s-master）執行，找一台master執行即可，CNI\nCalico是一個純三層的數據中心網絡方案，是目前Kubernetes主流的網絡方案。\nhttps://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart\nroot@k8s-master71u:~# mkdir calico root@k8s-master71u:~# cd calico/ root@k8s-master71u:~/calico# wget https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/tigera-operator.yaml root@k8s-master71u:~/calico# wget https://raw.githubusercontent.com/projectcalico/calico/v3.26.0/manifests/custom-resources.yaml root@k8s-master71u:~/calico# kubectl create -f tigera-operator.yaml # cidr ip部分，與前面kubeadm init的 --pod-network-cidr指定的一樣。 root@k8s-master71u:~/calico# vim custom-resources.yaml # This section includes base Calico installation configuration. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.Installation apiVersion: operator.tigera.io/v1 kind: Installation metadata: name: default spec: # Configures Calico networking. calicoNetwork: # Note: The ipPools section cannot be modified post-install. ipPools: - blockSize: 26 cidr: 10.244.0.0/16 encapsulation: VXLANCrossSubnet natOutgoing: Enabled nodeSelector: all() --- # This section configures the Calico API server. # For more information, see: https://projectcalico.docs.tigera.io/master/reference/installation/api#operator.tigera.io/v1.APIServer apiVersion: operator.tigera.io/v1 kind: APIServer metadata: name: default spec: {} root@k8s-master71u:~/calico# kubectl create -f custom-resources.yaml # 等Calico Pod都Running，節點也會准備就緒。 root@k8s-master71u:~/calico# kubectl get pods -n calico-system NAME READY STATUS RESTARTS AGE calico-kube-controllers-676484d755-9llvm 1/1 Running 0 16m calico-node-2s4gl 1/1 Running 0 16m calico-node-f9dz9 1/1 Running 0 16m calico-node-kvc55 1/1 Running 0 16m calico-node-l9gb2 1/1 Running 0 16m calico-node-xdp42 1/1 Running 0 16m calico-typha-98f544f9f-nqc4n 1/1 Running 0 16m calico-typha-98f544f9f-plpnn 1/1 Running 0 16m calico-typha-98f544f9f-vgrmn 1/1 Running 0 16m csi-node-driver-42c8p 2/2 Running 0 16m csi-node-driver-kdd42 2/2 Running 0 16m csi-node-driver-nxf5d 2/2 Running 0 16m csi-node-driver-rphdj 2/2 Running 0 16m csi-node-driver-shs2s 2/2 Running 0 16m root@k8s-master71u:~/calico# kubectl get node NAME STATUS ROLES AGE VERSION k8s-master71u Ready control-plane 31m v1.26.3 k8s-master72u Ready control-plane 24m v1.26.3 k8s-master73u Ready control-plane 23m v1.26.3 k8s-node75u Ready \u0026lt;none\u0026gt; 21m v1.26.3 k8s-node76u Ready \u0026lt;none\u0026gt; 21m v1.26.3 root@k8s-master71u:~/calico# kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE coredns-787d4945fb-6x8v2 1/1 Running 0 31m coredns-787d4945fb-ddpgp 1/1 Running 0 31m etcd-k8s-master71u 1/1 Running 0 31m etcd-k8s-master72u 1/1 Running 0 24m etcd-k8s-master73u 1/1 Running 0 23m kube-apiserver-k8s-master71u 1/1 Running 0 31m kube-apiserver-k8s-master72u 1/1 Running 0 24m kube-apiserver-k8s-master73u 1/1 Running 1 (23m ago) 23m kube-controller-manager-k8s-master71u 1/1 Running 1 (24m ago) 31m kube-controller-manager-k8s-master72u 1/1 Running 0 24m kube-controller-manager-k8s-master73u 1/1 Running 0 22m kube-proxy-4rtwz 1/1 Running 0 23m kube-proxy-84v9t 1/1 Running 0 24m kube-proxy-9bh8t 1/1 Running 0 21m kube-proxy-m5gj8 1/1 Running 0 21m kube-proxy-x4t5v 1/1 Running 0 31m kube-scheduler-k8s-master71u 1/1 Running 1 (24m ago) 31m kube-scheduler-k8s-master72u 1/1 Running 0 24m kube-scheduler-k8s-master73u 1/1 Running 0 22m 註：以後所有yaml文件都只在Master節點執行。\n安裝目錄：/etc/kubernetes/\n組件配置文件目錄：/etc/kubernetes/manifests/\n集群設置 設置master節點是否可調度（可選） 操作節點：k8s-master\n默認部署成功後，master節點無法調度業務pod，如需設置master節點也可以參與pod的調度，需執行：\n$ kubectl taint node k8s-master node-role.kubernetes.io/master:NoSchedule- 設置kubectl自動補全 操作節點：k8s-master\nroot@k8s-master71u:~# apt install -y bash-completion root@k8s-master71u:~# apt install plocate root@k8s-master71u:~# locate bash_completion root@k8s-master71u:~# source /usr/share/bash-completion/bash_completion root@k8s-master71u:~# source \u0026lt;(kubectl completion bash) root@k8s-master71u:~# echo \u0026#34;source \u0026lt;(kubectl completion bash)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 調整證書過期 使用kubeadm安裝的集群，證書默認有效期為1年，可以通過如下方式修改為10年。全部master節點都要執行\nroot@k8s-master71u:~/calico# cd /etc/kubernetes/pki root@k8s-master71u:/etc/kubernetes/pki# for i in $(ls *.crt); do echo \u0026#34;===== $i =====\u0026#34;; openssl x509 -in $i -text -noout | grep -A 3 \u0026#39;Validity\u0026#39; ; done ===== apiserver.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:27 2024 GMT Subject: CN = kube-apiserver ===== apiserver-etcd-client.crt ===== Validity Not Before: Sep 20 04:42:28 2023 GMT Not After : Sep 19 04:42:29 2024 GMT Subject: O = system:masters, CN = kube-apiserver-etcd-client ===== apiserver-kubelet-client.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:27 2024 GMT Subject: O = system:masters, CN = kube-apiserver-kubelet-client ===== ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = kubernetes ===== front-proxy-ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = front-proxy-ca ===== front-proxy-client.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 19 04:42:28 2024 GMT Subject: CN = front-proxy-client root@k8s-master71u:/etc/kubernetes/pki# mkdir backup_key; cp -rp ./* backup_key/ root@k8s-master71u:/etc/kubernetes/pki# git clone https://github.com/yuyicai/update-kube-cert.git root@k8s-master71u:/etc/kubernetes/pki# cd update-kube-cert/ root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# bash update-kubeadm-cert.sh all root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# kubectl -n kube-system delete po kube-apiserver-k8s-master71u kube-apiserver-k8s-master72u kube-apiserver-k8s-master73u kube-controller-manager-k8s-master71u kube-controller-manager-k8s-master72u kube-controller-manager-k8s-master73u kube-scheduler-k8s-master71u kube-scheduler-k8s-master72u kube-scheduler-k8s-master73u root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# kubectl get pod -n kube-system NAME READY STATUS RESTARTS AGE coredns-787d4945fb-6x8v2 1/1 Running 0 36m coredns-787d4945fb-ddpgp 1/1 Running 0 36m etcd-k8s-master71u 1/1 Running 0 36m etcd-k8s-master72u 1/1 Running 0 29m etcd-k8s-master73u 1/1 Running 0 28m kube-apiserver-k8s-master71u 1/1 Running 0 30s kube-apiserver-k8s-master72u 1/1 Running 0 30s kube-apiserver-k8s-master73u 1/1 Running 1 (28m ago) 30s kube-controller-manager-k8s-master71u 1/1 Running 1 (29m ago) 30s kube-controller-manager-k8s-master72u 1/1 Running 0 30s kube-controller-manager-k8s-master73u 1/1 Running 0 30s kube-proxy-4rtwz 1/1 Running 0 28m kube-proxy-84v9t 1/1 Running 0 29m kube-proxy-9bh8t 1/1 Running 0 26m kube-proxy-m5gj8 1/1 Running 0 26m kube-proxy-x4t5v 1/1 Running 0 36m kube-scheduler-k8s-master71u 1/1 Running 2 (69s ago) 30s kube-scheduler-k8s-master72u 1/1 Running 0 30s kube-scheduler-k8s-master73u 1/1 Running 0 30s root@k8s-master71u:/etc/kubernetes/pki/update-kube-cert# cd /etc/kubernetes/pki root@k8s-master71u:/etc/kubernetes/pki# for i in $(ls *.crt); do echo \u0026#34;===== $i =====\u0026#34;; openssl x509 -in $i -text -noout | grep -A 3 \u0026#39;Validity\u0026#39; ; done ===== apiserver.crt ===== Validity Not Before: Sep 20 05:17:58 2023 GMT Not After : Sep 17 05:17:58 2033 GMT Subject: CN = kube-apiserver ===== apiserver-etcd-client.crt ===== Validity Not Before: Sep 20 05:17:55 2023 GMT Not After : Sep 17 05:17:55 2033 GMT Subject: O = system:masters, CN = kube-apiserver-etcd-client ===== apiserver-kubelet-client.crt ===== Validity Not Before: Sep 20 05:17:58 2023 GMT Not After : Sep 17 05:17:58 2033 GMT Subject: O = system:masters, CN = kube-apiserver-kubelet-client ===== ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = kubernetes ===== front-proxy-ca.crt ===== Validity Not Before: Sep 20 04:42:27 2023 GMT Not After : Sep 17 04:42:27 2033 GMT Subject: CN = front-proxy-ca ===== front-proxy-client.crt ===== Validity Not Before: Sep 20 05:17:59 2023 GMT Not After : Sep 17 05:17:59 2033 GMT Subject: CN = front-proxy-client 驗證集群 操作節點： 在master節點（k8s-master）執行\nroot@k8s-master71u:~# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master71u Ready control-plane 39m v1.26.3 k8s-master72u Ready control-plane 32m v1.26.3 k8s-master73u Ready control-plane 31m v1.26.3 k8s-node75u Ready \u0026lt;none\u0026gt; 29m v1.26.3 k8s-node76u Ready \u0026lt;none\u0026gt; 29m v1.26.3 root@k8s-master71u:~# kubectl run test-nginx --image=nginx:alpine pod/test-nginx created root@k8s-master71u:~# kubectl get pod -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES test-nginx 1/1 Running 0 21s 10.244.255.195 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; root@k8s-master71u:~# curl 10.244.255.195 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2023-10-07T02:30:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-install/","title":"kubeadm安裝 高可用版(ubuntu2204+k8s版本1.26.3+docker+cri-docker)"},{"content":"\nRancher官網安裝網址： https://ranchermanager.docs.rancher.com/zh/pages-for-subheaders/rancher-on-a-single-node-with-docker\n最新版Rancher(v2.7.6)能夠納管的kubernetes版本為1.26.4： https://www.suse.com/suse-rancher/support-matrix/all-supported-versions/rancher-v2-7-6/ 一、Rancher Server安裝 一、使用docker起容器 root@k8s-node75u:~# sudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher root@k8s-node75u:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0e92a3ece9cd rancher/rancher \u0026#34;entrypoint.sh\u0026#34; 4 minutes ago Up About a minute 0.0.0.0:80-\u0026gt;80/tcp, :::80-\u0026gt;80/tcp, 0.0.0.0:443-\u0026gt;443/tcp, :::443-\u0026gt;443/tcp dreamy_rubin 二、查看初始密碼 root@k8s-node75u:~# docker logs 0e92a3ece9cd 2\u0026gt;\u0026amp;1 | grep \u0026#34;Bootstrap Password:\u0026#34; 2023/09/20 09:50:01 [INFO] Bootstrap Password: 79j4khgd9952rmn55kdntxt7kwxfn7f7dvpmrsgx6nr7wqblrtpp6l 三、登入 四、重新設定admin密碼 登入成功頁面 二、匯入現有集群 一、點選Import Existing 二、點選Import any Kubernetes cluster(Generic) 三、填寫Cluster Name(自己決定，以利後續辨識)，點選Create 四、創建之後，會有提供加入的方式，選擇第二項 # master節點執行 root@k8s-master71u:~# curl --insecure -sfL https://192.168.1.75/v3/import/ff4mlx8k768hsz8vmwl89lqhbmcsfbttkxqdtmk4m8pgqsrnd87pqc_c-m-gq2vbtfn.yaml | kubectl apply -f - # 查看pod是否都創建成功 root@k8s-master71u:~# kubectl get pod -n cattle-system -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES cattle-cluster-agent-6c97c478bb-mjgwg 1/1 Running 0 5m 10.244.14.137 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; cattle-cluster-agent-6c97c478bb-vdn59 1/1 Running 0 16m 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; rancher-webhook-74c9bd4d6-znrdp 1/1 Running 0 61s 10.244.255.201 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 五、確認現有集群已加入納管 加入rancher需要一點時間，請耐心等候，如果鏡像拉取失敗，可以手動去下載鏡像\n六、開啟Kubectl Shell介面，Rancher會臨時起一個容器來跑Shell指令，關閉Shell介面，容器就會刪除 root@k8s-master71u:~# kubectl get pod -n cattle-system -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES cattle-cluster-agent-6c97c478bb-mjgwg 1/1 Running 0 6m11s 10.244.14.137 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; cattle-cluster-agent-6c97c478bb-vdn59 1/1 Running 0 17m 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; dashboard-shell-75g77 2/2 Running 0 9s 10.244.255.202 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; rancher-webhook-74c9bd4d6-znrdp 1/1 Running 0 2m12s 10.244.255.201 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 三、加入Windows Server Active Directory (LDAP) Rancher官網設定網址： https://ranchermanager.docs.rancher.com/zh/how-to-guides/new-user-guides/authentication-permissions-and-global-configuration/authentication-config/configure-active-directory\n一、查看可以整合登入驗證的方式 二、創建AD使用者，供Rancher獲取ldap使用者資料 三、使用ldapsearch測試一下，是否可以查找到剛剛建立的使用者資訊 chenqingze@chenqingze-MBP ~ % ldapsearch -x -H \u0026#34;ldap://192.168.1.49:389\u0026#34; -D \u0026#34;jimmyhome\\rancheruser\u0026#34; -w \u0026#34;密碼\u0026#34; \\ -b \u0026#34;dc=jimmyhome,dc=tw\u0026#34; -s sub \u0026#34;sAMAccountName=rancheruser\u0026#34; # extended LDIF # # LDAPv3 # base \u0026lt;dc=jimmyhome,dc=tw\u0026gt; with scope subtree # filter: sAMAccountName=rancheruser # requesting: ALL # # rancheruser, Users, jimmyhome.tw dn: CN=rancheruser,CN=Users,DC=jimmyhome,DC=tw objectClass: top objectClass: person objectClass: organizationalPerson objectClass: user cn: rancheruser givenName: rancheruser distinguishedName: CN=rancheruser,CN=Users,DC=jimmyhome,DC=tw instanceType: 4 whenCreated: 20230920115311.0Z whenChanged: 20230920120448.0Z displayName: rancheruser uSNCreated: 16399 uSNChanged: 16452 name: rancheruser objectGUID:: B9nTPDTyY0ehHZz4mWIJ1Q== userAccountControl: 66048 badPwdCount: 0 codePage: 0 countryCode: 0 badPasswordTime: 0 lastLogoff: 0 lastLogon: 0 pwdLastSet: 133396843913520620 primaryGroupID: 513 objectSid:: AQUAAAAAAAUVAAAA2KPkIYA62ax0WlhyTwQAAA== accountExpires: 9223372036854775807 logonCount: 0 sAMAccountName: rancheruser sAMAccountType: 805306368 userPrincipalName: rancheruser@jimmyhome.tw objectCategory: CN=Person,CN=Schema,CN=Configuration,DC=jimmyhome,DC=tw dSCorePropagationData: 16010101000000.0Z lastLogonTimestamp: 133396850882972826 # search reference ref: ldap://ForestDnsZones.jimmyhome.tw/DC=ForestDnsZones,DC=jimmyhome,DC=tw # search reference ref: ldap://DomainDnsZones.jimmyhome.tw/DC=DomainDnsZones,DC=jimmyhome,DC=tw # search reference ref: ldap://jimmyhome.tw/CN=Configuration,DC=jimmyhome,DC=tw # search result search: 2 result: 0 Success # numResponses: 5 # numEntries: 1 # numReferences: 3 四、整合AD驗證 確認驗證成功，連接到ldap 可以看到，此時已經自動改成用剛剛驗證的ad帳戶登入了 五、再到AD創建一個使用者，驗證一下，是否Rancher可以獲取到此使用者帳號 編輯default project(裡面只有一個default namespace) 添加ldap帳號 可以看到有jimmy帳號 添加此帳號 登出Rancher，改用jimmy帳號登入，密碼是ad中設定的密碼 確認可以登入 可以看到，能查看到default project與default namespace dashboard shell也是可以使用的，但只能看到default namespace的資源 是無法查看kube-system namespace的資源，確實跟前面設定的權限是符合的 六、也可以下載連線設定檔到自己常用linux主機，連線管理 # 1. 將下載的設定檔，scp到常用linux主機 chenqingze@chenqingze-MBP ~ % scp /Users/chenqingze/Downloads/kubernetes-config.yml root@192.168.1.76:/root/ # 2. 可以看到設定檔 root@k8s-node76u:~# ls -l total 9376 -rw-r--r-- 1 root root 1396 Sep 20 12:47 kubernetes-config.yml # 3. 在使用者家目錄下，創建.kube目錄 root@k8s-node76u:~# mkdir .kube # 4. 將設定檔複製到.kube目錄，且命名為config(因kubectl預設就是用.kube/config設定檔連線) root@k8s-node76u:~# cp kubernetes-config.yml ~/.kube/config # 5. 確認可以連線，查看default namespace下的資源 root@k8s-node76u:~# kubectl get pod NAME READY STATUS RESTARTS AGE test-nginx 1/1 Running 1 (3h20m ago) 7h26m # 6. 其他namespace下的資源，是無法查看的 root@k8s-node76u:~# kubectl get pod -n kube-system Error from server (Forbidden): pods is forbidden: User \u0026#34;u-hx7xy6ap22\u0026#34; cannot list resource \u0026#34;pods\u0026#34; in API group \u0026#34;\u0026#34; in the namespace \u0026#34;kube-system\u0026#34; ","date":"2023-10-07T02:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-docker/","title":"使用Docker安裝Rancher管理平台，納管現有k8s集群(單節點-非高可用)"},{"content":"\n安裝先決條件：\nkubernetes 集群 Ingress Controller Helm 、kubectl CLI 工具 一、Ingress Controller安裝 github網址:\nhttps://github.com/kubernetes/ingress-nginx\nchenqingze@chenqingze-MBP ~ % scp /Users/chenqingze/Downloads/ingress-nginx-controller-v1.6.4.tar.gz root@192.168.1.71:/root / root@k8s-master71u:~# tar -xzvf ingress-nginx-controller-v1.6.4.tar.gz root@k8s-master71u:~# cd ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal # Deployment改成DaemonSet # 添加hostNetwork: true root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# vim deploy.yaml --- apiVersion: apps/v1 kind: DaemonSet metadata: labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx app.kubernetes.io/version: 1.6.4 name: ingress-nginx-controller namespace: ingress-nginx spec: minReadySeconds: 0 revisionHistoryLimit: 10 selector: matchLabels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx template: metadata: labels: app.kubernetes.io/component: controller app.kubernetes.io/instance: ingress-nginx app.kubernetes.io/name: ingress-nginx spec: hostNetwork: true containers: root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# kubectl apply -f deploy.yaml root@k8s-master71u:~/ingress-nginx-controller-v1.6.4/deploy/static/provider/baremetal# kubectl get pod -n ingress-nginx -owide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES ingress-nginx-admission-create-zmkrl 0/1 Completed 0 73s 10.244.255.199 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-admission-patch-rlglf 0/1 Completed 0 73s 10.244.14.133 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-controller-js2fl 1/1 Running 0 73s 192.168.1.76 k8s-node76u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; ingress-nginx-controller-mmc2h 1/1 Running 0 73s 192.168.1.75 k8s-node75u \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 二、Kubectl與Helm CLI 工具安裝 官方安裝網站： https://helm.sh/docs/intro/install/\nHelm v3.12.3 Binary Releases： https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz\nroot@k8s-master71u:~# wget https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz root@k8s-master71u:~# tar -zxvf helm-v3.12.3-linux-amd64.tar.gz root@k8s-master71u:~# mv linux-amd64/helm /usr/local/bin/helm Kubectl： https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n如果主機就是master,應該都有kubectl了,此流程可以略過\n# 1. Update the apt package index and install packages needed to use the Kubernetes apt repository: sudo apt-get update sudo apt-get install -y apt-transport-https ca-certificates curl # 2. Download the Google Cloud public signing key: curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg # 3. Add the Kubernetes apt repository: echo \u0026#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\u0026#34; | sudo tee /etc/apt/sources.list.d/kubernetes.list # 4. 檢查是否已經添加源 root@k8s-master71u:~# cat /etc/apt/sources.list.d/kubernetes.list deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main # 5. Update apt package index, install kubelet, kubeadm and kubectl, and pin their version: sudo apt-get update root@k8s-master71u:~# sudo apt-get install -y kubectl=1.26.3-00 # 查看版本 root@k8s-master71u:~# kubectl version 三、Rancher高可用管理平台安裝 一、添加 Helm Chart 倉庫 root@k8s-master71u:~# helm repo add rancher-stable https://releases.rancher.com/server-charts/stable \u0026#34;rancher-stable\u0026#34; has been added to your repositories 二、為 Rancher 建立命名空間 root@k8s-master71u:~# kubectl create namespace cattle-system 三、選擇 SSL 配置 Rancher 產生的憑證（預設） 需要 cert-manager\n四、安裝 cert-manager # 如果你手動安裝了CRD，而不是在 Helm 安裝命令中添加了 \u0026#39;--set installCRDs=true\u0026#39; 選項，你應該在升級 Helm Chart 之前升級 CRD 資源。 root@k8s-master71u:~# kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.crds.yaml # 添加 Jetstack Helm 倉庫 root@k8s-master71u:~# helm repo add jetstack https://charts.jetstack.io # 更新本地 Helm Chart 倉庫緩存 root@k8s-master71u:~# helm repo update Hang tight while we grab the latest from your chart repositories... ...Successfully got an update from the \u0026#34;jetstack\u0026#34; chart repository ...Successfully got an update from the \u0026#34;rancher-stable\u0026#34; chart repository Update Complete. ⎈Happy Helming!⎈ # 安裝 cert-manager Helm Chart root@k8s-master71u:~# helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.11.0 # 安裝完 cert-manager 后，你可以通過檢查 cert-manager 命名空間中正在運行的 Pod 來驗證它是否已正確部署 root@k8s-master71u:~# kubectl get pods --namespace cert-manager NAME READY STATUS RESTARTS AGE cert-manager-64f9f45d6f-8j65z 1/1 Running 0 2m1s cert-manager-cainjector-56bbdd5c47-4hngr 1/1 Running 0 2m1s cert-manager-startupapicheck-vzq7z 0/1 Completed 0 2m cert-manager-webhook-d4f4545d7-rhbkv 1/1 Running 0 2m1s 五、根據你選擇的證書選項，通過 Helm 安裝 Rancher 採Rancher 生成的證書方式\nRancher Helm Chart 選項： https://ranchermanager.docs.rancher.com/zh/getting-started/installation-and-upgrade/installation-references/helm-chart-options\n需多指定ingressClassName為nginx\nroot@k8s-master71u:~# helm install rancher rancher-stable/rancher \\ --namespace cattle-system \\ --set hostname=rancher.jimmyhome.tw \\ --set bootstrapPassword=admin \\ --set ingress.ingressClassName=nginx NAME: rancher LAST DEPLOYED: Wed Sep 20 18:31:10 2023 NAMESPACE: cattle-system STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: Rancher Server has been installed. NOTE: Rancher may take several minutes to fully initialize. Please standby while Certificates are being issued, Containers are started and the Ingress rule comes up. Check out our docs at https://rancher.com/docs/ If you provided your own bootstrap password during installation, browse to https://rancher.jimmyhome.tw to get started. If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates: echo https://rancher.jimmyhome.tw/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}\u0026#39;) To get just the bootstrap password on its own, run: kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}{{ \u0026#34;\\n\u0026#34; }}\u0026#39; Happy Containering! # 等待 Rancher 運行 root@k8s-master71u:~# kubectl -n cattle-system rollout status deploy/rancher Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 0 of 3 updated replicas are available... Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 1 of 3 updated replicas are available... Waiting for deployment \u0026#34;rancher\u0026#34; rollout to finish: 2 of 3 updated replicas are available... deployment \u0026#34;rancher\u0026#34; successfully rolled out 六、驗證 Rancher Server 是否部署成功 root@k8s-master71u:~# kubectl -n cattle-system get deploy NAME READY UP-TO-DATE AVAILABLE AGE rancher 3/3 3 3 53s root@k8s-master71u:~# kubectl -n cattle-system get ingress NAME CLASS HOSTS ADDRESS PORTS AGE rancher nginx rancher.jimmyhome.tw 192.168.1.75,192.168.1.76 80, 443 67s # 我自己的筆電，先設定/etc/hosts測試網頁訪問 # 如是內部有dns server的，就到dns server設定a record解析 chenqingze@chenqingze-MBP ~ % sudo vim /etc/hosts 192.168.1.75 rancher.jimmyhome.tw 打 https://rancher.jimmyhome.tw 可以看到網頁 由上方helm install rancher完成時，可以看到以下兩個指令，可以獲取到預設admin帳號的密碼\n# If this is the first time you installed Rancher, get started by running this command and clicking the URL it generates root@k8s-master71u:~# echo https://rancher.jimmyhome.tw/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}\u0026#39;) https://rancher.jimmyhome.tw/dashboard/?setup=admin # To get just the bootstrap password on its own, run root@k8s-master71u:~# kubectl get secret --namespace cattle-system bootstrap-secret -o go-template=\u0026#39;{{.data.bootstrapPassword|base64decode}}{{ \u0026#34;\\n\u0026#34; }}\u0026#39; admin 重設admin帳號的密碼 輸入剛剛重設的admin密碼，登入 可以看到集群資訊，state為Active 進入集群，可以看到集群詳細訊息 也可以使用dashboard shell去管理集群 ","date":"2023-10-07T01:00:00+08:00","permalink":"https://blog.goldfishbrain-fighting.com/2023/kubernetes-helm/","title":"使用Helm安裝Rancher管理平台，納管現有k8s集群(高可用)"}]